/* Generated code for Python module 'site-packages.nuitka.nodes.shapes.StandardShapes'
 * created by Nuitka version 0.6.7
 *
 * This code is in part copyright 2019 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_site$$45$packages$nuitka$nodes$shapes$StandardShapes" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_site$$45$packages$nuitka$nodes$shapes$StandardShapes;
PyDictObject *moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes;

/* The declarations of module constants used, if any. */
static PyObject *const_str_digest_7180205ef64e9c18df2d09fcaaa43691;
static PyObject *const_str_digest_7e7788ccf7097b006f15d4ab18035078;
extern PyObject *const_str_plain_ControlFlowDescriptions;
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain___name__;
extern PyObject *const_str_plain_object;
static PyObject *const_str_digest_0594efac62700843ff32809de058caae;
extern PyObject *const_str_plain_hasShapeModule;
static PyObject *const_str_digest_4f26a96a64793f4392df8222281f5de5;
static PyObject *const_str_digest_3f0b0dc1a1fa3987ac4353534e0f5905;
static PyObject *const_str_digest_d5cbbc53e11173a4dca6aeb4d5ec4db4;
extern PyObject *const_str_plain_ShapeLoopInitialAlternative;
static PyObject *const_str_plain_getOperationBinaryMatMultLShape;
extern PyObject *const_str_plain___debug__;
extern PyObject *const_str_plain_getOperationBinaryMultShape;
extern PyObject *const_str_plain_truediv_shapes;
static PyObject *const_str_digest_dcf51f3801ec287eefe3cc0ece44bb21;
static PyObject *const_str_digest_0391c0c81b22fe4c6e9cfbfa036d7f29;
static PyObject *const_str_digest_df9171a19dc9056c92c0285a45a6639f;
extern PyObject *const_str_plain_emitAlternatives;
static PyObject *const_tuple_str_plain_self_str_plain_size_str_plain_shape_tuple;
extern PyObject *const_str_plain_getComparisonLteShape;
extern PyObject *const_str_plain_check;
extern PyObject *const_str_plain_hasShapeSlotAbs;
extern PyObject *const_str_plain_add_shapes;
extern PyObject *const_str_plain_hasShapeSlotBytes;
static PyObject *const_str_digest_625fe1e69ace93fc64749f3af6009f31;
static PyObject *const_str_plain_escape_description;
extern PyObject *const_str_plain_OBJECT;
extern PyObject *const_str_plain_predictor;
static PyObject *const_str_digest_210cf36a20d8be933983da1bd9dc5f0f;
static PyObject *const_str_digest_e93196de0aa84d7986fb4af03f1bcb72;
static PyObject *const_str_plain__collectInitialShape;
extern PyObject *const_str_plain_type_shape;
static PyObject *const_str_digest_abb5cd115195ebd171fd19240d19c05c;
extern PyObject *const_str_plain_CTypePyObjectPtr;
static PyObject *const_str_digest_b6d23c14d0d4bc9dad07080a16f71e1e;
static PyObject *const_str_digest_d8b645143e9f1a455e3cb5b0c969754d;
static PyObject *const_str_digest_1a03e9ce2e16071a8c173e0843bab7a2;
static PyObject *const_str_digest_9478741cfa8b1b672c5ae1b2d6fcd0f3;
extern PyObject *const_str_plain_sub_shapes;
static PyObject *const_str_digest_213535de2986e9fe33ceaa61e0fcca40;
static PyObject *const_str_digest_0251aa253c1cab7b3975aa8a056bcd59;
static PyObject *const_str_plain_right_shape_type;
static PyObject *const_str_digest_f38880eba632621d930a62348aff8df0;
static PyObject *const_str_digest_4f357c02d4f02597489b79e57bf68d5e;
extern PyObject *const_int_0;
static PyObject *const_str_digest_c7e895ad3a752f5af11608a55fc3e719;
static PyObject *const_str_digest_c54c54e35beee66a709658cabf4884cf;
static PyObject *const_str_digest_456552722d27a21eddbe73939e12677a;
static PyObject *const_str_digest_7a4c138f498be59b81e44a071ffe23e3;
extern PyObject *const_str_plain_mod_shapes;
extern PyObject *const_str_plain_shape;
extern PyObject *const_str_plain_type;
extern PyObject *const_tuple_str_plain_left_shape_str_plain_right_shape_tuple;
static PyObject *const_str_digest_950482538a86eb0630a1ab5b98519299;
extern PyObject *const_str_plain___cached__;
static PyObject *const_str_plain_matmult_shapes;
static PyObject *const_str_digest_ca1207a01fdb60ef20cd2cafffcf4764;
static PyObject *const_str_digest_76def7778bdd1aae29d1264a72a4ff16;
extern PyObject *const_str_plain_pow_shapes;
extern PyObject *const_str_plain_emit;
static PyObject *const_str_digest_a7c0071cf4b3200d86be5a79f1c38d4c;
extern PyObject *const_int_pos_1;
static PyObject *const_str_digest_c04892013b17346e0feb2d7582ab7ae0;
static PyObject *const_tuple_19e9cf822ef663d07339aa620df912db_tuple;
static PyObject *const_str_digest_d53a423951b232e18d93c9f1828c1a3f;
extern PyObject *const_str_plain_hasShapeSlotNext;
extern PyObject *const_str_plain_rshift_shapes;
extern PyObject *const_str_plain_hasShapeSlotComplex;
static PyObject *const_str_digest_b74e3483c0b7dc405673b6681b893ef1;
extern PyObject *const_str_plain___prepare__;
static PyObject *const_str_digest_6ab4c8ed7aba351c9a8e1e4e1a56ce1a;
extern PyObject *const_str_plain_getOperationBinaryRShiftShape;
static PyObject *const_str_digest_5fe1a7c4046b9f2044748f911c36403f;
static PyObject *const_str_digest_60d9f6c8d66361ecc95ade1ea639f1a2;
extern PyObject *const_str_plain_lshift_shapes;
static PyObject *const_str_digest_194ab90c00e030718b1d173955c51229;
extern PyObject *const_str_plain_hasShapeSlotLen;
static PyObject *const_str_digest_e8c3d9420556b2f8c1303cddaa3f8e40;
static PyObject *const_str_digest_d2189c374f6bb9323c899684884dea1a;
extern PyObject *const_str_plain_getComparisonEqShape;
static PyObject *const_str_digest_50adb2c3ec0e699614cd7fbbefc0169b;
static PyObject *const_str_digest_91cd369ed1b9a8fd6ffd7715f35cc157;
static PyObject *const_str_digest_a354cca5276535abe1bef4525c86cc54;
static PyObject *const_tuple_str_plain_predictor_tuple;
extern PyObject *const_str_plain_Mult;
static PyObject *const_str_digest_9028633f7a2e20ffed935d77dc3cfa39;
extern PyObject *const_str_plain___file__;
extern PyObject *const_tuple_str_plain_onMissingOperation_tuple;
static PyObject *const_str_digest_92d7bb3869456a3d13d0abb2a892ed4b;
extern PyObject *const_str_plain_bitxor_shapes;
extern PyObject *const_str_plain_entry;
static PyObject *const_str_digest_b58f205b283109589d6616923c5e38ce;
static PyObject *const_str_digest_9294d61dfee050890f7ed89747a17073;
static PyObject *const_str_digest_d2f1e24741c28a03ec32e5b3e138ec1d;
static PyObject *const_str_plain_getOperationBinaryBitAndLShape;
extern PyObject *const_str_plain_Sub;
static PyObject *const_str_digest_7a1d07fe183b0c7a628ebe63a5385a45;
static PyObject *const_str_digest_4283052390ee7abb237257312d760dba;
static PyObject *const_str_digest_1821e1c4b4c84919918ee3082ed9b2aa;
extern PyObject *const_str_plain_getOperationBinaryMatMultShape;
static PyObject *const_str_digest_f8b45238e2c8bc14c71e96c1b7a374de;
static PyObject *const_tuple_str_plain_type_shapes_tuple;
static PyObject *const_str_digest_f3c4681ec6b288d03e6a965eb469af08;
static PyObject *const_str_digest_7ef113462f316f87e890cdcd1d4b107c;
static PyObject *const_str_digest_1f08c45497409e65e5b6cfc132cdfd37;
static PyObject *const_str_digest_92fc3e2a785ed05a6acf59211c03e00b;
static PyObject *const_str_digest_d4eb92a9170cb090d83ff226aec0b12a;
static PyObject *const_str_digest_6ed0e0b4680a298aee0daa9ebe484594;
static PyObject *const_str_digest_669e15ef7677859ad07cd30927cc4d72;
extern PyObject *const_tuple_str_plain_cls_str_plain_right_shape_tuple;
extern PyObject *const_str_plain_hasShapeSlotInt;
static PyObject *const_str_digest_024d617040713eb605fdc16d5e8c5e35;
static PyObject *const_tuple_6581d4b45daab8949369aff04ae4c3cf_tuple;
static PyObject *const_str_digest_d83cc59cf648a94cfc73f654ffd0dc34;
static PyObject *const_str_digest_b6e852c15fbf4de53bee47e76b75421f;
static PyObject *const_str_digest_322c0da1f98adfc4e00077e5581652e3;
extern PyObject *const_str_plain___qualname__;
static PyObject *const_str_digest_365da10cd9378856c420835e2cc7f545;
static PyObject *const_str_digest_71ed497c2844da7c828242ad2d4aa6af;
extern PyObject *const_str_plain_hasShapeSlotBool;
static PyObject *const_str_digest_12887f500372f8562e066c16ba68b9a6;
static PyObject *const_str_digest_5eca226fe02ac5de7f4929cfe61fd4e8;
extern PyObject *const_str_plain_getOperationBinaryPowShape;
static PyObject *const_str_digest_e3e58d5b79048c12a1260373b81ee46c;
static PyObject *const_str_digest_99df920857485ae5c8e557b8e1140b04;
static PyObject *const_str_digest_0008cb4c56ad268bf83a0c41c2a4f36b;
extern PyObject *const_str_plain_getOperationBinaryBitOrShape;
static PyObject *const_str_digest_96451d49b3183e84063fa4b336b9c2d0;
static PyObject *const_str_plain_getOperationBinaryLShiftLShape;
static PyObject *const_str_digest_d165cf867ceeb8fac2673d04c18391b5;
static PyObject *const_str_digest_13fc0a95d0665b0c4d5bc5f80c1f4584;
static PyObject *const_str_digest_86fa1c52e4adde46f77b4c8eff21e870;
static PyObject *const_str_plain_getOperationBinaryBitXorLShape;
static PyObject *const_str_digest_762147b023ade88d738804d3e8476ff8;
static PyObject *const_str_digest_575e9c00e04e5e00338462e0e3cdfa90;
static PyObject *const_str_digest_847fbb2c38b79bc7df8d53d0d76e35fe;
static PyObject *const_str_digest_ab35dd025889bc45db317c286206826f;
extern PyObject *const_str_plain___getitem__;
static PyObject *const_tuple_str_plain_ValueShapeBase_tuple_type_object_tuple_tuple;
static PyObject *const_str_digest_6f65270eb24f34e894a86c108883d024;
static PyObject *const_str_plain_ValueShapeBase;
extern PyObject *const_str_plain_operation_result_unknown;
extern PyObject *const_str_plain_getOperationBinarySubShape;
static PyObject *const_str_digest_6be52d31f524db4ba645af96905d73e9;
extern PyObject *const_str_plain_operation;
extern PyObject *const_str_plain_hasShapeSlotLong;
static PyObject *const_str_digest_ea4093cba5ec1e09e23d65d8548dcd5b;
static PyObject *const_str_digest_9cae8449d07612259d5c056ed2934071;
extern PyObject *const_str_plain_origin;
extern PyObject *const_str_plain_getOperationBinaryBitAndShape;
static PyObject *const_str_digest_bab51e387d3153f087b88e7f459e5262;
extern PyObject *const_str_digest_75fd71b1edada749c2ef7ac810062295;
extern PyObject *const_str_plain_getComparisonLtLShape;
static PyObject *const_str_digest_a5bfe47ce4ba19f54f28f4b3cc10be37;
extern PyObject *const_str_plain_getOperationBinaryModShape;
static PyObject *const_str_plain_getOperationBinaryAddLShape;
static PyObject *const_str_plain_getOperationBinaryTrueDivLShape;
extern PyObject *const_str_plain_onMissingOperation;
extern PyObject *const_str_plain_ShapeIterator;
extern PyObject *const_str_plain_isConstant;
static PyObject *const_str_digest_9dbdf6b6ac13c99241af100a163ecf6e;
static PyObject *const_str_plain_getComparisonNeqShape;
static PyObject *const_str_digest_def9b5bb7f50b71de97a052b638056e8;
static PyObject *const_str_digest_33f8b5b02c5515b662664b0259421a7e;
static PyObject *const_str_digest_a5d1c8577236b0122906b5451836ac13;
extern PyObject *const_str_plain_hasShapeSlotIter;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_digest_dcc6e2d69aa8d5793f2331176634f4e0;
static PyObject *const_tuple_str_plain_ShapeBase_tuple_type_object_tuple_tuple;
extern PyObject *const_str_plain_ControlFlowDescriptionFullEscape;
static PyObject *const_str_digest_5f9120f7f6d51d9ce5732e159b382137;
static PyObject *const_str_digest_00a09cfe5e24c0a47b44de43f2bc0f40;
extern PyObject *const_str_plain_right_shape;
extern PyObject *const_str_plain_has_location;
static PyObject *const_tuple_str_plain_self_str_plain_right_shape_tuple;
static PyObject *const_str_plain__delegatedCheck;
static PyObject *const_str_digest_b8f9f1c9c4c0048542d1f2a992963cd9;
static PyObject *const_str_digest_63d0871f0e62133be883b984a3258a9e;
static PyObject *const_str_digest_069829ea685b9f6e8c3137a8deda8d06;
static PyObject *const_str_digest_029bc98430e80320845b687048090956;
extern PyObject *const_str_digest_6e7dbe51ff007289b31e0fc6eaf5e18e;
static PyObject *const_str_digest_69612c7138597cea4ca455a4be16865d;
static PyObject *const_str_digest_dc9c40641d6a52244eab03534e9b8d47;
static PyObject *const_str_digest_34c5d84ff7282938eda842134a3330c8;
static PyObject *const_str_digest_eac2c10d37faadc12734713c9705faa0;
static PyObject *const_str_plain_getOperationBinaryModLShape;
extern PyObject *const_str_plain_ShapeLargeConstantValue;
extern PyObject *const_str_plain_result;
static PyObject *const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_shapes_tuple;
static PyObject *const_str_plain_getOperationBinaryBitMatMultLShape;
static PyObject *const_str_digest_c15c72a7e37e89f81802924290efa8b4;
static PyObject *const_str_digest_b20249b89da7c7d41d472a96cb3f04f7;
extern PyObject *const_str_plain_getOperationBinaryLShiftShape;
extern PyObject *const_str_plain_single;
static PyObject *const_str_digest_fe95f50f92c2a05973e7b6fedacebe1d;
static PyObject *const_str_digest_67fabd6d0d4cff0f1dd156de9e6b195c;
extern PyObject *const_str_plain_ShapeLoopCompleteAlternative;
extern PyObject *const_str_plain_classmethod;
static PyObject *const_str_digest_96b820c249396a1aca0592af708777cf;
static PyObject *const_str_digest_09fa250c7788dd76d322da225470e409;
extern PyObject *const_str_plain_floordiv_shapes;
static PyObject *const_str_plain_getOperationBinaryFloorDivLShape;
extern PyObject *const_str_plain_type_shapes;
extern PyObject *const_str_plain_getComparisonLtShape;
extern PyObject *const_str_plain_getOperationBinaryTrueDivShape;
static PyObject *const_str_digest_cae779c1a1dc30fc8c1cddf76f7f3c16;
static PyObject *const_str_digest_46234c0d9fa622e2c891a3eeef342f81;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_digest_b867b57ef1511273804bd83b2ec25374;
static PyObject *const_str_digest_5d4052745f0da93e79fd9db1fa2358ae;
extern PyObject *const_str_plain_add;
static PyObject *const_str_digest_328609247c98d96b06f85f1dc9e9a651;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_digest_aa5851757158e07e6201e4ca073299b2;
static PyObject *const_str_digest_dc11cc451e3f25cc39ee212d19c2267b;
static PyObject *const_str_digest_8f64e387ba2d40fbaf2e0c9911337215;
static PyObject *const_str_plain_getOperationBinaryRShiftLShape;
extern PyObject *const_str_plain_bitor_shapes;
static PyObject *const_str_digest_5445345d5ab4fea2ae8f2eb419a7a1cd;
extern PyObject *const_tuple_empty;
static PyObject *const_str_digest_d454e1ca882012a2883b67d83d0c86c5;
extern PyObject *const_str_plain_Add;
static PyObject *const_str_plain_getOperationBinaryBitOrLShape;
static PyObject *const_str_digest_84b5e8d5c8b459d742fc3e3a1516a732;
static PyObject *const_str_plain_getOperationBinaryMultLShape;
static PyObject *const_str_plain_getOperationBinarySubLShape;
static PyObject *const_str_digest_0a1285450b6c1002a0164d8da0ba1cdc;
static PyObject *const_str_digest_e30a07ccc1c2a998704b9606b2835b95;
static PyObject *const_str_digest_9947a771fdf7affcb1a68d2b4d5a662a;
static PyObject *const_str_digest_b527f90acd21e596976714914f889237;
static PyObject *const_str_digest_53587ace7c4bf33107ed1f570aadf105;
static PyObject *const_str_digest_1d7b5f7dfcc811f8fc7513c38a2587d8;
static PyObject *const_str_digest_9b26d03e2a1655101f000317cbb0b0ec;
static PyObject *const_str_digest_255d85ab519561f7569c6132871b3a12;
static PyObject *const_str_digest_fb06347c64ee3b801ccfd4a33d6bc377;
static PyObject *const_str_digest_c39bde8b6b341623969694b505be7a70;
static PyObject *const_str_digest_2af96047d68e2c8830c315efb5eb5e6e;
extern PyObject *const_str_plain_hasShapeSlotContains;
extern PyObject *const_str_plain_getOperationBinaryBitXorShape;
static PyObject *const_str_digest_8e7cf89322c3481963627b7f5dd2d7ce;
static PyObject *const_str_digest_e05dfff18ab5f0084ec7af38e27e39ec;
static PyObject *const_str_digest_b02c75ea17c35630c1c53481a1915463;
static PyObject *const_str_digest_b16b9c9441e9c5fc2752839cfa5f5465;
extern PyObject *const_str_plain___slots__;
extern PyObject *const_str_plain_x;
extern PyObject *const_str_plain_left_shape;
static PyObject *const_str_digest_034b2a937fdda560dc9a98763f96162c;
static PyObject *const_str_digest_cb155a5768e5f44496815fb1875631eb;
extern PyObject *const_str_plain_mul_shapes;
static PyObject *const_str_digest_0b24bf1a87dc3a7f1bf92158dade790a;
extern PyObject *const_str_plain___class__;
extern PyObject *const_str_plain_ShapeLargeConstantValuePredictable;
extern PyObject *const_str_plain___module__;
static PyObject *const_str_digest_1b169eed60667f879366fb78beb151ef;
static PyObject *const_str_digest_90f0220328a09edaf62c4482306ba916;
static PyObject *const_str_digest_ce07a58f856c25460ff35b8a5e594d26;
static PyObject *const_str_digest_b6d47b59a5c3db11af01e7a0db94bbe0;
static PyObject *const_str_plain_ValueShapeUnknown;
static PyObject *const_str_digest_0d2c9cef16d5cc0608d81849836c876e;
extern PyObject *const_str_plain_helper_code;
static PyObject *const_str_digest_f96a037699f72408c3e0a6b5d83057b3;
extern PyObject *const_str_plain_getComparisonGteShape;
static PyObject *const_tuple_str_plain_ControlFlowDescriptionFullEscape_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_left_shape_tuple;
extern PyObject *const_str_plain_get;
static PyObject *const_str_digest_e28b3e65378741fcd9441531f65e447f;
static PyObject *const_str_digest_22da858206cc847e210a9fa730c577aa;
static PyObject *const_str_digest_1ddcb2b45d6000f54afbf9eb0e90743b;
static PyObject *const_str_digest_682498401e8c313f897fef027fe921cc;
static PyObject *const_str_digest_9599c172028796027d409abf82468412;
static PyObject *const_str_digest_e0bf05a64dce3920b00a790d74a3c152;
static PyObject *const_str_digest_05a78548926bee9c0aa1504a38bc3272;
static PyObject *const_tuple_str_plain_self_str_plain_emit_str_plain_type_shape_tuple;
extern PyObject *const_str_plain_metaclass;
static PyObject *const_str_plain_getOperationBinaryOldDivLShape;
static PyObject *const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple;
extern PyObject *const_tuple_str_plain___class___tuple;
extern PyObject *const_str_angle_metaclass;
static PyObject *const_str_digest_45e740ebd0e72590beff0fbc1084a81e;
extern PyObject *const_str_plain_ShapeUnknown;
static PyObject *const_str_digest_627c1a9a275d106b97f1899bf1ed6756;
static PyObject *const_str_digest_7bb85642334b99ad0049c2629ee11a6d;
static PyObject *const_str_digest_652e076dbd067789ae3169ead7b44231;
extern PyObject *const_str_plain_olddiv_shapes;
static PyObject *const_tuple_7f894d1a5e692237733383026dfad7fd_tuple;
static PyObject *const_str_digest_b262ff30fa9e5c5b9c7b2430aa61ef08;
extern PyObject *const_str_plain_size;
extern PyObject *const_str_plain_staticmethod;
static PyObject *const_str_digest_8c5302682484c126170068b2bd2d33ce;
static PyObject *const_str_digest_78e7f75305f7d62feb3a9dc186636f18;
extern PyObject *const_str_plain_cls;
static PyObject *const_str_digest_cab3b6618917c459acfca3e5ab31358f;
extern PyObject *const_str_plain_getTypeShape;
static PyObject *const_str_digest_f8abc771bcfacef2d1c50cb3c2e4e301;
extern PyObject *const_str_plain_description;
extern PyObject *const_str_plain_getTypeName;
static PyObject *const_str_digest_03fb79af517e133535ec295810dfac46;
static PyObject *const_tuple_str_plain_shape_str_plain_size_tuple;
static PyObject *const_str_digest_4bb83b53e6a8045fe086d9e5bdc97f54;
extern PyObject *const_str_plain_hasShapeSlotFloat;
static PyObject *const_str_digest_87d515201677c9301fd970b13f35344c;
static PyObject *const_tuple_str_plain_ShapeLargeConstantValue_tuple_type_object_tuple_tuple;
static PyObject *const_str_digest_acc972e8d43650389227b81299d1ae15;
extern PyObject *const_str_plain_getShapeIter;
static PyObject *const_str_digest_8d861b97287f8c44d00db282d2298711;
extern PyObject *const_str_plain_bitand_shapes;
static PyObject *const_str_digest_3c0042cdc3c9a57e46849cdc92b3eb3b;
static PyObject *const_str_digest_f9df910acf0215eaf464f92425dcd002;
static PyObject *const_str_digest_47c5cdb23723111667af8a2a10d27324;
extern PyObject *const_str_plain_r;
static PyObject *const_str_digest_6078755004362c4ae543ea6452fd4308;
extern PyObject *const_tuple_str_plain_x_tuple;
static PyObject *const_str_plain__description;
static PyObject *const_tuple_str_plain_cls_str_plain_emit_tuple;
static PyObject *const_str_digest_9bece148b4f208983edca24b57ffdcae;
extern PyObject *const_str_plain_vshape_unknown;
static PyObject *const_str_digest_1f0cdda054450e3fa5634a8722b3e7b8;
static PyObject *const_str_digest_c8a3b90d77b847ed37d4a0b8bd57ab05;
static PyObject *const_str_plain_getOperationBinaryPowLShape;
static PyObject *const_str_digest_380789f8960e6daa2e93c66890a30dca;
static PyObject *const_str_digest_d90d5c78caabd24db486a4ccbf59cd14;
extern PyObject *const_str_plain_ShapeBase;
static PyObject *const_str_digest_b2df44234e2ee51d521095a7fa337920;
static PyObject *const_tuple_str_plain_CTypePyObjectPtr_tuple;
static PyObject *const_str_digest_d34491a40e0b3b367fb66022378077d3;
extern PyObject *const_str_plain_getComparisonGtShape;
static PyObject *const_str_digest_5b903e5051ed33327d0845acb1aa06d6;
static PyObject *const_str_digest_2cd707492de6eec06aba9aa75d93cda7;
extern PyObject *const_str_plain_getOperationBinaryFloorDivShape;
extern PyObject *const_str_plain_getCType;
static PyObject *const_str_digest_2417025a2204fdfd1df0e2bcb92592e8;
extern PyObject *const_str_angle_lambda;
static PyObject *const_str_digest_8e711790dd74232149aab0a58c8a3a7f;
static PyObject *const_str_digest_acb5c981f9ec880bb67e20323a9b090c;
static PyObject *const_str_digest_9ac60839a4ad81e96900228ba26d8a4b;
extern PyObject *const_str_plain_shapes;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_str_digest_597956a8912e09241dc76842ab712a3c;
static PyObject *const_str_digest_b238134514f501a27042729c5b3f3441;
extern PyObject *const_str_plain_getOperationBinaryOldDivShape;
static PyObject *const_str_digest_d00dd524112ac2daf0807f02a08713f5;
static PyObject *const_str_digest_d6bf92263192a5627e57fff8feddd8f5;
extern PyObject *const_str_plain_self;
static PyObject *const_str_digest_8f14b440fd6ca8bff343a227d301809d;
extern PyObject *const_str_plain_Lt;
static PyObject *const_str_digest_aa65ab12dd477f85bad48af2f0edbfe9;
static PyObject *const_str_plain__collectShapeOperation;
static PyObject *const_str_digest_8e5ece21e576f546463bfe5c2f0ba8e5;
static PyObject *const_str_digest_fea64aa82d89c33944e5ab8ceb84ea5f;
extern PyObject *const_str_plain_getOperationBinaryAddShape;
static PyObject *const_str_digest_c9c35ef4cfa2cd9b28f23fe80d1b5aa7;
static PyObject *const_str_digest_cb30ed96be09f5491dc64c5417a592d5;
static PyObject *const_str_digest_4ab5d94003c31387d8faf22e555d63b0;
static PyObject *const_str_digest_aaa846ca7fe03417eeca473ef7d50543;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants(void) {
    const_str_digest_7180205ef64e9c18df2d09fcaaa43691 = UNSTREAM_STRING_ASCII(&constant_bin[ 677232 ], 36, 0);
    const_str_digest_7e7788ccf7097b006f15d4ab18035078 = UNSTREAM_STRING_ASCII(&constant_bin[ 677268 ], 55, 0);
    const_str_digest_0594efac62700843ff32809de058caae = UNSTREAM_STRING_ASCII(&constant_bin[ 677323 ], 59, 0);
    const_str_digest_4f26a96a64793f4392df8222281f5de5 = UNSTREAM_STRING_ASCII(&constant_bin[ 677382 ], 18, 0);
    const_str_digest_3f0b0dc1a1fa3987ac4353534e0f5905 = UNSTREAM_STRING_ASCII(&constant_bin[ 677400 ], 33, 0);
    const_str_digest_d5cbbc53e11173a4dca6aeb4d5ec4db4 = UNSTREAM_STRING_ASCII(&constant_bin[ 677433 ], 51, 0);
    const_str_plain_getOperationBinaryMatMultLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 677484 ], 31, 1);
    const_str_digest_dcf51f3801ec287eefe3cc0ece44bb21 = UNSTREAM_STRING_ASCII(&constant_bin[ 677515 ], 73, 0);
    const_str_digest_0391c0c81b22fe4c6e9cfbfa036d7f29 = UNSTREAM_STRING_ASCII(&constant_bin[ 677588 ], 38, 0);
    const_str_digest_df9171a19dc9056c92c0285a45a6639f = UNSTREAM_STRING_ASCII(&constant_bin[ 677626 ], 27, 0);
    const_tuple_str_plain_self_str_plain_size_str_plain_shape_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_size_str_plain_shape_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_size_str_plain_shape_tuple, 1, const_str_plain_size); Py_INCREF(const_str_plain_size);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_size_str_plain_shape_tuple, 2, const_str_plain_shape); Py_INCREF(const_str_plain_shape);
    const_str_digest_625fe1e69ace93fc64749f3af6009f31 = UNSTREAM_STRING_ASCII(&constant_bin[ 677653 ], 58, 0);
    const_str_plain_escape_description = UNSTREAM_STRING_ASCII(&constant_bin[ 677711 ], 18, 1);
    const_str_digest_210cf36a20d8be933983da1bd9dc5f0f = UNSTREAM_STRING_ASCII(&constant_bin[ 677729 ], 25, 0);
    const_str_digest_e93196de0aa84d7986fb4af03f1bcb72 = UNSTREAM_STRING_ASCII(&constant_bin[ 677754 ], 56, 0);
    const_str_plain__collectInitialShape = UNSTREAM_STRING_ASCII(&constant_bin[ 677810 ], 20, 1);
    const_str_digest_abb5cd115195ebd171fd19240d19c05c = UNSTREAM_STRING_ASCII(&constant_bin[ 677830 ], 50, 0);
    const_str_digest_b6d23c14d0d4bc9dad07080a16f71e1e = UNSTREAM_STRING_ASCII(&constant_bin[ 677880 ], 43, 0);
    const_str_digest_d8b645143e9f1a455e3cb5b0c969754d = UNSTREAM_STRING_ASCII(&constant_bin[ 677923 ], 39, 0);
    const_str_digest_1a03e9ce2e16071a8c173e0843bab7a2 = UNSTREAM_STRING_ASCII(&constant_bin[ 677962 ], 63, 0);
    const_str_digest_9478741cfa8b1b672c5ae1b2d6fcd0f3 = UNSTREAM_STRING_ASCII(&constant_bin[ 678025 ], 39, 0);
    const_str_digest_213535de2986e9fe33ceaa61e0fcca40 = UNSTREAM_STRING_ASCII(&constant_bin[ 678064 ], 59, 0);
    const_str_digest_0251aa253c1cab7b3975aa8a056bcd59 = UNSTREAM_STRING_ASCII(&constant_bin[ 678123 ], 26, 0);
    const_str_plain_right_shape_type = UNSTREAM_STRING_ASCII(&constant_bin[ 678149 ], 16, 1);
    const_str_digest_f38880eba632621d930a62348aff8df0 = UNSTREAM_STRING_ASCII(&constant_bin[ 678165 ], 76, 0);
    const_str_digest_4f357c02d4f02597489b79e57bf68d5e = UNSTREAM_STRING_ASCII(&constant_bin[ 678241 ], 73, 0);
    const_str_digest_c7e895ad3a752f5af11608a55fc3e719 = UNSTREAM_STRING_ASCII(&constant_bin[ 678314 ], 49, 0);
    const_str_digest_c54c54e35beee66a709658cabf4884cf = UNSTREAM_STRING_ASCII(&constant_bin[ 678363 ], 57, 0);
    const_str_digest_456552722d27a21eddbe73939e12677a = UNSTREAM_STRING_ASCII(&constant_bin[ 678420 ], 61, 0);
    const_str_digest_7a4c138f498be59b81e44a071ffe23e3 = UNSTREAM_STRING_ASCII(&constant_bin[ 678165 ], 58, 0);
    const_str_digest_950482538a86eb0630a1ab5b98519299 = UNSTREAM_STRING_ASCII(&constant_bin[ 678481 ], 30, 0);
    const_str_plain_matmult_shapes = UNSTREAM_STRING_ASCII(&constant_bin[ 678511 ], 14, 1);
    const_str_digest_ca1207a01fdb60ef20cd2cafffcf4764 = UNSTREAM_STRING_ASCII(&constant_bin[ 678525 ], 49, 0);
    const_str_digest_76def7778bdd1aae29d1264a72a4ff16 = UNSTREAM_STRING_ASCII(&constant_bin[ 678574 ], 60, 0);
    const_str_digest_a7c0071cf4b3200d86be5a79f1c38d4c = UNSTREAM_STRING_ASCII(&constant_bin[ 678634 ], 36, 0);
    const_str_digest_c04892013b17346e0feb2d7582ab7ae0 = UNSTREAM_STRING_ASCII(&constant_bin[ 678670 ], 30, 0);
    const_tuple_19e9cf822ef663d07339aa620df912db_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 1, const_str_plain_right_shape); Py_INCREF(const_str_plain_right_shape);
    PyTuple_SET_ITEM(const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 3, const_str_plain_right_shape_type); Py_INCREF(const_str_plain_right_shape_type);
    const_str_digest_d53a423951b232e18d93c9f1828c1a3f = UNSTREAM_STRING_ASCII(&constant_bin[ 678700 ], 54, 0);
    const_str_digest_b74e3483c0b7dc405673b6681b893ef1 = UNSTREAM_STRING_ASCII(&constant_bin[ 678754 ], 45, 0);
    const_str_digest_6ab4c8ed7aba351c9a8e1e4e1a56ce1a = UNSTREAM_STRING_ASCII(&constant_bin[ 678799 ], 45, 0);
    const_str_digest_5fe1a7c4046b9f2044748f911c36403f = UNSTREAM_STRING_ASCII(&constant_bin[ 678844 ], 76, 0);
    const_str_digest_60d9f6c8d66361ecc95ade1ea639f1a2 = UNSTREAM_STRING_ASCII(&constant_bin[ 678920 ], 74, 0);
    const_str_digest_194ab90c00e030718b1d173955c51229 = UNSTREAM_STRING_ASCII(&constant_bin[ 678994 ], 58, 0);
    const_str_digest_e8c3d9420556b2f8c1303cddaa3f8e40 = UNSTREAM_STRING_ASCII(&constant_bin[ 679052 ], 63, 0);
    const_str_digest_d2189c374f6bb9323c899684884dea1a = UNSTREAM_STRING_ASCII(&constant_bin[ 679115 ], 39, 0);
    const_str_digest_50adb2c3ec0e699614cd7fbbefc0169b = UNSTREAM_STRING_ASCII(&constant_bin[ 679154 ], 76, 0);
    const_str_digest_91cd369ed1b9a8fd6ffd7715f35cc157 = UNSTREAM_STRING_ASCII(&constant_bin[ 679230 ], 48, 0);
    const_str_digest_a354cca5276535abe1bef4525c86cc54 = UNSTREAM_STRING_ASCII(&constant_bin[ 679278 ], 59, 0);
    const_tuple_str_plain_predictor_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_predictor_tuple, 0, const_str_plain_predictor); Py_INCREF(const_str_plain_predictor);
    const_str_digest_9028633f7a2e20ffed935d77dc3cfa39 = UNSTREAM_STRING_ASCII(&constant_bin[ 679337 ], 62, 0);
    const_str_digest_92d7bb3869456a3d13d0abb2a892ed4b = UNSTREAM_STRING_ASCII(&constant_bin[ 679399 ], 40, 0);
    const_str_digest_b58f205b283109589d6616923c5e38ce = UNSTREAM_STRING_ASCII(&constant_bin[ 679439 ], 67, 0);
    const_str_digest_9294d61dfee050890f7ed89747a17073 = UNSTREAM_STRING_ASCII(&constant_bin[ 679506 ], 75, 0);
    const_str_digest_d2f1e24741c28a03ec32e5b3e138ec1d = UNSTREAM_STRING_ASCII(&constant_bin[ 679581 ], 36, 0);
    const_str_plain_getOperationBinaryBitAndLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 679617 ], 30, 1);
    const_str_digest_7a1d07fe183b0c7a628ebe63a5385a45 = UNSTREAM_STRING_ASCII(&constant_bin[ 679647 ], 72, 0);
    const_str_digest_4283052390ee7abb237257312d760dba = UNSTREAM_STRING_ASCII(&constant_bin[ 679719 ], 31, 0);
    const_str_digest_1821e1c4b4c84919918ee3082ed9b2aa = UNSTREAM_STRING_ASCII(&constant_bin[ 679750 ], 45, 0);
    const_str_digest_f8b45238e2c8bc14c71e96c1b7a374de = UNSTREAM_STRING_ASCII(&constant_bin[ 679795 ], 75, 0);
    const_tuple_str_plain_type_shapes_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_type_shapes_tuple, 0, const_str_plain_type_shapes); Py_INCREF(const_str_plain_type_shapes);
    const_str_digest_f3c4681ec6b288d03e6a965eb469af08 = UNSTREAM_STRING_ASCII(&constant_bin[ 679870 ], 21, 0);
    const_str_digest_7ef113462f316f87e890cdcd1d4b107c = UNSTREAM_STRING_ASCII(&constant_bin[ 679891 ], 36, 0);
    const_str_digest_1f08c45497409e65e5b6cfc132cdfd37 = UNSTREAM_STRING_ASCII(&constant_bin[ 679927 ], 44, 0);
    const_str_digest_92fc3e2a785ed05a6acf59211c03e00b = UNSTREAM_STRING_ASCII(&constant_bin[ 679971 ], 29, 0);
    const_str_digest_d4eb92a9170cb090d83ff226aec0b12a = UNSTREAM_STRING_ASCII(&constant_bin[ 680000 ], 62, 0);
    const_str_digest_6ed0e0b4680a298aee0daa9ebe484594 = UNSTREAM_STRING_ASCII(&constant_bin[ 680062 ], 73, 0);
    const_str_digest_669e15ef7677859ad07cd30927cc4d72 = UNSTREAM_STRING_ASCII(&constant_bin[ 680135 ], 66, 0);
    const_str_digest_024d617040713eb605fdc16d5e8c5e35 = UNSTREAM_STRING_ASCII(&constant_bin[ 677515 ], 55, 0);
    const_tuple_6581d4b45daab8949369aff04ae4c3cf_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_6581d4b45daab8949369aff04ae4c3cf_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_6581d4b45daab8949369aff04ae4c3cf_tuple, 1, const_str_plain_size); Py_INCREF(const_str_plain_size);
    PyTuple_SET_ITEM(const_tuple_6581d4b45daab8949369aff04ae4c3cf_tuple, 2, const_str_plain_predictor); Py_INCREF(const_str_plain_predictor);
    PyTuple_SET_ITEM(const_tuple_6581d4b45daab8949369aff04ae4c3cf_tuple, 3, const_str_plain_shape); Py_INCREF(const_str_plain_shape);
    const_str_digest_d83cc59cf648a94cfc73f654ffd0dc34 = UNSTREAM_STRING_ASCII(&constant_bin[ 680201 ], 50, 0);
    const_str_digest_b6e852c15fbf4de53bee47e76b75421f = UNSTREAM_STRING_ASCII(&constant_bin[ 680251 ], 39, 0);
    const_str_digest_322c0da1f98adfc4e00077e5581652e3 = UNSTREAM_STRING_ASCII(&constant_bin[ 680290 ], 50, 0);
    const_str_digest_365da10cd9378856c420835e2cc7f545 = UNSTREAM_STRING_ASCII(&constant_bin[ 680340 ], 73, 0);
    const_str_digest_71ed497c2844da7c828242ad2d4aa6af = UNSTREAM_STRING_ASCII(&constant_bin[ 679506 ], 57, 0);
    const_str_digest_12887f500372f8562e066c16ba68b9a6 = UNSTREAM_STRING_ASCII(&constant_bin[ 680413 ], 39, 0);
    const_str_digest_5eca226fe02ac5de7f4929cfe61fd4e8 = UNSTREAM_STRING_ASCII(&constant_bin[ 680452 ], 49, 0);
    const_str_digest_e3e58d5b79048c12a1260373b81ee46c = UNSTREAM_STRING_ASCII(&constant_bin[ 678920 ], 56, 0);
    const_str_digest_99df920857485ae5c8e557b8e1140b04 = UNSTREAM_STRING_ASCII(&constant_bin[ 680501 ], 36, 0);
    const_str_digest_0008cb4c56ad268bf83a0c41c2a4f36b = UNSTREAM_STRING_ASCII(&constant_bin[ 680537 ], 60, 0);
    const_str_digest_96451d49b3183e84063fa4b336b9c2d0 = UNSTREAM_STRING_ASCII(&constant_bin[ 680597 ], 50, 0);
    const_str_plain_getOperationBinaryLShiftLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 679307 ], 30, 1);
    const_str_digest_d165cf867ceeb8fac2673d04c18391b5 = UNSTREAM_STRING_ASCII(&constant_bin[ 679439 ], 49, 0);
    const_str_digest_13fc0a95d0665b0c4d5bc5f80c1f4584 = UNSTREAM_STRING_ASCII(&constant_bin[ 680647 ], 57, 0);
    const_str_digest_86fa1c52e4adde46f77b4c8eff21e870 = UNSTREAM_STRING_ASCII(&constant_bin[ 677962 ], 45, 0);
    const_str_plain_getOperationBinaryBitXorLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 678093 ], 30, 1);
    const_str_digest_762147b023ade88d738804d3e8476ff8 = UNSTREAM_STRING_ASCII(&constant_bin[ 680704 ], 43, 0);
    const_str_digest_575e9c00e04e5e00338462e0e3cdfa90 = UNSTREAM_STRING_ASCII(&constant_bin[ 680747 ], 30, 0);
    const_str_digest_847fbb2c38b79bc7df8d53d0d76e35fe = UNSTREAM_STRING_ASCII(&constant_bin[ 680777 ], 49, 0);
    const_str_digest_ab35dd025889bc45db317c286206826f = UNSTREAM_STRING_ASCII(&constant_bin[ 680826 ], 30, 0);
    const_tuple_str_plain_ValueShapeBase_tuple_type_object_tuple_tuple = PyTuple_New(2);
    const_str_plain_ValueShapeBase = UNSTREAM_STRING_ASCII(&constant_bin[ 86214 ], 14, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_ValueShapeBase_tuple_type_object_tuple_tuple, 0, const_str_plain_ValueShapeBase); Py_INCREF(const_str_plain_ValueShapeBase);
    PyTuple_SET_ITEM(const_tuple_str_plain_ValueShapeBase_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple); Py_INCREF(const_tuple_type_object_tuple);
    const_str_digest_6f65270eb24f34e894a86c108883d024 = UNSTREAM_STRING_ASCII(&constant_bin[ 680856 ], 73, 0);
    const_str_digest_6be52d31f524db4ba645af96905d73e9 = UNSTREAM_STRING_ASCII(&constant_bin[ 680856 ], 55, 0);
    const_str_digest_ea4093cba5ec1e09e23d65d8548dcd5b = UNSTREAM_STRING_ASCII(&constant_bin[ 680929 ], 76, 0);
    const_str_digest_9cae8449d07612259d5c056ed2934071 = UNSTREAM_STRING_ASCII(&constant_bin[ 681005 ], 60, 0);
    const_str_digest_bab51e387d3153f087b88e7f459e5262 = UNSTREAM_STRING_ASCII(&constant_bin[ 681065 ], 39, 0);
    const_str_digest_a5bfe47ce4ba19f54f28f4b3cc10be37 = UNSTREAM_STRING_ASCII(&constant_bin[ 681104 ], 373, 0);
    const_str_plain_getOperationBinaryAddLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 681477 ], 27, 1);
    const_str_plain_getOperationBinaryTrueDivLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 678603 ], 31, 1);
    const_str_digest_9dbdf6b6ac13c99241af100a163ecf6e = UNSTREAM_STRING_ASCII(&constant_bin[ 681504 ], 44, 0);
    const_str_plain_getComparisonNeqShape = UNSTREAM_STRING_ASCII(&constant_bin[ 677859 ], 21, 1);
    const_str_digest_def9b5bb7f50b71de97a052b638056e8 = UNSTREAM_STRING_ASCII(&constant_bin[ 681548 ], 26, 0);
    const_str_digest_33f8b5b02c5515b662664b0259421a7e = UNSTREAM_STRING_ASCII(&constant_bin[ 681574 ], 57, 0);
    const_str_digest_a5d1c8577236b0122906b5451836ac13 = UNSTREAM_STRING_ASCII(&constant_bin[ 681631 ], 72, 0);
    const_str_digest_dcc6e2d69aa8d5793f2331176634f4e0 = UNSTREAM_STRING_ASCII(&constant_bin[ 681703 ], 37, 0);
    const_tuple_str_plain_ShapeBase_tuple_type_object_tuple_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_ShapeBase_tuple_type_object_tuple_tuple, 0, const_str_plain_ShapeBase); Py_INCREF(const_str_plain_ShapeBase);
    PyTuple_SET_ITEM(const_tuple_str_plain_ShapeBase_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple); Py_INCREF(const_tuple_type_object_tuple);
    const_str_digest_5f9120f7f6d51d9ce5732e159b382137 = UNSTREAM_STRING_ASCII(&constant_bin[ 680062 ], 55, 0);
    const_str_digest_00a09cfe5e24c0a47b44de43f2bc0f40 = UNSTREAM_STRING_ASCII(&constant_bin[ 681740 ], 26, 0);
    const_tuple_str_plain_self_str_plain_right_shape_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_right_shape_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_right_shape_tuple, 1, const_str_plain_right_shape); Py_INCREF(const_str_plain_right_shape);
    const_str_plain__delegatedCheck = UNSTREAM_STRING_ASCII(&constant_bin[ 681533 ], 15, 1);
    const_str_digest_b8f9f1c9c4c0048542d1f2a992963cd9 = UNSTREAM_STRING_ASCII(&constant_bin[ 681766 ], 31, 0);
    const_str_digest_63d0871f0e62133be883b984a3258a9e = UNSTREAM_STRING_ASCII(&constant_bin[ 681797 ], 54, 0);
    const_str_digest_069829ea685b9f6e8c3137a8deda8d06 = UNSTREAM_STRING_ASCII(&constant_bin[ 681851 ], 40, 0);
    const_str_digest_029bc98430e80320845b687048090956 = UNSTREAM_STRING_ASCII(&constant_bin[ 681891 ], 26, 0);
    const_str_digest_69612c7138597cea4ca455a4be16865d = UNSTREAM_STRING_ASCII(&constant_bin[ 679337 ], 44, 0);
    const_str_digest_dc9c40641d6a52244eab03534e9b8d47 = UNSTREAM_STRING_ASCII(&constant_bin[ 681917 ], 385, 0);
    const_str_digest_34c5d84ff7282938eda842134a3330c8 = UNSTREAM_STRING_ASCII(&constant_bin[ 682302 ], 26, 0);
    const_str_digest_eac2c10d37faadc12734713c9705faa0 = UNSTREAM_STRING_ASCII(&constant_bin[ 682328 ], 27, 0);
    const_str_plain_getOperationBinaryModLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 682355 ], 27, 1);
    const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 1, const_str_plain_operation); Py_INCREF(const_str_plain_operation);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 3, const_str_plain_escape_description); Py_INCREF(const_str_plain_escape_description);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 4, const_str_plain_single); Py_INCREF(const_str_plain_single);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 5, const_str_plain_type_shape); Py_INCREF(const_str_plain_type_shape);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 6, const_str_plain_entry); Py_INCREF(const_str_plain_entry);
    PyTuple_SET_ITEM(const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 7, const_str_plain_description); Py_INCREF(const_str_plain_description);
    const_tuple_str_plain_self_str_plain_shapes_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_shapes_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_shapes_tuple, 1, const_str_plain_shapes); Py_INCREF(const_str_plain_shapes);
    const_str_plain_getOperationBinaryBitMatMultLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 682382 ], 34, 1);
    const_str_digest_c15c72a7e37e89f81802924290efa8b4 = UNSTREAM_STRING_ASCII(&constant_bin[ 682416 ], 66, 0);
    const_str_digest_b20249b89da7c7d41d472a96cb3f04f7 = UNSTREAM_STRING_ASCII(&constant_bin[ 682482 ], 49, 0);
    const_str_digest_fe95f50f92c2a05973e7b6fedacebe1d = UNSTREAM_STRING_ASCII(&constant_bin[ 682531 ], 36, 0);
    const_str_digest_67fabd6d0d4cff0f1dd156de9e6b195c = UNSTREAM_STRING_ASCII(&constant_bin[ 682567 ], 58, 0);
    const_str_digest_96b820c249396a1aca0592af708777cf = UNSTREAM_STRING_ASCII(&constant_bin[ 682625 ], 48, 0);
    const_str_digest_09fa250c7788dd76d322da225470e409 = UNSTREAM_STRING_ASCII(&constant_bin[ 682673 ], 22, 0);
    const_str_plain_getOperationBinaryFloorDivLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 678449 ], 32, 1);
    const_str_digest_cae779c1a1dc30fc8c1cddf76f7f3c16 = UNSTREAM_STRING_ASCII(&constant_bin[ 682695 ], 64, 0);
    const_str_digest_46234c0d9fa622e2c891a3eeef342f81 = UNSTREAM_STRING_ASCII(&constant_bin[ 682759 ], 75, 0);
    const_str_digest_b867b57ef1511273804bd83b2ec25374 = UNSTREAM_STRING_ASCII(&constant_bin[ 682834 ], 30, 0);
    const_str_digest_5d4052745f0da93e79fd9db1fa2358ae = UNSTREAM_STRING_ASCII(&constant_bin[ 682864 ], 76, 0);
    const_str_digest_328609247c98d96b06f85f1dc9e9a651 = UNSTREAM_STRING_ASCII(&constant_bin[ 682940 ], 46, 0);
    const_str_digest_aa5851757158e07e6201e4ca073299b2 = UNSTREAM_STRING_ASCII(&constant_bin[ 682986 ], 63, 0);
    const_str_digest_dc11cc451e3f25cc39ee212d19c2267b = UNSTREAM_STRING_ASCII(&constant_bin[ 680340 ], 55, 0);
    const_str_digest_8f64e387ba2d40fbaf2e0c9911337215 = UNSTREAM_STRING_ASCII(&constant_bin[ 683049 ], 39, 0);
    const_str_plain_getOperationBinaryRShiftLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 683088 ], 30, 1);
    const_str_digest_5445345d5ab4fea2ae8f2eb419a7a1cd = UNSTREAM_STRING_ASCII(&constant_bin[ 683118 ], 34, 0);
    const_str_digest_d454e1ca882012a2883b67d83d0c86c5 = UNSTREAM_STRING_ASCII(&constant_bin[ 683152 ], 113, 0);
    const_str_plain_getOperationBinaryBitOrLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 683265 ], 29, 1);
    const_str_digest_84b5e8d5c8b459d742fc3e3a1516a732 = UNSTREAM_STRING_ASCII(&constant_bin[ 683294 ], 42, 0);
    const_str_plain_getOperationBinaryMultLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 683336 ], 28, 1);
    const_str_plain_getOperationBinarySubLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 683364 ], 27, 1);
    const_str_digest_0a1285450b6c1002a0164d8da0ba1cdc = UNSTREAM_STRING_ASCII(&constant_bin[ 683391 ], 57, 0);
    const_str_digest_e30a07ccc1c2a998704b9606b2835b95 = UNSTREAM_STRING_ASCII(&constant_bin[ 683448 ], 25, 0);
    const_str_digest_9947a771fdf7affcb1a68d2b4d5a662a = UNSTREAM_STRING_ASCII(&constant_bin[ 683473 ], 40, 0);
    const_str_digest_b527f90acd21e596976714914f889237 = UNSTREAM_STRING_ASCII(&constant_bin[ 683513 ], 59, 0);
    const_str_digest_53587ace7c4bf33107ed1f570aadf105 = UNSTREAM_STRING_ASCII(&constant_bin[ 683572 ], 30, 0);
    const_str_digest_1d7b5f7dfcc811f8fc7513c38a2587d8 = UNSTREAM_STRING_ASCII(&constant_bin[ 683602 ], 44, 0);
    const_str_digest_9b26d03e2a1655101f000317cbb0b0ec = UNSTREAM_STRING_ASCII(&constant_bin[ 683646 ], 58, 0);
    const_str_digest_255d85ab519561f7569c6132871b3a12 = UNSTREAM_STRING_ASCII(&constant_bin[ 683704 ], 76, 0);
    const_str_digest_fb06347c64ee3b801ccfd4a33d6bc377 = UNSTREAM_STRING_ASCII(&constant_bin[ 683780 ], 30, 0);
    const_str_digest_c39bde8b6b341623969694b505be7a70 = UNSTREAM_STRING_ASCII(&constant_bin[ 682416 ], 48, 0);
    const_str_digest_2af96047d68e2c8830c315efb5eb5e6e = UNSTREAM_STRING_ASCII(&constant_bin[ 680135 ], 48, 0);
    const_str_digest_8e7cf89322c3481963627b7f5dd2d7ce = UNSTREAM_STRING_ASCII(&constant_bin[ 683810 ], 39, 0);
    const_str_digest_e05dfff18ab5f0084ec7af38e27e39ec = UNSTREAM_STRING_ASCII(&constant_bin[ 683849 ], 56, 0);
    const_str_digest_b02c75ea17c35630c1c53481a1915463 = UNSTREAM_STRING_ASCII(&constant_bin[ 683905 ], 49, 0);
    const_str_digest_b16b9c9441e9c5fc2752839cfa5f5465 = UNSTREAM_STRING_ASCII(&constant_bin[ 683954 ], 43, 0);
    const_str_digest_034b2a937fdda560dc9a98763f96162c = UNSTREAM_STRING_ASCII(&constant_bin[ 683997 ], 59, 0);
    const_str_digest_cb155a5768e5f44496815fb1875631eb = UNSTREAM_STRING_ASCII(&constant_bin[ 684056 ], 43, 0);
    const_str_digest_0b24bf1a87dc3a7f1bf92158dade790a = UNSTREAM_STRING_ASCII(&constant_bin[ 684099 ], 56, 0);
    const_str_digest_1b169eed60667f879366fb78beb151ef = UNSTREAM_STRING_ASCII(&constant_bin[ 682695 ], 46, 0);
    const_str_digest_90f0220328a09edaf62c4482306ba916 = UNSTREAM_STRING_ASCII(&constant_bin[ 684155 ], 25, 0);
    const_str_digest_ce07a58f856c25460ff35b8a5e594d26 = UNSTREAM_STRING_ASCII(&constant_bin[ 684180 ], 76, 0);
    const_str_digest_b6d47b59a5c3db11af01e7a0db94bbe0 = UNSTREAM_STRING_ASCII(&constant_bin[ 684256 ], 41, 0);
    const_str_plain_ValueShapeUnknown = UNSTREAM_STRING_ASCII(&constant_bin[ 86250 ], 17, 1);
    const_str_digest_0d2c9cef16d5cc0608d81849836c876e = UNSTREAM_STRING_ASCII(&constant_bin[ 684297 ], 32, 0);
    const_str_digest_f96a037699f72408c3e0a6b5d83057b3 = UNSTREAM_STRING_ASCII(&constant_bin[ 684329 ], 64, 0);
    const_tuple_str_plain_ControlFlowDescriptionFullEscape_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_ControlFlowDescriptionFullEscape_tuple, 0, const_str_plain_ControlFlowDescriptionFullEscape); Py_INCREF(const_str_plain_ControlFlowDescriptionFullEscape);
    const_tuple_str_plain_self_str_plain_left_shape_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_left_shape_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_left_shape_tuple, 1, const_str_plain_left_shape); Py_INCREF(const_str_plain_left_shape);
    const_str_digest_e28b3e65378741fcd9441531f65e447f = UNSTREAM_STRING_ASCII(&constant_bin[ 684393 ], 56, 0);
    const_str_digest_22da858206cc847e210a9fa730c577aa = UNSTREAM_STRING_ASCII(&constant_bin[ 684449 ], 45, 0);
    const_str_digest_1ddcb2b45d6000f54afbf9eb0e90743b = UNSTREAM_STRING_ASCII(&constant_bin[ 684494 ], 30, 0);
    const_str_digest_682498401e8c313f897fef027fe921cc = UNSTREAM_STRING_ASCII(&constant_bin[ 684524 ], 61, 0);
    const_str_digest_9599c172028796027d409abf82468412 = UNSTREAM_STRING_ASCII(&constant_bin[ 684585 ], 72, 0);
    const_str_digest_e0bf05a64dce3920b00a790d74a3c152 = UNSTREAM_STRING_ASCII(&constant_bin[ 684657 ], 41, 0);
    const_str_digest_05a78548926bee9c0aa1504a38bc3272 = UNSTREAM_STRING_ASCII(&constant_bin[ 684698 ], 30, 0);
    const_tuple_str_plain_self_str_plain_emit_str_plain_type_shape_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_emit_str_plain_type_shape_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_emit_str_plain_type_shape_tuple, 1, const_str_plain_emit); Py_INCREF(const_str_plain_emit);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_emit_str_plain_type_shape_tuple, 2, const_str_plain_type_shape); Py_INCREF(const_str_plain_type_shape);
    const_str_plain_getOperationBinaryOldDivLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 677352 ], 30, 1);
    const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple, 1, const_str_plain_operation); Py_INCREF(const_str_plain_operation);
    PyTuple_SET_ITEM(const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple, 3, const_str_plain_type_shape); Py_INCREF(const_str_plain_type_shape);
    PyTuple_SET_ITEM(const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple, 4, const_str_plain_entry); Py_INCREF(const_str_plain_entry);
    const_str_plain__description = UNSTREAM_STRING_ASCII(&constant_bin[ 209791 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple, 5, const_str_plain__description); Py_INCREF(const_str_plain__description);
    const_str_digest_45e740ebd0e72590beff0fbc1084a81e = UNSTREAM_STRING_ASCII(&constant_bin[ 684728 ], 77, 0);
    const_str_digest_627c1a9a275d106b97f1899bf1ed6756 = UNSTREAM_STRING_ASCII(&constant_bin[ 684805 ], 78, 0);
    const_str_digest_7bb85642334b99ad0049c2629ee11a6d = UNSTREAM_STRING_ASCII(&constant_bin[ 684883 ], 56, 0);
    const_str_digest_652e076dbd067789ae3169ead7b44231 = UNSTREAM_STRING_ASCII(&constant_bin[ 684939 ], 29, 0);
    const_tuple_7f894d1a5e692237733383026dfad7fd_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_7f894d1a5e692237733383026dfad7fd_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_7f894d1a5e692237733383026dfad7fd_tuple, 1, const_str_plain_check); Py_INCREF(const_str_plain_check);
    PyTuple_SET_ITEM(const_tuple_7f894d1a5e692237733383026dfad7fd_tuple, 2, const_str_plain_result); Py_INCREF(const_str_plain_result);
    PyTuple_SET_ITEM(const_tuple_7f894d1a5e692237733383026dfad7fd_tuple, 3, const_str_plain_type_shape); Py_INCREF(const_str_plain_type_shape);
    PyTuple_SET_ITEM(const_tuple_7f894d1a5e692237733383026dfad7fd_tuple, 4, const_str_plain_r); Py_INCREF(const_str_plain_r);
    const_str_digest_b262ff30fa9e5c5b9c7b2430aa61ef08 = UNSTREAM_STRING_ASCII(&constant_bin[ 684968 ], 42, 0);
    const_str_digest_8c5302682484c126170068b2bd2d33ce = UNSTREAM_STRING_ASCII(&constant_bin[ 685010 ], 77, 0);
    const_str_digest_78e7f75305f7d62feb3a9dc186636f18 = UNSTREAM_STRING_ASCII(&constant_bin[ 685087 ], 75, 0);
    const_str_digest_cab3b6618917c459acfca3e5ab31358f = UNSTREAM_STRING_ASCII(&constant_bin[ 685087 ], 57, 0);
    const_str_digest_f8abc771bcfacef2d1c50cb3c2e4e301 = UNSTREAM_STRING_ASCII(&constant_bin[ 685162 ], 37, 0);
    const_str_digest_03fb79af517e133535ec295810dfac46 = UNSTREAM_STRING_ASCII(&constant_bin[ 685199 ], 42, 0);
    const_tuple_str_plain_shape_str_plain_size_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_shape_str_plain_size_tuple, 0, const_str_plain_shape); Py_INCREF(const_str_plain_shape);
    PyTuple_SET_ITEM(const_tuple_str_plain_shape_str_plain_size_tuple, 1, const_str_plain_size); Py_INCREF(const_str_plain_size);
    const_str_digest_4bb83b53e6a8045fe086d9e5bdc97f54 = UNSTREAM_STRING_ASCII(&constant_bin[ 685241 ], 31, 0);
    const_str_digest_87d515201677c9301fd970b13f35344c = UNSTREAM_STRING_ASCII(&constant_bin[ 684585 ], 54, 0);
    const_tuple_str_plain_ShapeLargeConstantValue_tuple_type_object_tuple_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_ShapeLargeConstantValue_tuple_type_object_tuple_tuple, 0, const_str_plain_ShapeLargeConstantValue); Py_INCREF(const_str_plain_ShapeLargeConstantValue);
    PyTuple_SET_ITEM(const_tuple_str_plain_ShapeLargeConstantValue_tuple_type_object_tuple_tuple, 1, const_tuple_type_object_tuple); Py_INCREF(const_tuple_type_object_tuple);
    const_str_digest_acc972e8d43650389227b81299d1ae15 = UNSTREAM_STRING_ASCII(&constant_bin[ 682759 ], 57, 0);
    const_str_digest_8d861b97287f8c44d00db282d2298711 = UNSTREAM_STRING_ASCII(&constant_bin[ 685272 ], 39, 0);
    const_str_digest_3c0042cdc3c9a57e46849cdc92b3eb3b = UNSTREAM_STRING_ASCII(&constant_bin[ 685311 ], 59, 0);
    const_str_digest_f9df910acf0215eaf464f92425dcd002 = UNSTREAM_STRING_ASCII(&constant_bin[ 685370 ], 42, 0);
    const_str_digest_47c5cdb23723111667af8a2a10d27324 = UNSTREAM_STRING_ASCII(&constant_bin[ 685412 ], 24, 0);
    const_str_digest_6078755004362c4ae543ea6452fd4308 = UNSTREAM_STRING_ASCII(&constant_bin[ 685436 ], 75, 0);
    const_tuple_str_plain_cls_str_plain_emit_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_emit_tuple, 0, const_str_plain_cls); Py_INCREF(const_str_plain_cls);
    PyTuple_SET_ITEM(const_tuple_str_plain_cls_str_plain_emit_tuple, 1, const_str_plain_emit); Py_INCREF(const_str_plain_emit);
    const_str_digest_9bece148b4f208983edca24b57ffdcae = UNSTREAM_STRING_ASCII(&constant_bin[ 685511 ], 39, 0);
    const_str_digest_1f0cdda054450e3fa5634a8722b3e7b8 = UNSTREAM_STRING_ASCII(&constant_bin[ 685550 ], 29, 0);
    const_str_digest_c8a3b90d77b847ed37d4a0b8bd57ab05 = UNSTREAM_STRING_ASCII(&constant_bin[ 685579 ], 34, 0);
    const_str_plain_getOperationBinaryPowLShape = UNSTREAM_STRING_ASCII(&constant_bin[ 677783 ], 27, 1);
    const_str_digest_380789f8960e6daa2e93c66890a30dca = UNSTREAM_STRING_ASCII(&constant_bin[ 685010 ], 59, 0);
    const_str_digest_d90d5c78caabd24db486a4ccbf59cd14 = UNSTREAM_STRING_ASCII(&constant_bin[ 685613 ], 31, 0);
    const_str_digest_b2df44234e2ee51d521095a7fa337920 = UNSTREAM_STRING_ASCII(&constant_bin[ 680655 ], 48, 0);
    const_tuple_str_plain_CTypePyObjectPtr_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_CTypePyObjectPtr_tuple, 0, const_str_plain_CTypePyObjectPtr); Py_INCREF(const_str_plain_CTypePyObjectPtr);
    const_str_digest_d34491a40e0b3b367fb66022378077d3 = UNSTREAM_STRING_ASCII(&constant_bin[ 685644 ], 44, 0);
    const_str_digest_5b903e5051ed33327d0845acb1aa06d6 = UNSTREAM_STRING_ASCII(&constant_bin[ 685688 ], 67, 0);
    const_str_digest_2cd707492de6eec06aba9aa75d93cda7 = UNSTREAM_STRING_ASCII(&constant_bin[ 685755 ], 26, 0);
    const_str_digest_2417025a2204fdfd1df0e2bcb92592e8 = UNSTREAM_STRING_ASCII(&constant_bin[ 685781 ], 59, 0);
    const_str_digest_8e711790dd74232149aab0a58c8a3a7f = UNSTREAM_STRING_ASCII(&constant_bin[ 685840 ], 75, 0);
    const_str_digest_acb5c981f9ec880bb67e20323a9b090c = UNSTREAM_STRING_ASCII(&constant_bin[ 685915 ], 48, 0);
    const_str_digest_9ac60839a4ad81e96900228ba26d8a4b = UNSTREAM_STRING_ASCII(&constant_bin[ 678844 ], 58, 0);
    const_str_digest_597956a8912e09241dc76842ab712a3c = UNSTREAM_STRING_ASCII(&constant_bin[ 685963 ], 63, 0);
    const_str_digest_b238134514f501a27042729c5b3f3441 = UNSTREAM_STRING_ASCII(&constant_bin[ 686026 ], 42, 0);
    const_str_digest_d00dd524112ac2daf0807f02a08713f5 = UNSTREAM_STRING_ASCII(&constant_bin[ 684180 ], 58, 0);
    const_str_digest_d6bf92263192a5627e57fff8feddd8f5 = UNSTREAM_STRING_ASCII(&constant_bin[ 679795 ], 57, 0);
    const_str_digest_8f14b440fd6ca8bff343a227d301809d = UNSTREAM_STRING_ASCII(&constant_bin[ 686068 ], 74, 0);
    const_str_digest_aa65ab12dd477f85bad48af2f0edbfe9 = UNSTREAM_STRING_ASCII(&constant_bin[ 682864 ], 58, 0);
    const_str_plain__collectShapeOperation = UNSTREAM_STRING_ASCII(&constant_bin[ 677462 ], 22, 1);
    const_str_digest_8e5ece21e576f546463bfe5c2f0ba8e5 = UNSTREAM_STRING_ASCII(&constant_bin[ 686142 ], 72, 0);
    const_str_digest_fea64aa82d89c33944e5ab8ceb84ea5f = UNSTREAM_STRING_ASCII(&constant_bin[ 686214 ], 77, 0);
    const_str_digest_c9c35ef4cfa2cd9b28f23fe80d1b5aa7 = UNSTREAM_STRING_ASCII(&constant_bin[ 446347 ], 40, 0);
    const_str_digest_cb30ed96be09f5491dc64c5417a592d5 = UNSTREAM_STRING_ASCII(&constant_bin[ 686291 ], 30, 0);
    const_str_digest_4ab5d94003c31387d8faf22e555d63b0 = UNSTREAM_STRING_ASCII(&constant_bin[ 686321 ], 39, 0);
    const_str_digest_aaa846ca7fe03417eeca473ef7d50543 = UNSTREAM_STRING_ASCII(&constant_bin[ 681631 ], 54, 0);

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_site$$45$packages$nuitka$nodes$shapes$StandardShapes(void) {
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_6302733a60eca15cfc35740f6b43693f;
static PyCodeObject *codeobj_7c85d5316288c6cbdec21410c52b261d;
static PyCodeObject *codeobj_b2a1bf0e8cf458d869fb18b9aca64a04;
static PyCodeObject *codeobj_8cdd1cf02b6e91978eb12c28eb60bd5b;
static PyCodeObject *codeobj_b8bb20277bc146b9f2d9eb297a44862e;
static PyCodeObject *codeobj_24e64e080f977ec2c688592a89cab564;
static PyCodeObject *codeobj_4f7853b32d446d492871a3092798aa20;
static PyCodeObject *codeobj_cc89ba8a3dc4ca5e9a8187a8b1fe39dd;
static PyCodeObject *codeobj_18bda4c64265e404b7aaf22dc15b2d12;
static PyCodeObject *codeobj_0deae47aea120f40c053e988347a77a8;
static PyCodeObject *codeobj_f95de718f13fcea583daf1efacdefdb0;
static PyCodeObject *codeobj_76ee1733c9e71f1b5d4cbcef34146606;
static PyCodeObject *codeobj_d26a4ad1ef1a2f2b0ab74283bf91d39c;
static PyCodeObject *codeobj_26bc50f31cbb49207bb35be4ca0587b0;
static PyCodeObject *codeobj_0333d7f7a3f0e07402c652ec964b3d26;
static PyCodeObject *codeobj_298fce9d2aa2b6ff2b7027183ccc4ed1;
static PyCodeObject *codeobj_c28932552839632b2b12c0c3408e4ea3;
static PyCodeObject *codeobj_8c07135053c1f08248f8e07045be6e55;
static PyCodeObject *codeobj_3f41991df1be5fc8332b7034fc522534;
static PyCodeObject *codeobj_3aa00639304e27a92d16236ecf68307c;
static PyCodeObject *codeobj_16d5e8aa45f52a0ffbe0ad9ded831f67;
static PyCodeObject *codeobj_cf083e9cfbad2c159d4aced3a9ce2f13;
static PyCodeObject *codeobj_ae60fc6cc678c38925186346b02b8b4d;
static PyCodeObject *codeobj_c6fedd91871b754cb84e7622a10d1bf8;
static PyCodeObject *codeobj_a00d35d4a235c5f8456762b71f4a78d8;
static PyCodeObject *codeobj_b106615f89fdb156afc27cd670a27ae1;
static PyCodeObject *codeobj_5177af75f0d50388640dc79607719db2;
static PyCodeObject *codeobj_48a7b3d2a10292d9b503c411427e1f81;
static PyCodeObject *codeobj_82587817d4eefe554b1bf051b3a97d84;
static PyCodeObject *codeobj_70217d00d45fc96da8509d7a100c38b7;
static PyCodeObject *codeobj_9213af8db78767aff8cead2d99c1749e;
static PyCodeObject *codeobj_7cf65518226adba994bd642d64603a44;
static PyCodeObject *codeobj_1fabff4328626adf4b34b26b8241dfdf;
static PyCodeObject *codeobj_5c1a84bec52aef4d7d0ddcbc4e61e1e3;
static PyCodeObject *codeobj_055e2ca14ff87752a7d8fd63af7652a1;
static PyCodeObject *codeobj_cdbf906c0739ab6356e0e347536125aa;
static PyCodeObject *codeobj_98f81faae2bf81700a9b4d64a2a300b8;
static PyCodeObject *codeobj_bcc5afc5622beff01e962364d56f676b;
static PyCodeObject *codeobj_da56531b628e3ca972ef4a15f3f08a5e;
static PyCodeObject *codeobj_e7c71e6f889cab8489245cf49f121e69;
static PyCodeObject *codeobj_58219c7fcfbff9bb0579c8d429f43f1f;
static PyCodeObject *codeobj_fbcacf0dd7105f7e77a454cdc3975a6d;
static PyCodeObject *codeobj_2a661cbeaf4f4cdde5f67a06430e33d1;
static PyCodeObject *codeobj_30d744ac1c2b5a81f536d4ad013b3e3a;
static PyCodeObject *codeobj_314cddf2026135a2b36d24db96264100;
static PyCodeObject *codeobj_b49158edaeabda446bf086b2eb083353;
static PyCodeObject *codeobj_c1a664c66de179cd92cb9a38d83e5344;
static PyCodeObject *codeobj_2562b0e500dd6b012dd5989b37851978;
static PyCodeObject *codeobj_443e077e6134ea2158171ecac004feeb;
static PyCodeObject *codeobj_a09999ee0b961cf0bc904e3250f3dd24;
static PyCodeObject *codeobj_5310b13332f11e9c5a2f13a4f54ec265;
static PyCodeObject *codeobj_a28c20139dda310267de405e90aedb3b;
static PyCodeObject *codeobj_825ccb8ddbea6048defc2fcd9766b195;
static PyCodeObject *codeobj_208a723e26e261a3bf976d79358671a0;
static PyCodeObject *codeobj_3d9d357ef5fd95d0ea8392fcfe0fb9f6;
static PyCodeObject *codeobj_aadd76d1ac15293cca02cc13b85b7e65;
static PyCodeObject *codeobj_4f95aee009bf65dad8462a36a27ef7b2;
static PyCodeObject *codeobj_a818f4846d9afff91b53bc51915b56db;
static PyCodeObject *codeobj_3dd985f11eb0390621d8aa4f697a7080;
static PyCodeObject *codeobj_2569be5f046998681575c4cffffe0229;
static PyCodeObject *codeobj_37abb6baa47331d3a21966c1a9dcd9a1;
static PyCodeObject *codeobj_5c600498451b8d72313d3e673c48c257;
static PyCodeObject *codeobj_7c100bf546aed522cbd46c14979c3efc;
static PyCodeObject *codeobj_d267c448b6251b74e5be0a1f61bbb709;
static PyCodeObject *codeobj_70e317dae3fb5986fcb73404909f3e30;
static PyCodeObject *codeobj_6390b7f7acb0d560e13329b28fdb6941;
static PyCodeObject *codeobj_03b6369ad1eae0faab06dedb33f72ed3;
static PyCodeObject *codeobj_c390965f85f4215d855d80d3672dc3ef;
static PyCodeObject *codeobj_db559a66c57804d1299b0a78f87fee65;
static PyCodeObject *codeobj_daf8c11419498c5f135c12cffe0042c9;
static PyCodeObject *codeobj_98a1e21a840c28842f395e2877031f1d;
static PyCodeObject *codeobj_0931520935c7e99ab3dcaee9ad1b2b86;
static PyCodeObject *codeobj_5366e9a5a3a3a2940f454d9212513daa;
static PyCodeObject *codeobj_20fdbaf40e4c640828046210bbe44889;
static PyCodeObject *codeobj_5cf72a68714c34d1eca72117e53cd4c7;
static PyCodeObject *codeobj_e8edcee2bcc3a3c47a8e3d80ccbd9d98;
static PyCodeObject *codeobj_34497d9734a343c6e4c38b4f0585ce64;
static PyCodeObject *codeobj_aab3111a94fa8100bd8f5d5fb097a9d7;
static PyCodeObject *codeobj_634e0d0e6b9ca9e13c2e7613437423ba;
static PyCodeObject *codeobj_29fb47d6e17a7db0be35c6eeddb22698;
static PyCodeObject *codeobj_875572138db468037ef97f678b91cfcd;
static PyCodeObject *codeobj_3bbac0237f2002868a95b78402153953;
static PyCodeObject *codeobj_32b984094e77316abf5e33762f53b721;
static PyCodeObject *codeobj_02a760bb24dd602344ff02253e7d2d49;
static PyCodeObject *codeobj_678bd036360d1eb3a05a8cdfaa296054;
static PyCodeObject *codeobj_e1948cbedd102577e7c86b2494befd90;
static PyCodeObject *codeobj_3aea18dc8eb5b018ebd7f4ecac8bb769;
static PyCodeObject *codeobj_11e7ab378f88e66229cd37c1b8ae6f5a;
static PyCodeObject *codeobj_6517a9e6af7657c6c498ec1df71e5715;
static PyCodeObject *codeobj_de429e1ffc0386afb873c85570f8584a;
static PyCodeObject *codeobj_fb6c31fd0fb939d2e4c0c9e55ad06301;
static PyCodeObject *codeobj_59ddd5bade3e7d7071096f791af6bb2f;
static PyCodeObject *codeobj_a4b3d419635a7d10c41957d99b9159db;
static PyCodeObject *codeobj_e5d0fed2b249d1b8ba1ccf80b6875e05;
static PyCodeObject *codeobj_c18b64232e6fc0478d21a489ab050c32;
static PyCodeObject *codeobj_87f148f9ab85354cc524c43c25996583;
static PyCodeObject *codeobj_022829a966c1f23e7ccf00bde09aee2d;
static PyCodeObject *codeobj_19d7eb5a646720b3401b683db4b2185f;
static PyCodeObject *codeobj_8d52d35578ce25dc5ed9bb1ffc8f2a50;
static PyCodeObject *codeobj_9b28af0540046a6af23498002ebb11c4;
static PyCodeObject *codeobj_2ff7ba750e4d1ecf070df3a4a0896ed0;
static PyCodeObject *codeobj_3dfb915e058f7cd39b9377754263a24f;
static PyCodeObject *codeobj_c714d2a2f7bfad7079061d65fe46ada6;
static PyCodeObject *codeobj_cb66089c7c49445489a6df4c43c43e5b;
static PyCodeObject *codeobj_0c1fd16734cb23f268c3b167c098d5b8;
static PyCodeObject *codeobj_1bd7d763ce82777b8bc18c38ea0167ca;
static PyCodeObject *codeobj_b22d37a6a511a522a7e064ecabab8350;
static PyCodeObject *codeobj_772acebd2213c5bdb8b999e2489f6bca;
static PyCodeObject *codeobj_c6072bc075ab36c511024aa4ee91175d;
static PyCodeObject *codeobj_16ae7053c6540f737e1f47f13348d563;
static PyCodeObject *codeobj_3dd45ca70afc01291f9356164bd33100;
static PyCodeObject *codeobj_a591b45e141f9e1407e183961bfaacf7;
static PyCodeObject *codeobj_2e8d5b7e70c842f835f5724785f66100;
static PyCodeObject *codeobj_92ab9ca6c3d62cc16d8e60249b83ab8c;
static PyCodeObject *codeobj_92c1d4b76e96a3fed296e8929c9652c0;
static PyCodeObject *codeobj_80ca9f6e6aceaa2ee897274b7bf46769;
static PyCodeObject *codeobj_de246dc45def92d44d802cefb7b0ae4b;
static PyCodeObject *codeobj_e4b9971ff2e44c8eb16719c5a7a83aca;
static PyCodeObject *codeobj_ccebd776c0e9937695f958a434521a69;
static PyCodeObject *codeobj_41ed3b8a61648a26b73c29af4c38df95;
static PyCodeObject *codeobj_a03bf40e3eb8edc8605a7e62ecdd3212;
static PyCodeObject *codeobj_499f52653ddcc4cf7b070bb86ee33cb5;
static PyCodeObject *codeobj_c3da3b096edbebbddbe97561bde3609f;
static PyCodeObject *codeobj_9b596b8c78a93eea39d745589a3900b6;
static PyCodeObject *codeobj_9c35ab8056efcc1e1a9cbbeae45063e2;
static PyCodeObject *codeobj_876a1e5fe9d10bccf76f38ef397f6295;
static PyCodeObject *codeobj_cf4ec8f3fd82f729a4fed2653f5c444f;
static PyCodeObject *codeobj_a11317166dcd24d5b94654425530a792;
static PyCodeObject *codeobj_9f37cab9541cc450eb9c857ae61b29a1;
static PyCodeObject *codeobj_b1fc41a4b1b55db7c1dab679545abd03;
static PyCodeObject *codeobj_16f3995a02c0e9c79caad0e3968c3371;
static PyCodeObject *codeobj_99127d41fd2b0d07a06cc6547a8fe896;
static PyCodeObject *codeobj_816d37b6bd67981dc36715502904915c;
static PyCodeObject *codeobj_fcfb7c2b1f4bf8340de4834a4181b333;
static PyCodeObject *codeobj_cedcccd9f989b37336d1dea134c62a2f;
static PyCodeObject *codeobj_9a1cd419ff5f7369aad29af0cbf529dc;
static PyCodeObject *codeobj_1d78d973fdfa93709e28c3b9fb0259d5;
static PyCodeObject *codeobj_f9937f0aba6a561a1e4c7b53de1f19ef;
static PyCodeObject *codeobj_d40437d95659f9bf5a7905552e30aca2;
static PyCodeObject *codeobj_4d67752b63622030491af6955ba617a7;
static PyCodeObject *codeobj_3645059692b6a687f1cc693a5e2a7992;
static PyCodeObject *codeobj_89a8f8ac78edc545758a6558f344ee65;
static PyCodeObject *codeobj_2e3216b1267876dc850124ca8effd7c7;
static PyCodeObject *codeobj_92c12f700eb21f649d49d8acb8025fa1;
static PyCodeObject *codeobj_378f783feea5c5ee55f1db0e91ea08cf;
static PyCodeObject *codeobj_04bb67784ec2ae1c58a2b767c0192b14;
static PyCodeObject *codeobj_89c2e72108c717d051bc2f3380028c01;
static PyCodeObject *codeobj_4e32de501717c1aec308daeedf0101e1;
static PyCodeObject *codeobj_f106a1a4d7fc00f78b1f75bd99972f11;
static PyCodeObject *codeobj_5116cfd790e929ec7c172c3075615daf;
static PyCodeObject *codeobj_8dd75cae359f2182c58f87b80393d24e;
static PyCodeObject *codeobj_b7c9f7c3ee3a065c315692d6d6b121d6;
static PyCodeObject *codeobj_4a871f328f64bc7fb78c4391d9ae083c;
static PyCodeObject *codeobj_7ca2522bf2581894b1beb8f845b610a2;
static PyCodeObject *codeobj_9aab73c7d497adf0ecd3b65c524655cc;
static PyCodeObject *codeobj_a7baa7c0f07185d9e8b484fee1877a94;
static PyCodeObject *codeobj_b584a9e3380c2590713c3f1fcc9529d0;
static PyCodeObject *codeobj_09ec202a6c4c061684a9757d62bf95f9;
static PyCodeObject *codeobj_366bfe275f86f90b862b24584f82a814;
static PyCodeObject *codeobj_8925401d2d7666c1c1f7ff4e170d4927;
static PyCodeObject *codeobj_ccbdbf168ce9b29845afaf138f608d62;
static PyCodeObject *codeobj_70f9e31a0a98ee3ca758fa8bf06d7ae9;
static PyCodeObject *codeobj_cfa96613c609587ff5d56994103aa43b;
static PyCodeObject *codeobj_8fd6898fba148c461cb27db922645580;
static PyCodeObject *codeobj_09b833cccf2012f65ae2f8fe2ea9e6f0;
static PyCodeObject *codeobj_b8b3c14b8b2545d9f3a0de139c5cd3f4;
static PyCodeObject *codeobj_2f307bb43cefd698e5c636502311625a;
static PyCodeObject *codeobj_b52bbf96acad86ac80f5dbb8709c292f;
static PyCodeObject *codeobj_cd783a51523183bd96d40e52e2be64d3;
static PyCodeObject *codeobj_90e4ebaa842519314147c2eda45dd7ae;
static PyCodeObject *codeobj_2f4520eafc261c3a8b579825550a022e;
static PyCodeObject *codeobj_0e77d4d63e616eb1a3bc028bbd180e01;
static PyCodeObject *codeobj_3c58c0b1373f4cdeab30cf41740a1706;
static PyCodeObject *codeobj_ceb5972e74036bff8934f4bde148658d;
static PyCodeObject *codeobj_8a7f0f6cb1b6d1a79102c587416607e0;
static PyCodeObject *codeobj_261904682a894c605dc4a31d2ba13d77;
static PyCodeObject *codeobj_e4ffd958de903bd2c2a7941492898be6;
static PyCodeObject *codeobj_954260a5d80350d35448265904c2ece9;
static PyCodeObject *codeobj_ff4571568d88d9e77d9e1b964de0b0cf;
static PyCodeObject *codeobj_f7a94311b4b68316590dc83f56d0fdfa;
static PyCodeObject *codeobj_c887985073edec097f150e9c98e0cfe9;
static PyCodeObject *codeobj_7375bd3b7c5c494c7b6e41ec225ff82d;
static PyCodeObject *codeobj_e1ea14b18ebff6d3e87dbd7f9e59473c;
static PyCodeObject *codeobj_c215eed7076c01dc4a3d37b768a1c271;
static PyCodeObject *codeobj_2002d456b69ea529e08aed94c4b75e71;
static PyCodeObject *codeobj_b41ca985d47eaf533323004d01c2f936;
static PyCodeObject *codeobj_a347f3f55a405604ff7de8cac0d96fbd;
static PyCodeObject *codeobj_39c42cee787eff76aedb26ca2eb2746f;
static PyCodeObject *codeobj_d162cf51f4337d7c44c85056e237dcd9;
static PyCodeObject *codeobj_6ba11ba0e23039b19e0dc773c8a602ea;
static PyCodeObject *codeobj_70252d84a66c9c64934c4c4eed81830e;

static void createModuleCodeObjects(void) {
    module_filename_obj = const_str_digest_d454e1ca882012a2883b67d83d0c86c5;
    codeobj_6302733a60eca15cfc35740f6b43693f = MAKE_CODEOBJECT(module_filename_obj, 601, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_7c85d5316288c6cbdec21410c52b261d = MAKE_CODEOBJECT(module_filename_obj, 614, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_b2a1bf0e8cf458d869fb18b9aca64a04 = MAKE_CODEOBJECT(module_filename_obj, 627, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_8cdd1cf02b6e91978eb12c28eb60bd5b = MAKE_CODEOBJECT(module_filename_obj, 640, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_b8bb20277bc146b9f2d9eb297a44862e = MAKE_CODEOBJECT(module_filename_obj, 653, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_24e64e080f977ec2c688592a89cab564 = MAKE_CODEOBJECT(module_filename_obj, 666, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_4f7853b32d446d492871a3092798aa20 = MAKE_CODEOBJECT(module_filename_obj, 679, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_cc89ba8a3dc4ca5e9a8187a8b1fe39dd = MAKE_CODEOBJECT(module_filename_obj, 692, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_18bda4c64265e404b7aaf22dc15b2d12 = MAKE_CODEOBJECT(module_filename_obj, 705, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_0deae47aea120f40c053e988347a77a8 = MAKE_CODEOBJECT(module_filename_obj, 718, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_f95de718f13fcea583daf1efacdefdb0 = MAKE_CODEOBJECT(module_filename_obj, 731, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_76ee1733c9e71f1b5d4cbcef34146606 = MAKE_CODEOBJECT(module_filename_obj, 744, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_d26a4ad1ef1a2f2b0ab74283bf91d39c = MAKE_CODEOBJECT(module_filename_obj, 757, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_26bc50f31cbb49207bb35be4ca0587b0 = MAKE_CODEOBJECT(module_filename_obj, 770, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_0333d7f7a3f0e07402c652ec964b3d26 = MAKE_CODEOBJECT(module_filename_obj, 783, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_298fce9d2aa2b6ff2b7027183ccc4ed1 = MAKE_CODEOBJECT(module_filename_obj, 872, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_c28932552839632b2b12c0c3408e4ea3 = MAKE_CODEOBJECT(module_filename_obj, 882, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_8c07135053c1f08248f8e07045be6e55 = MAKE_CODEOBJECT(module_filename_obj, 892, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_3f41991df1be5fc8332b7034fc522534 = MAKE_CODEOBJECT(module_filename_obj, 902, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_3aa00639304e27a92d16236ecf68307c = MAKE_CODEOBJECT(module_filename_obj, 912, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_16d5e8aa45f52a0ffbe0ad9ded831f67 = MAKE_CODEOBJECT(module_filename_obj, 922, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_cf083e9cfbad2c159d4aced3a9ce2f13 = MAKE_CODEOBJECT(module_filename_obj, 932, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_ae60fc6cc678c38925186346b02b8b4d = MAKE_CODEOBJECT(module_filename_obj, 942, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_c6fedd91871b754cb84e7622a10d1bf8 = MAKE_CODEOBJECT(module_filename_obj, 952, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_a00d35d4a235c5f8456762b71f4a78d8 = MAKE_CODEOBJECT(module_filename_obj, 962, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_b106615f89fdb156afc27cd670a27ae1 = MAKE_CODEOBJECT(module_filename_obj, 972, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_5177af75f0d50388640dc79607719db2 = MAKE_CODEOBJECT(module_filename_obj, 982, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_48a7b3d2a10292d9b503c411427e1f81 = MAKE_CODEOBJECT(module_filename_obj, 992, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_82587817d4eefe554b1bf051b3a97d84 = MAKE_CODEOBJECT(module_filename_obj, 1002, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_70217d00d45fc96da8509d7a100c38b7 = MAKE_CODEOBJECT(module_filename_obj, 1114, CO_OPTIMIZED | CO_NEWLOCALS, const_str_angle_lambda, const_tuple_str_plain_left_shape_str_plain_right_shape_tuple, 1, 0, 0);
    codeobj_9213af8db78767aff8cead2d99c1749e = MAKE_CODEOBJECT(module_filename_obj, 1161, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_7cf65518226adba994bd642d64603a44 = MAKE_CODEOBJECT(module_filename_obj, 1164, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_1fabff4328626adf4b34b26b8241dfdf = MAKE_CODEOBJECT(module_filename_obj, 1167, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_5c1a84bec52aef4d7d0ddcbc4e61e1e3 = MAKE_CODEOBJECT(module_filename_obj, 1170, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_055e2ca14ff87752a7d8fd63af7652a1 = MAKE_CODEOBJECT(module_filename_obj, 1173, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_cdbf906c0739ab6356e0e347536125aa = MAKE_CODEOBJECT(module_filename_obj, 1176, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_98f81faae2bf81700a9b4d64a2a300b8 = MAKE_CODEOBJECT(module_filename_obj, 1179, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_bcc5afc5622beff01e962364d56f676b = MAKE_CODEOBJECT(module_filename_obj, 1182, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_da56531b628e3ca972ef4a15f3f08a5e = MAKE_CODEOBJECT(module_filename_obj, 1185, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_e7c71e6f889cab8489245cf49f121e69 = MAKE_CODEOBJECT(module_filename_obj, 1188, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_58219c7fcfbff9bb0579c8d429f43f1f = MAKE_CODEOBJECT(module_filename_obj, 1191, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_lambda, const_tuple_str_plain_x_tuple, 1, 0, 0);
    codeobj_fbcacf0dd7105f7e77a454cdc3975a6d = MAKE_CODEOBJECT(module_filename_obj, 1, CO_NOFREE, const_str_digest_13fc0a95d0665b0c4d5bc5f80c1f4584, const_tuple_empty, 0, 0, 0);
    codeobj_2a661cbeaf4f4cdde5f67a06430e33d1 = MAKE_CODEOBJECT(module_filename_obj, 26, CO_NOFREE, const_str_plain_ShapeBase, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_30d744ac1c2b5a81f536d4ad013b3e3a = MAKE_CODEOBJECT(module_filename_obj, 519, CO_NOFREE, const_str_plain_ShapeIterator, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_314cddf2026135a2b36d24db96264100 = MAKE_CODEOBJECT(module_filename_obj, 492, CO_NOFREE, const_str_plain_ShapeLargeConstantValue, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_b49158edaeabda446bf086b2eb083353 = MAKE_CODEOBJECT(module_filename_obj, 510, CO_NOFREE, const_str_plain_ShapeLargeConstantValuePredictable, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_c1a664c66de179cd92cb9a38d83e5344 = MAKE_CODEOBJECT(module_filename_obj, 806, CO_NOFREE, const_str_plain_ShapeLoopCompleteAlternative, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_2562b0e500dd6b012dd5989b37851978 = MAKE_CODEOBJECT(module_filename_obj, 557, CO_NOFREE, const_str_plain_ShapeLoopInitialAlternative, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_443e077e6134ea2158171ecac004feeb = MAKE_CODEOBJECT(module_filename_obj, 411, CO_NOFREE, const_str_plain_ShapeUnknown, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_a09999ee0b961cf0bc904e3250f3dd24 = MAKE_CODEOBJECT(module_filename_obj, 473, CO_NOFREE, const_str_plain_ValueShapeBase, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_5310b13332f11e9c5a2f13a4f54ec265 = MAKE_CODEOBJECT(module_filename_obj, 480, CO_NOFREE, const_str_plain_ValueShapeUnknown, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_a28c20139dda310267de405e90aedb3b = MAKE_CODEOBJECT(module_filename_obj, 570, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_shapes_tuple, 2, 0, 0);
    codeobj_825ccb8ddbea6048defc2fcd9766b195 = MAKE_CODEOBJECT(module_filename_obj, 819, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_shapes_tuple, 2, 0, 0);
    codeobj_208a723e26e261a3bf976d79358671a0 = MAKE_CODEOBJECT(module_filename_obj, 513, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_6581d4b45daab8949369aff04ae4c3cf_tuple, 4, 0, 0);
    codeobj_3d9d357ef5fd95d0ea8392fcfe0fb9f6 = MAKE_CODEOBJECT(module_filename_obj, 495, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_str_plain_self_str_plain_size_str_plain_shape_tuple, 3, 0, 0);
    codeobj_aadd76d1ac15293cca02cc13b85b7e65 = MAKE_CODEOBJECT(module_filename_obj, 579, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__collectInitialShape, const_tuple_87aa7a8ac65180134342b098bc7a9d83_tuple, 2, 0, 0);
    codeobj_4f95aee009bf65dad8462a36a27ef7b2 = MAKE_CODEOBJECT(module_filename_obj, 828, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__collectShapeOperation, const_tuple_7d151f34399cd9c9910ee2fcdedef7f6_tuple, 2, 0, 0);
    codeobj_a818f4846d9afff91b53bc51915b56db = MAKE_CODEOBJECT(module_filename_obj, 1139, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__delegatedCheck, const_tuple_7f894d1a5e692237733383026dfad7fd_tuple, 2, 0, 0);
    codeobj_3dd985f11eb0390621d8aa4f697a7080 = MAKE_CODEOBJECT(module_filename_obj, 406, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_emitAlternatives, const_tuple_str_plain_cls_str_plain_emit_tuple, 2, 0, 0);
    codeobj_2569be5f046998681575c4cffffe0229 = MAKE_CODEOBJECT(module_filename_obj, 575, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_emitAlternatives, const_tuple_str_plain_self_str_plain_emit_str_plain_type_shape_tuple, 2, 0, 0);
    codeobj_37abb6baa47331d3a21966c1a9dcd9a1 = MAKE_CODEOBJECT(module_filename_obj, 824, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_emitAlternatives, const_tuple_str_plain_self_str_plain_emit_str_plain_type_shape_tuple, 2, 0, 0);
    codeobj_5c600498451b8d72313d3e673c48c257 = MAKE_CODEOBJECT(module_filename_obj, 33, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getCType, const_tuple_empty, 0, 0, 0);
    codeobj_7c100bf546aed522cbd46c14979c3efc = MAKE_CODEOBJECT(module_filename_obj, 398, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonEqShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_d267c448b6251b74e5be0a1f61bbb709 = MAKE_CODEOBJECT(module_filename_obj, 799, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonEqShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_70e317dae3fb5986fcb73404909f3e30 = MAKE_CODEOBJECT(module_filename_obj, 1133, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonEqShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_6390b7f7acb0d560e13329b28fdb6941 = MAKE_CODEOBJECT(module_filename_obj, 390, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonGtShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_03b6369ad1eae0faab06dedb33f72ed3 = MAKE_CODEOBJECT(module_filename_obj, 793, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonGtShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_c390965f85f4215d855d80d3672dc3ef = MAKE_CODEOBJECT(module_filename_obj, 1127, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonGtShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_db559a66c57804d1299b0a78f87fee65 = MAKE_CODEOBJECT(module_filename_obj, 394, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonGteShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_daf8c11419498c5f135c12cffe0042c9 = MAKE_CODEOBJECT(module_filename_obj, 796, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonGteShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_98a1e21a840c28842f395e2877031f1d = MAKE_CODEOBJECT(module_filename_obj, 1130, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonGteShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_0931520935c7e99ab3dcaee9ad1b2b86 = MAKE_CODEOBJECT(module_filename_obj, 1119, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLtLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_5366e9a5a3a3a2940f454d9212513daa = MAKE_CODEOBJECT(module_filename_obj, 380, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLtShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_20fdbaf40e4c640828046210bbe44889 = MAKE_CODEOBJECT(module_filename_obj, 468, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLtShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_5cf72a68714c34d1eca72117e53cd4c7 = MAKE_CODEOBJECT(module_filename_obj, 777, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLtShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_e8edcee2bcc3a3c47a8e3d80ccbd9d98 = MAKE_CODEOBJECT(module_filename_obj, 1109, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLtShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_34497d9734a343c6e4c38b4f0585ce64 = MAKE_CODEOBJECT(module_filename_obj, 386, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLteShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_aab3111a94fa8100bd8f5d5fb097a9d7 = MAKE_CODEOBJECT(module_filename_obj, 790, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLteShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_634e0d0e6b9ca9e13c2e7613437423ba = MAKE_CODEOBJECT(module_filename_obj, 1124, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonLteShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_29fb47d6e17a7db0be35c6eeddb22698 = MAKE_CODEOBJECT(module_filename_obj, 402, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonNeqShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_875572138db468037ef97f678b91cfcd = MAKE_CODEOBJECT(module_filename_obj, 802, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonNeqShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_3bbac0237f2002868a95b78402153953 = MAKE_CODEOBJECT(module_filename_obj, 1136, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getComparisonNeqShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_32b984094e77316abf5e33762f53b721 = MAKE_CODEOBJECT(module_filename_obj, 1009, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryAddLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_02a760bb24dd602344ff02253e7d2d49 = MAKE_CODEOBJECT(module_filename_obj, 412, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryAddShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_678bd036360d1eb3a05a8cdfaa296054 = MAKE_CODEOBJECT(module_filename_obj, 91, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryAddShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_e1948cbedd102577e7c86b2494befd90 = MAKE_CODEOBJECT(module_filename_obj, 595, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryAddShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_3aea18dc8eb5b018ebd7f4ecac8bb769 = MAKE_CODEOBJECT(module_filename_obj, 867, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryAddShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_11e7ab378f88e66229cd37c1b8ae6f5a = MAKE_CODEOBJECT(module_filename_obj, 1088, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitAndLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_6517a9e6af7657c6c498ec1df71e5715 = MAKE_CODEOBJECT(module_filename_obj, 456, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitAndShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_de429e1ffc0386afb873c85570f8584a = MAKE_CODEOBJECT(module_filename_obj, 319, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitAndShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_fb6c31fd0fb939d2e4c0c9e55ad06301 = MAKE_CODEOBJECT(module_filename_obj, 738, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitAndShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_59ddd5bade3e7d7071096f791af6bb2f = MAKE_CODEOBJECT(module_filename_obj, 977, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitAndShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_a4b3d419635a7d10c41957d99b9159db = MAKE_CODEOBJECT(module_filename_obj, 1081, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitOrLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_e5d0fed2b249d1b8ba1ccf80b6875e05 = MAKE_CODEOBJECT(module_filename_obj, 452, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitOrShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_c18b64232e6fc0478d21a489ab050c32 = MAKE_CODEOBJECT(module_filename_obj, 298, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitOrShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_87f148f9ab85354cc524c43c25996583 = MAKE_CODEOBJECT(module_filename_obj, 725, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitOrShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_022829a966c1f23e7ccf00bde09aee2d = MAKE_CODEOBJECT(module_filename_obj, 967, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitOrShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_19d7eb5a646720b3401b683db4b2185f = MAKE_CODEOBJECT(module_filename_obj, 1095, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitXorLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_8d52d35578ce25dc5ed9bb1ffc8f2a50 = MAKE_CODEOBJECT(module_filename_obj, 460, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitXorShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_9b28af0540046a6af23498002ebb11c4 = MAKE_CODEOBJECT(module_filename_obj, 340, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitXorShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_2ff7ba750e4d1ecf070df3a4a0896ed0 = MAKE_CODEOBJECT(module_filename_obj, 751, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitXorShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_3dfb915e058f7cd39b9377754263a24f = MAKE_CODEOBJECT(module_filename_obj, 987, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryBitXorShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_c714d2a2f7bfad7079061d65fe46ada6 = MAKE_CODEOBJECT(module_filename_obj, 1032, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryFloorDivLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_cb66089c7c49445489a6df4c43c43e5b = MAKE_CODEOBJECT(module_filename_obj, 424, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryFloorDivShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_0c1fd16734cb23f268c3b167c098d5b8 = MAKE_CODEOBJECT(module_filename_obj, 151, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryFloorDivShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_1bd7d763ce82777b8bc18c38ea0167ca = MAKE_CODEOBJECT(module_filename_obj, 634, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryFloorDivShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_b22d37a6a511a522a7e064ecabab8350 = MAKE_CODEOBJECT(module_filename_obj, 897, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryFloorDivShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_772acebd2213c5bdb8b999e2489f6bca = MAKE_CODEOBJECT(module_filename_obj, 1067, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryLShiftLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_c6072bc075ab36c511024aa4ee91175d = MAKE_CODEOBJECT(module_filename_obj, 444, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryLShiftShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_16ae7053c6540f737e1f47f13348d563 = MAKE_CODEOBJECT(module_filename_obj, 256, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryLShiftShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_3dd45ca70afc01291f9356164bd33100 = MAKE_CODEOBJECT(module_filename_obj, 699, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryLShiftShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_a591b45e141f9e1407e183961bfaacf7 = MAKE_CODEOBJECT(module_filename_obj, 947, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryLShiftShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_2e8d5b7e70c842f835f5724785f66100 = MAKE_CODEOBJECT(module_filename_obj, 1102, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMatMultLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_92ab9ca6c3d62cc16d8e60249b83ab8c = MAKE_CODEOBJECT(module_filename_obj, 464, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMatMultShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_92c1d4b76e96a3fed296e8929c9652c0 = MAKE_CODEOBJECT(module_filename_obj, 361, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMatMultShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_80ca9f6e6aceaa2ee897274b7bf46769 = MAKE_CODEOBJECT(module_filename_obj, 764, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMatMultShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_de246dc45def92d44d802cefb7b0ae4b = MAKE_CODEOBJECT(module_filename_obj, 997, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMatMultShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_e4b9971ff2e44c8eb16719c5a7a83aca = MAKE_CODEOBJECT(module_filename_obj, 1053, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryModLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_ccebd776c0e9937695f958a434521a69 = MAKE_CODEOBJECT(module_filename_obj, 436, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryModShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_41ed3b8a61648a26b73c29af4c38df95 = MAKE_CODEOBJECT(module_filename_obj, 214, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryModShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_a03bf40e3eb8edc8605a7e62ecdd3212 = MAKE_CODEOBJECT(module_filename_obj, 673, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryModShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_499f52653ddcc4cf7b070bb86ee33cb5 = MAKE_CODEOBJECT(module_filename_obj, 927, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryModShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_c3da3b096edbebbddbe97561bde3609f = MAKE_CODEOBJECT(module_filename_obj, 1025, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMultLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_9b596b8c78a93eea39d745589a3900b6 = MAKE_CODEOBJECT(module_filename_obj, 420, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMultShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_9c35ab8056efcc1e1a9cbbeae45063e2 = MAKE_CODEOBJECT(module_filename_obj, 131, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMultShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_876a1e5fe9d10bccf76f38ef397f6295 = MAKE_CODEOBJECT(module_filename_obj, 621, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMultShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_cf4ec8f3fd82f729a4fed2653f5c444f = MAKE_CODEOBJECT(module_filename_obj, 887, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryMultShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_a11317166dcd24d5b94654425530a792 = MAKE_CODEOBJECT(module_filename_obj, 1039, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryOldDivLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_9f37cab9541cc450eb9c857ae61b29a1 = MAKE_CODEOBJECT(module_filename_obj, 428, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryOldDivShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_b1fc41a4b1b55db7c1dab679545abd03 = MAKE_CODEOBJECT(module_filename_obj, 172, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryOldDivShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_16f3995a02c0e9c79caad0e3968c3371 = MAKE_CODEOBJECT(module_filename_obj, 647, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryOldDivShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_99127d41fd2b0d07a06cc6547a8fe896 = MAKE_CODEOBJECT(module_filename_obj, 907, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryOldDivShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_816d37b6bd67981dc36715502904915c = MAKE_CODEOBJECT(module_filename_obj, 1060, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryPowLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_fcfb7c2b1f4bf8340de4834a4181b333 = MAKE_CODEOBJECT(module_filename_obj, 440, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryPowShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_cedcccd9f989b37336d1dea134c62a2f = MAKE_CODEOBJECT(module_filename_obj, 235, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryPowShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_9a1cd419ff5f7369aad29af0cbf529dc = MAKE_CODEOBJECT(module_filename_obj, 686, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryPowShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_1d78d973fdfa93709e28c3b9fb0259d5 = MAKE_CODEOBJECT(module_filename_obj, 937, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryPowShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_f9937f0aba6a561a1e4c7b53de1f19ef = MAKE_CODEOBJECT(module_filename_obj, 1074, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryRShiftLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_d40437d95659f9bf5a7905552e30aca2 = MAKE_CODEOBJECT(module_filename_obj, 448, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryRShiftShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_4d67752b63622030491af6955ba617a7 = MAKE_CODEOBJECT(module_filename_obj, 277, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryRShiftShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_3645059692b6a687f1cc693a5e2a7992 = MAKE_CODEOBJECT(module_filename_obj, 712, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryRShiftShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_89a8f8ac78edc545758a6558f344ee65 = MAKE_CODEOBJECT(module_filename_obj, 957, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryRShiftShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_2e3216b1267876dc850124ca8effd7c7 = MAKE_CODEOBJECT(module_filename_obj, 1018, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinarySubLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_92c12f700eb21f649d49d8acb8025fa1 = MAKE_CODEOBJECT(module_filename_obj, 416, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinarySubShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_378f783feea5c5ee55f1db0e91ea08cf = MAKE_CODEOBJECT(module_filename_obj, 111, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinarySubShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_04bb67784ec2ae1c58a2b767c0192b14 = MAKE_CODEOBJECT(module_filename_obj, 608, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinarySubShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_89c2e72108c717d051bc2f3380028c01 = MAKE_CODEOBJECT(module_filename_obj, 877, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinarySubShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_4e32de501717c1aec308daeedf0101e1 = MAKE_CODEOBJECT(module_filename_obj, 1046, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryTrueDivLShape, const_tuple_str_plain_self_str_plain_left_shape_tuple, 2, 0, 0);
    codeobj_f106a1a4d7fc00f78b1f75bd99972f11 = MAKE_CODEOBJECT(module_filename_obj, 432, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryTrueDivShape, const_tuple_str_plain_cls_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_5116cfd790e929ec7c172c3075615daf = MAKE_CODEOBJECT(module_filename_obj, 193, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryTrueDivShape, const_tuple_19e9cf822ef663d07339aa620df912db_tuple, 2, 0, 0);
    codeobj_8dd75cae359f2182c58f87b80393d24e = MAKE_CODEOBJECT(module_filename_obj, 660, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryTrueDivShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_b7c9f7c3ee3a065c315692d6d6b121d6 = MAKE_CODEOBJECT(module_filename_obj, 917, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getOperationBinaryTrueDivShape, const_tuple_str_plain_self_str_plain_right_shape_tuple, 2, 0, 0);
    codeobj_4a871f328f64bc7fb78c4391d9ae083c = MAKE_CODEOBJECT(module_filename_obj, 37, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getShapeIter, const_tuple_empty, 0, 0, 0);
    codeobj_7ca2522bf2581894b1beb8f845b610a2 = MAKE_CODEOBJECT(module_filename_obj, 548, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getShapeIter, const_tuple_empty, 0, 0, 0);
    codeobj_9aab73c7d497adf0ecd3b65c524655cc = MAKE_CODEOBJECT(module_filename_obj, 27, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getTypeName, const_tuple_empty, 0, 0, 0);
    codeobj_a7baa7c0f07185d9e8b484fee1877a94 = MAKE_CODEOBJECT(module_filename_obj, 483, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getTypeShape, const_tuple_empty, 0, 0, 0);
    codeobj_b584a9e3380c2590713c3f1fcc9529d0 = MAKE_CODEOBJECT(module_filename_obj, 499, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_getTypeShape, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_09ec202a6c4c061684a9757d62bf95f9 = MAKE_CODEOBJECT(module_filename_obj, 41, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeModule, const_tuple_empty, 0, 0, 0);
    codeobj_366bfe275f86f90b862b24584f82a814 = MAKE_CODEOBJECT(module_filename_obj, 1190, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeModule, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8925401d2d7666c1c1f7ff4e170d4927 = MAKE_CODEOBJECT(module_filename_obj, 57, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotAbs, const_tuple_empty, 0, 0, 0);
    codeobj_ccbdbf168ce9b29845afaf138f608d62 = MAKE_CODEOBJECT(module_filename_obj, 53, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotBool, const_tuple_empty, 0, 0, 0);
    codeobj_70f9e31a0a98ee3ca758fa8bf06d7ae9 = MAKE_CODEOBJECT(module_filename_obj, 520, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotBool, const_tuple_empty, 0, 0, 0);
    codeobj_cfa96613c609587ff5d56994103aa43b = MAKE_CODEOBJECT(module_filename_obj, 1160, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotBool, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8fd6898fba148c461cb27db922645580 = MAKE_CODEOBJECT(module_filename_obj, 45, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotBytes, const_tuple_empty, 0, 0, 0);
    codeobj_09b833cccf2012f65ae2f8fe2ea9e6f0 = MAKE_CODEOBJECT(module_filename_obj, 1187, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotBytes, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b8b3c14b8b2545d9f3a0de139c5cd3f4 = MAKE_CODEOBJECT(module_filename_obj, 49, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotComplex, const_tuple_empty, 0, 0, 0);
    codeobj_2f307bb43cefd698e5c636502311625a = MAKE_CODEOBJECT(module_filename_obj, 1184, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotComplex, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_b52bbf96acad86ac80f5dbb8709c292f = MAKE_CODEOBJECT(module_filename_obj, 85, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotContains, const_tuple_empty, 0, 0, 0);
    codeobj_cd783a51523183bd96d40e52e2be64d3 = MAKE_CODEOBJECT(module_filename_obj, 552, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotContains, const_tuple_empty, 0, 0, 0);
    codeobj_90e4ebaa842519314147c2eda45dd7ae = MAKE_CODEOBJECT(module_filename_obj, 1172, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotContains, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2f4520eafc261c3a8b579825550a022e = MAKE_CODEOBJECT(module_filename_obj, 73, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotFloat, const_tuple_empty, 0, 0, 0);
    codeobj_0e77d4d63e616eb1a3bc028bbd180e01 = MAKE_CODEOBJECT(module_filename_obj, 536, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotFloat, const_tuple_empty, 0, 0, 0);
    codeobj_3c58c0b1373f4cdeab30cf41740a1706 = MAKE_CODEOBJECT(module_filename_obj, 1181, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotFloat, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ceb5972e74036bff8934f4bde148658d = MAKE_CODEOBJECT(module_filename_obj, 65, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotInt, const_tuple_empty, 0, 0, 0);
    codeobj_8a7f0f6cb1b6d1a79102c587416607e0 = MAKE_CODEOBJECT(module_filename_obj, 528, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotInt, const_tuple_empty, 0, 0, 0);
    codeobj_261904682a894c605dc4a31d2ba13d77 = MAKE_CODEOBJECT(module_filename_obj, 1175, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotInt, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_e4ffd958de903bd2c2a7941492898be6 = MAKE_CODEOBJECT(module_filename_obj, 77, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotIter, const_tuple_empty, 0, 0, 0);
    codeobj_954260a5d80350d35448265904c2ece9 = MAKE_CODEOBJECT(module_filename_obj, 540, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotIter, const_tuple_empty, 0, 0, 0);
    codeobj_ff4571568d88d9e77d9e1b964de0b0cf = MAKE_CODEOBJECT(module_filename_obj, 1166, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotIter, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_f7a94311b4b68316590dc83f56d0fdfa = MAKE_CODEOBJECT(module_filename_obj, 61, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLen, const_tuple_empty, 0, 0, 0);
    codeobj_c887985073edec097f150e9c98e0cfe9 = MAKE_CODEOBJECT(module_filename_obj, 524, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLen, const_tuple_empty, 0, 0, 0);
    codeobj_7375bd3b7c5c494c7b6e41ec225ff82d = MAKE_CODEOBJECT(module_filename_obj, 476, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLen, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_e1ea14b18ebff6d3e87dbd7f9e59473c = MAKE_CODEOBJECT(module_filename_obj, 506, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLen, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_c215eed7076c01dc4a3d37b768a1c271 = MAKE_CODEOBJECT(module_filename_obj, 1163, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLen, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2002d456b69ea529e08aed94c4b75e71 = MAKE_CODEOBJECT(module_filename_obj, 69, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLong, const_tuple_empty, 0, 0, 0);
    codeobj_b41ca985d47eaf533323004d01c2f936 = MAKE_CODEOBJECT(module_filename_obj, 532, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLong, const_tuple_empty, 0, 0, 0);
    codeobj_a347f3f55a405604ff7de8cac0d96fbd = MAKE_CODEOBJECT(module_filename_obj, 1178, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotLong, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_39c42cee787eff76aedb26ca2eb2746f = MAKE_CODEOBJECT(module_filename_obj, 81, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotNext, const_tuple_empty, 0, 0, 0);
    codeobj_d162cf51f4337d7c44c85056e237dcd9 = MAKE_CODEOBJECT(module_filename_obj, 544, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotNext, const_tuple_empty, 0, 0, 0);
    codeobj_6ba11ba0e23039b19e0dc773c8a602ea = MAKE_CODEOBJECT(module_filename_obj, 1169, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_hasShapeSlotNext, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_70252d84a66c9c64934c4c4eed81830e = MAKE_CODEOBJECT(module_filename_obj, 502, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_isConstant, const_tuple_empty, 0, 0, 0);
}

// The module function declarations.
static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_108_getOperationBinaryAddLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_109_getOperationBinarySubLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_10_hasShapeSlotInt();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_110_getOperationBinaryMultLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_111_getOperationBinaryFloorDivLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_112_getOperationBinaryOldDivLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_113_getOperationBinaryTrueDivLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_114_getOperationBinaryModLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_115_getOperationBinaryPowLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_116_getOperationBinaryLShiftLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_117_getOperationBinaryRShiftLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_118_getOperationBinaryBitOrLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_119_getOperationBinaryBitAndLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_11_hasShapeSlotLong();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_120_getOperationBinaryBitXorLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_121_getOperationBinaryMatMultLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_123_getComparisonLtLShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_124_getComparisonLteShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_125_getComparisonGtShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_126_getComparisonGteShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_127_getComparisonEqShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_128_getComparisonNeqShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_12_hasShapeSlotFloat();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_13_hasShapeSlotIter();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_14_hasShapeSlotNext();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_15_hasShapeSlotContains();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_1_getTypeName();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_4_hasShapeModule();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_52_hasShapeSlotLen();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_54___init__();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_55_getTypeShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_57_hasShapeSlotLen();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_58___init__();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_59_hasShapeSlotBool();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_5_hasShapeSlotBytes();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_60_hasShapeSlotLen();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_61_hasShapeSlotInt();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_62_hasShapeSlotLong();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_63_hasShapeSlotFloat();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_68___init__();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_6_hasShapeSlotComplex();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_7_hasShapeSlotBool();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_86_getComparisonLteShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_87_getComparisonGtShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_88_getComparisonGteShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_89_getComparisonEqShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_8_hasShapeSlotAbs();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_90_getComparisonNeqShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_91___init__();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape$$$function_1_lambda();


static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_9_hasShapeSlotLen();


// The module function definitions.
static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_5c600498451b8d72313d3e673c48c257;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5c600498451b8d72313d3e673c48c257 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5c600498451b8d72313d3e673c48c257, codeobj_5c600498451b8d72313d3e673c48c257, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, 0);
    frame_5c600498451b8d72313d3e673c48c257 = cache_frame_5c600498451b8d72313d3e673c48c257;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5c600498451b8d72313d3e673c48c257);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5c600498451b8d72313d3e673c48c257) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_CTypePyObjectPtr);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_CTypePyObjectPtr);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 59194 ], 38, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 35;

            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c600498451b8d72313d3e673c48c257);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c600498451b8d72313d3e673c48c257);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c600498451b8d72313d3e673c48c257);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5c600498451b8d72313d3e673c48c257, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5c600498451b8d72313d3e673c48c257->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5c600498451b8d72313d3e673c48c257, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5c600498451b8d72313d3e673c48c257,
        type_description_1
    );


    // Release cached frame.
    if (frame_5c600498451b8d72313d3e673c48c257 == cache_frame_5c600498451b8d72313d3e673c48c257) {
        Py_DECREF(frame_5c600498451b8d72313d3e673c48c257);
    }
    cache_frame_5c600498451b8d72313d3e673c48c257 = NULL;

    assertFrameObject(frame_5c600498451b8d72313d3e673c48c257);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_4a871f328f64bc7fb78c4391d9ae083c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4a871f328f64bc7fb78c4391d9ae083c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4a871f328f64bc7fb78c4391d9ae083c, codeobj_4a871f328f64bc7fb78c4391d9ae083c, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, 0);
    frame_4a871f328f64bc7fb78c4391d9ae083c = cache_frame_4a871f328f64bc7fb78c4391d9ae083c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4a871f328f64bc7fb78c4391d9ae083c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4a871f328f64bc7fb78c4391d9ae083c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 39;

            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4a871f328f64bc7fb78c4391d9ae083c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4a871f328f64bc7fb78c4391d9ae083c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4a871f328f64bc7fb78c4391d9ae083c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4a871f328f64bc7fb78c4391d9ae083c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4a871f328f64bc7fb78c4391d9ae083c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4a871f328f64bc7fb78c4391d9ae083c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4a871f328f64bc7fb78c4391d9ae083c,
        type_description_1
    );


    // Release cached frame.
    if (frame_4a871f328f64bc7fb78c4391d9ae083c == cache_frame_4a871f328f64bc7fb78c4391d9ae083c) {
        Py_DECREF(frame_4a871f328f64bc7fb78c4391d9ae083c);
    }
    cache_frame_4a871f328f64bc7fb78c4391d9ae083c = NULL;

    assertFrameObject(frame_4a871f328f64bc7fb78c4391d9ae083c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_678bd036360d1eb3a05a8cdfaa296054;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_678bd036360d1eb3a05a8cdfaa296054 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_678bd036360d1eb3a05a8cdfaa296054, codeobj_678bd036360d1eb3a05a8cdfaa296054, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_678bd036360d1eb3a05a8cdfaa296054 = cache_frame_678bd036360d1eb3a05a8cdfaa296054;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_678bd036360d1eb3a05a8cdfaa296054);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_678bd036360d1eb3a05a8cdfaa296054) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_add_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 93;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_678bd036360d1eb3a05a8cdfaa296054->m_frame.f_lineno = 93;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 93;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 99;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_678bd036360d1eb3a05a8cdfaa296054->m_frame.f_lineno = 100;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryAddLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 100;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 102;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 103;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_onMissingOperation);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_onMissingOperation);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78821 ], 40, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 105;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_4;
            tmp_args_element_name_3 = const_str_plain_Add;
            CHECK_OBJECT(par_cls);
            tmp_args_element_name_4 = par_cls;
            CHECK_OBJECT(par_right_shape);
            tmp_args_element_name_5 = par_right_shape;
            frame_678bd036360d1eb3a05a8cdfaa296054->m_frame.f_lineno = 105;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 105;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_mvar_value_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 107;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_5;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_678bd036360d1eb3a05a8cdfaa296054);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_678bd036360d1eb3a05a8cdfaa296054);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_678bd036360d1eb3a05a8cdfaa296054);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_678bd036360d1eb3a05a8cdfaa296054, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_678bd036360d1eb3a05a8cdfaa296054->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_678bd036360d1eb3a05a8cdfaa296054, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_678bd036360d1eb3a05a8cdfaa296054,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_678bd036360d1eb3a05a8cdfaa296054 == cache_frame_678bd036360d1eb3a05a8cdfaa296054) {
        Py_DECREF(frame_678bd036360d1eb3a05a8cdfaa296054);
    }
    cache_frame_678bd036360d1eb3a05a8cdfaa296054 = NULL;

    assertFrameObject(frame_678bd036360d1eb3a05a8cdfaa296054);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_378f783feea5c5ee55f1db0e91ea08cf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_378f783feea5c5ee55f1db0e91ea08cf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_378f783feea5c5ee55f1db0e91ea08cf, codeobj_378f783feea5c5ee55f1db0e91ea08cf, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_378f783feea5c5ee55f1db0e91ea08cf = cache_frame_378f783feea5c5ee55f1db0e91ea08cf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_378f783feea5c5ee55f1db0e91ea08cf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_378f783feea5c5ee55f1db0e91ea08cf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_sub_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_378f783feea5c5ee55f1db0e91ea08cf->m_frame.f_lineno = 113;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 113;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 119;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_378f783feea5c5ee55f1db0e91ea08cf->m_frame.f_lineno = 120;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinarySubLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 120;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 122;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 123;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_onMissingOperation);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_onMissingOperation);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78821 ], 40, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 125;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_4;
            tmp_args_element_name_3 = const_str_plain_Sub;
            CHECK_OBJECT(par_cls);
            tmp_args_element_name_4 = par_cls;
            CHECK_OBJECT(par_right_shape);
            tmp_args_element_name_5 = par_right_shape;
            frame_378f783feea5c5ee55f1db0e91ea08cf->m_frame.f_lineno = 125;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 125;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_mvar_value_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 127;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_5;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_378f783feea5c5ee55f1db0e91ea08cf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_378f783feea5c5ee55f1db0e91ea08cf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_378f783feea5c5ee55f1db0e91ea08cf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_378f783feea5c5ee55f1db0e91ea08cf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_378f783feea5c5ee55f1db0e91ea08cf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_378f783feea5c5ee55f1db0e91ea08cf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_378f783feea5c5ee55f1db0e91ea08cf,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_378f783feea5c5ee55f1db0e91ea08cf == cache_frame_378f783feea5c5ee55f1db0e91ea08cf) {
        Py_DECREF(frame_378f783feea5c5ee55f1db0e91ea08cf);
    }
    cache_frame_378f783feea5c5ee55f1db0e91ea08cf = NULL;

    assertFrameObject(frame_378f783feea5c5ee55f1db0e91ea08cf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_9c35ab8056efcc1e1a9cbbeae45063e2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9c35ab8056efcc1e1a9cbbeae45063e2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_9c35ab8056efcc1e1a9cbbeae45063e2, codeobj_9c35ab8056efcc1e1a9cbbeae45063e2, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_9c35ab8056efcc1e1a9cbbeae45063e2 = cache_frame_9c35ab8056efcc1e1a9cbbeae45063e2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9c35ab8056efcc1e1a9cbbeae45063e2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9c35ab8056efcc1e1a9cbbeae45063e2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_mul_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 133;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_9c35ab8056efcc1e1a9cbbeae45063e2->m_frame.f_lineno = 133;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 133;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 139;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_9c35ab8056efcc1e1a9cbbeae45063e2->m_frame.f_lineno = 140;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryMultLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 140;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 142;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 143;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_called_name_1;
            PyObject *tmp_mvar_value_4;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_onMissingOperation);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_onMissingOperation);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78821 ], 40, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 145;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_1 = tmp_mvar_value_4;
            tmp_args_element_name_3 = const_str_plain_Mult;
            CHECK_OBJECT(par_cls);
            tmp_args_element_name_4 = par_cls;
            CHECK_OBJECT(par_right_shape);
            tmp_args_element_name_5 = par_right_shape;
            frame_9c35ab8056efcc1e1a9cbbeae45063e2->m_frame.f_lineno = 145;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 145;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_mvar_value_5;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 147;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_5;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9c35ab8056efcc1e1a9cbbeae45063e2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9c35ab8056efcc1e1a9cbbeae45063e2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9c35ab8056efcc1e1a9cbbeae45063e2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9c35ab8056efcc1e1a9cbbeae45063e2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9c35ab8056efcc1e1a9cbbeae45063e2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9c35ab8056efcc1e1a9cbbeae45063e2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9c35ab8056efcc1e1a9cbbeae45063e2,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_9c35ab8056efcc1e1a9cbbeae45063e2 == cache_frame_9c35ab8056efcc1e1a9cbbeae45063e2) {
        Py_DECREF(frame_9c35ab8056efcc1e1a9cbbeae45063e2);
    }
    cache_frame_9c35ab8056efcc1e1a9cbbeae45063e2 = NULL;

    assertFrameObject(frame_9c35ab8056efcc1e1a9cbbeae45063e2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_0c1fd16734cb23f268c3b167c098d5b8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0c1fd16734cb23f268c3b167c098d5b8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_0c1fd16734cb23f268c3b167c098d5b8, codeobj_0c1fd16734cb23f268c3b167c098d5b8, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_0c1fd16734cb23f268c3b167c098d5b8 = cache_frame_0c1fd16734cb23f268c3b167c098d5b8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0c1fd16734cb23f268c3b167c098d5b8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0c1fd16734cb23f268c3b167c098d5b8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_floordiv_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 153;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_0c1fd16734cb23f268c3b167c098d5b8->m_frame.f_lineno = 153;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 153;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 159;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_0c1fd16734cb23f268c3b167c098d5b8->m_frame.f_lineno = 160;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryFloorDivLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 160;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 162;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 163;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 168;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c1fd16734cb23f268c3b167c098d5b8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c1fd16734cb23f268c3b167c098d5b8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0c1fd16734cb23f268c3b167c098d5b8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0c1fd16734cb23f268c3b167c098d5b8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0c1fd16734cb23f268c3b167c098d5b8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0c1fd16734cb23f268c3b167c098d5b8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0c1fd16734cb23f268c3b167c098d5b8,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_0c1fd16734cb23f268c3b167c098d5b8 == cache_frame_0c1fd16734cb23f268c3b167c098d5b8) {
        Py_DECREF(frame_0c1fd16734cb23f268c3b167c098d5b8);
    }
    cache_frame_0c1fd16734cb23f268c3b167c098d5b8 = NULL;

    assertFrameObject(frame_0c1fd16734cb23f268c3b167c098d5b8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_b1fc41a4b1b55db7c1dab679545abd03;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b1fc41a4b1b55db7c1dab679545abd03 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_b1fc41a4b1b55db7c1dab679545abd03, codeobj_b1fc41a4b1b55db7c1dab679545abd03, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_b1fc41a4b1b55db7c1dab679545abd03 = cache_frame_b1fc41a4b1b55db7c1dab679545abd03;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b1fc41a4b1b55db7c1dab679545abd03);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b1fc41a4b1b55db7c1dab679545abd03) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_olddiv_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 174;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_b1fc41a4b1b55db7c1dab679545abd03->m_frame.f_lineno = 174;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 174;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 180;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_b1fc41a4b1b55db7c1dab679545abd03->m_frame.f_lineno = 181;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryOldDivLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 181;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 183;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 184;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 189;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1fc41a4b1b55db7c1dab679545abd03);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1fc41a4b1b55db7c1dab679545abd03);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1fc41a4b1b55db7c1dab679545abd03);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b1fc41a4b1b55db7c1dab679545abd03, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b1fc41a4b1b55db7c1dab679545abd03->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b1fc41a4b1b55db7c1dab679545abd03, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b1fc41a4b1b55db7c1dab679545abd03,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_b1fc41a4b1b55db7c1dab679545abd03 == cache_frame_b1fc41a4b1b55db7c1dab679545abd03) {
        Py_DECREF(frame_b1fc41a4b1b55db7c1dab679545abd03);
    }
    cache_frame_b1fc41a4b1b55db7c1dab679545abd03 = NULL;

    assertFrameObject(frame_b1fc41a4b1b55db7c1dab679545abd03);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_5116cfd790e929ec7c172c3075615daf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5116cfd790e929ec7c172c3075615daf = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_5116cfd790e929ec7c172c3075615daf, codeobj_5116cfd790e929ec7c172c3075615daf, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_5116cfd790e929ec7c172c3075615daf = cache_frame_5116cfd790e929ec7c172c3075615daf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5116cfd790e929ec7c172c3075615daf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5116cfd790e929ec7c172c3075615daf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_truediv_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 195;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_5116cfd790e929ec7c172c3075615daf->m_frame.f_lineno = 195;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 195;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 201;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_5116cfd790e929ec7c172c3075615daf->m_frame.f_lineno = 202;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryTrueDivLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 202;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 204;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 205;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 210;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5116cfd790e929ec7c172c3075615daf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5116cfd790e929ec7c172c3075615daf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5116cfd790e929ec7c172c3075615daf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5116cfd790e929ec7c172c3075615daf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5116cfd790e929ec7c172c3075615daf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5116cfd790e929ec7c172c3075615daf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5116cfd790e929ec7c172c3075615daf,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_5116cfd790e929ec7c172c3075615daf == cache_frame_5116cfd790e929ec7c172c3075615daf) {
        Py_DECREF(frame_5116cfd790e929ec7c172c3075615daf);
    }
    cache_frame_5116cfd790e929ec7c172c3075615daf = NULL;

    assertFrameObject(frame_5116cfd790e929ec7c172c3075615daf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_41ed3b8a61648a26b73c29af4c38df95;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_41ed3b8a61648a26b73c29af4c38df95 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_41ed3b8a61648a26b73c29af4c38df95, codeobj_41ed3b8a61648a26b73c29af4c38df95, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_41ed3b8a61648a26b73c29af4c38df95 = cache_frame_41ed3b8a61648a26b73c29af4c38df95;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_41ed3b8a61648a26b73c29af4c38df95);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_41ed3b8a61648a26b73c29af4c38df95) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_mod_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 216;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_41ed3b8a61648a26b73c29af4c38df95->m_frame.f_lineno = 216;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 216;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 222;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_41ed3b8a61648a26b73c29af4c38df95->m_frame.f_lineno = 223;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryModLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 223;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 225;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 226;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 231;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_41ed3b8a61648a26b73c29af4c38df95);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_41ed3b8a61648a26b73c29af4c38df95);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_41ed3b8a61648a26b73c29af4c38df95);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_41ed3b8a61648a26b73c29af4c38df95, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_41ed3b8a61648a26b73c29af4c38df95->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_41ed3b8a61648a26b73c29af4c38df95, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_41ed3b8a61648a26b73c29af4c38df95,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_41ed3b8a61648a26b73c29af4c38df95 == cache_frame_41ed3b8a61648a26b73c29af4c38df95) {
        Py_DECREF(frame_41ed3b8a61648a26b73c29af4c38df95);
    }
    cache_frame_41ed3b8a61648a26b73c29af4c38df95 = NULL;

    assertFrameObject(frame_41ed3b8a61648a26b73c29af4c38df95);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_cedcccd9f989b37336d1dea134c62a2f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cedcccd9f989b37336d1dea134c62a2f = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_cedcccd9f989b37336d1dea134c62a2f, codeobj_cedcccd9f989b37336d1dea134c62a2f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_cedcccd9f989b37336d1dea134c62a2f = cache_frame_cedcccd9f989b37336d1dea134c62a2f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cedcccd9f989b37336d1dea134c62a2f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cedcccd9f989b37336d1dea134c62a2f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_pow_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 237;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_cedcccd9f989b37336d1dea134c62a2f->m_frame.f_lineno = 237;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 237;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 243;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_cedcccd9f989b37336d1dea134c62a2f->m_frame.f_lineno = 244;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryPowLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 244;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 246;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 247;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 252;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cedcccd9f989b37336d1dea134c62a2f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cedcccd9f989b37336d1dea134c62a2f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cedcccd9f989b37336d1dea134c62a2f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cedcccd9f989b37336d1dea134c62a2f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cedcccd9f989b37336d1dea134c62a2f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cedcccd9f989b37336d1dea134c62a2f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cedcccd9f989b37336d1dea134c62a2f,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_cedcccd9f989b37336d1dea134c62a2f == cache_frame_cedcccd9f989b37336d1dea134c62a2f) {
        Py_DECREF(frame_cedcccd9f989b37336d1dea134c62a2f);
    }
    cache_frame_cedcccd9f989b37336d1dea134c62a2f = NULL;

    assertFrameObject(frame_cedcccd9f989b37336d1dea134c62a2f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_16ae7053c6540f737e1f47f13348d563;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_16ae7053c6540f737e1f47f13348d563 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_16ae7053c6540f737e1f47f13348d563, codeobj_16ae7053c6540f737e1f47f13348d563, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_16ae7053c6540f737e1f47f13348d563 = cache_frame_16ae7053c6540f737e1f47f13348d563;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_16ae7053c6540f737e1f47f13348d563);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_16ae7053c6540f737e1f47f13348d563) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_lshift_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 258;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_16ae7053c6540f737e1f47f13348d563->m_frame.f_lineno = 258;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 258;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 264;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_16ae7053c6540f737e1f47f13348d563->m_frame.f_lineno = 265;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryLShiftLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 265;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 267;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 268;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 273;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_16ae7053c6540f737e1f47f13348d563);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_16ae7053c6540f737e1f47f13348d563);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_16ae7053c6540f737e1f47f13348d563);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_16ae7053c6540f737e1f47f13348d563, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_16ae7053c6540f737e1f47f13348d563->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_16ae7053c6540f737e1f47f13348d563, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_16ae7053c6540f737e1f47f13348d563,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_16ae7053c6540f737e1f47f13348d563 == cache_frame_16ae7053c6540f737e1f47f13348d563) {
        Py_DECREF(frame_16ae7053c6540f737e1f47f13348d563);
    }
    cache_frame_16ae7053c6540f737e1f47f13348d563 = NULL;

    assertFrameObject(frame_16ae7053c6540f737e1f47f13348d563);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_4d67752b63622030491af6955ba617a7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_4d67752b63622030491af6955ba617a7 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4d67752b63622030491af6955ba617a7, codeobj_4d67752b63622030491af6955ba617a7, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4d67752b63622030491af6955ba617a7 = cache_frame_4d67752b63622030491af6955ba617a7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4d67752b63622030491af6955ba617a7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4d67752b63622030491af6955ba617a7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_rshift_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 279;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_4d67752b63622030491af6955ba617a7->m_frame.f_lineno = 279;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 279;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 285;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_4d67752b63622030491af6955ba617a7->m_frame.f_lineno = 286;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryRShiftLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 286;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 288;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 289;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 294;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4d67752b63622030491af6955ba617a7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4d67752b63622030491af6955ba617a7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4d67752b63622030491af6955ba617a7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4d67752b63622030491af6955ba617a7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4d67752b63622030491af6955ba617a7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4d67752b63622030491af6955ba617a7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4d67752b63622030491af6955ba617a7,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_4d67752b63622030491af6955ba617a7 == cache_frame_4d67752b63622030491af6955ba617a7) {
        Py_DECREF(frame_4d67752b63622030491af6955ba617a7);
    }
    cache_frame_4d67752b63622030491af6955ba617a7 = NULL;

    assertFrameObject(frame_4d67752b63622030491af6955ba617a7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_c18b64232e6fc0478d21a489ab050c32;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c18b64232e6fc0478d21a489ab050c32 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_c18b64232e6fc0478d21a489ab050c32, codeobj_c18b64232e6fc0478d21a489ab050c32, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_c18b64232e6fc0478d21a489ab050c32 = cache_frame_c18b64232e6fc0478d21a489ab050c32;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c18b64232e6fc0478d21a489ab050c32);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c18b64232e6fc0478d21a489ab050c32) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_bitor_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 300;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_c18b64232e6fc0478d21a489ab050c32->m_frame.f_lineno = 300;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 300;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 306;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_c18b64232e6fc0478d21a489ab050c32->m_frame.f_lineno = 307;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryBitOrLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 307;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 309;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 310;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 315;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c18b64232e6fc0478d21a489ab050c32);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c18b64232e6fc0478d21a489ab050c32);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c18b64232e6fc0478d21a489ab050c32);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c18b64232e6fc0478d21a489ab050c32, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c18b64232e6fc0478d21a489ab050c32->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c18b64232e6fc0478d21a489ab050c32, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c18b64232e6fc0478d21a489ab050c32,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_c18b64232e6fc0478d21a489ab050c32 == cache_frame_c18b64232e6fc0478d21a489ab050c32) {
        Py_DECREF(frame_c18b64232e6fc0478d21a489ab050c32);
    }
    cache_frame_c18b64232e6fc0478d21a489ab050c32 = NULL;

    assertFrameObject(frame_c18b64232e6fc0478d21a489ab050c32);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_de429e1ffc0386afb873c85570f8584a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_de429e1ffc0386afb873c85570f8584a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_de429e1ffc0386afb873c85570f8584a, codeobj_de429e1ffc0386afb873c85570f8584a, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_de429e1ffc0386afb873c85570f8584a = cache_frame_de429e1ffc0386afb873c85570f8584a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_de429e1ffc0386afb873c85570f8584a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_de429e1ffc0386afb873c85570f8584a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_bitand_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 321;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_de429e1ffc0386afb873c85570f8584a->m_frame.f_lineno = 321;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 321;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 327;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_de429e1ffc0386afb873c85570f8584a->m_frame.f_lineno = 328;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryBitAndLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 328;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 330;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 331;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 336;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de429e1ffc0386afb873c85570f8584a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_de429e1ffc0386afb873c85570f8584a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de429e1ffc0386afb873c85570f8584a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_de429e1ffc0386afb873c85570f8584a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_de429e1ffc0386afb873c85570f8584a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_de429e1ffc0386afb873c85570f8584a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_de429e1ffc0386afb873c85570f8584a,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_de429e1ffc0386afb873c85570f8584a == cache_frame_de429e1ffc0386afb873c85570f8584a) {
        Py_DECREF(frame_de429e1ffc0386afb873c85570f8584a);
    }
    cache_frame_de429e1ffc0386afb873c85570f8584a = NULL;

    assertFrameObject(frame_de429e1ffc0386afb873c85570f8584a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_9b28af0540046a6af23498002ebb11c4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9b28af0540046a6af23498002ebb11c4 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_9b28af0540046a6af23498002ebb11c4, codeobj_9b28af0540046a6af23498002ebb11c4, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_9b28af0540046a6af23498002ebb11c4 = cache_frame_9b28af0540046a6af23498002ebb11c4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9b28af0540046a6af23498002ebb11c4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9b28af0540046a6af23498002ebb11c4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_bitxor_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 342;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_9b28af0540046a6af23498002ebb11c4->m_frame.f_lineno = 342;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 342;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 348;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_9b28af0540046a6af23498002ebb11c4->m_frame.f_lineno = 349;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryBitXorLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 349;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 351;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 352;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 357;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b28af0540046a6af23498002ebb11c4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b28af0540046a6af23498002ebb11c4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b28af0540046a6af23498002ebb11c4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9b28af0540046a6af23498002ebb11c4, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9b28af0540046a6af23498002ebb11c4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9b28af0540046a6af23498002ebb11c4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b28af0540046a6af23498002ebb11c4,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_9b28af0540046a6af23498002ebb11c4 == cache_frame_9b28af0540046a6af23498002ebb11c4) {
        Py_DECREF(frame_9b28af0540046a6af23498002ebb11c4);
    }
    cache_frame_9b28af0540046a6af23498002ebb11c4 = NULL;

    assertFrameObject(frame_9b28af0540046a6af23498002ebb11c4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_right_shape_type = NULL;
    struct Nuitka_FrameObject *frame_92c1d4b76e96a3fed296e8929c9652c0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_92c1d4b76e96a3fed296e8929c9652c0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_92c1d4b76e96a3fed296e8929c9652c0, codeobj_92c1d4b76e96a3fed296e8929c9652c0, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_92c1d4b76e96a3fed296e8929c9652c0 = cache_frame_92c1d4b76e96a3fed296e8929c9652c0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_92c1d4b76e96a3fed296e8929c9652c0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_92c1d4b76e96a3fed296e8929c9652c0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_source_name_1 = par_cls;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_matmult_shapes);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 363;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_92c1d4b76e96a3fed296e8929c9652c0->m_frame.f_lineno = 363;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_get, call_args);
        }

        Py_DECREF(tmp_called_instance_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 363;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_result);
        tmp_compexpr_left_1 = var_result;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(var_result);
        tmp_return_value = var_result;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_type_arg_1;
            CHECK_OBJECT(par_right_shape);
            tmp_type_arg_1 = par_right_shape;
            tmp_assign_source_2 = BUILTIN_TYPE1(tmp_type_arg_1);
            assert(!(tmp_assign_source_2 == NULL));
            assert(var_right_shape_type == NULL);
            var_right_shape_type = tmp_assign_source_2;
        }
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            PyObject *tmp_mvar_value_1;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_2 = var_right_shape_type;
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_1 == NULL)) {
                tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_1 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 369;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_2 = tmp_mvar_value_1;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                PyObject *tmp_called_instance_2;
                PyObject *tmp_args_element_name_2;
                CHECK_OBJECT(par_right_shape);
                tmp_called_instance_2 = par_right_shape;
                CHECK_OBJECT(par_cls);
                tmp_args_element_name_2 = par_cls;
                frame_92c1d4b76e96a3fed296e8929c9652c0->m_frame.f_lineno = 370;
                {
                    PyObject *call_args[] = {tmp_args_element_name_2};
                    tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_getOperationBinaryBitMatMultLShape, call_args);
                }

                if (tmp_return_value == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 370;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }
                goto frame_return_exit_1;
            }
            branch_no_2:;
        }
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_3;
            PyObject *tmp_compexpr_right_3;
            PyObject *tmp_mvar_value_2;
            CHECK_OBJECT(var_right_shape_type);
            tmp_compexpr_left_3 = var_right_shape_type;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 372;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_right_3 = tmp_mvar_value_2;
            tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 373;
                    type_description_1 = "oooo";
                    goto frame_exception_exit_1;
                }

                tmp_return_value = tmp_mvar_value_3;
                Py_INCREF(tmp_return_value);
                goto frame_return_exit_1;
            }
            branch_no_3:;
        }
        {
            PyObject *tmp_mvar_value_4;
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_4 == NULL)) {
                tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_4 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 378;
                type_description_1 = "oooo";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_4;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c1d4b76e96a3fed296e8929c9652c0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c1d4b76e96a3fed296e8929c9652c0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c1d4b76e96a3fed296e8929c9652c0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_92c1d4b76e96a3fed296e8929c9652c0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_92c1d4b76e96a3fed296e8929c9652c0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_92c1d4b76e96a3fed296e8929c9652c0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_92c1d4b76e96a3fed296e8929c9652c0,
        type_description_1,
        par_cls,
        par_right_shape,
        var_result,
        var_right_shape_type
    );


    // Release cached frame.
    if (frame_92c1d4b76e96a3fed296e8929c9652c0 == cache_frame_92c1d4b76e96a3fed296e8929c9652c0) {
        Py_DECREF(frame_92c1d4b76e96a3fed296e8929c9652c0);
    }
    cache_frame_92c1d4b76e96a3fed296e8929c9652c0 = NULL;

    assertFrameObject(frame_92c1d4b76e96a3fed296e8929c9652c0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_right_shape_type);
    var_right_shape_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_5366e9a5a3a3a2940f454d9212513daa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5366e9a5a3a3a2940f454d9212513daa = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5366e9a5a3a3a2940f454d9212513daa, codeobj_5366e9a5a3a3a2940f454d9212513daa, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_5366e9a5a3a3a2940f454d9212513daa = cache_frame_5366e9a5a3a3a2940f454d9212513daa;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5366e9a5a3a3a2940f454d9212513daa);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5366e9a5a3a3a2940f454d9212513daa) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_onMissingOperation);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_onMissingOperation);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78821 ], 40, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 382;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_1 = tmp_mvar_value_1;
        tmp_args_element_name_1 = const_str_plain_Lt;
        CHECK_OBJECT(par_cls);
        tmp_args_element_name_2 = par_cls;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_3 = par_right_shape;
        frame_5366e9a5a3a3a2940f454d9212513daa->m_frame.f_lineno = 382;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_1, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 382;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 384;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_2;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5366e9a5a3a3a2940f454d9212513daa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5366e9a5a3a3a2940f454d9212513daa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5366e9a5a3a3a2940f454d9212513daa);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5366e9a5a3a3a2940f454d9212513daa, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5366e9a5a3a3a2940f454d9212513daa->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5366e9a5a3a3a2940f454d9212513daa, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5366e9a5a3a3a2940f454d9212513daa,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_5366e9a5a3a3a2940f454d9212513daa == cache_frame_5366e9a5a3a3a2940f454d9212513daa) {
        Py_DECREF(frame_5366e9a5a3a3a2940f454d9212513daa);
    }
    cache_frame_5366e9a5a3a3a2940f454d9212513daa = NULL;

    assertFrameObject(frame_5366e9a5a3a3a2940f454d9212513daa);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_34497d9734a343c6e4c38b4f0585ce64;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_34497d9734a343c6e4c38b4f0585ce64 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_34497d9734a343c6e4c38b4f0585ce64, codeobj_34497d9734a343c6e4c38b4f0585ce64, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_34497d9734a343c6e4c38b4f0585ce64 = cache_frame_34497d9734a343c6e4c38b4f0585ce64;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_34497d9734a343c6e4c38b4f0585ce64);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_34497d9734a343c6e4c38b4f0585ce64) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_34497d9734a343c6e4c38b4f0585ce64->m_frame.f_lineno = 388;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 388;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_34497d9734a343c6e4c38b4f0585ce64);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_34497d9734a343c6e4c38b4f0585ce64);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_34497d9734a343c6e4c38b4f0585ce64);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_34497d9734a343c6e4c38b4f0585ce64, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_34497d9734a343c6e4c38b4f0585ce64->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_34497d9734a343c6e4c38b4f0585ce64, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_34497d9734a343c6e4c38b4f0585ce64,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_34497d9734a343c6e4c38b4f0585ce64 == cache_frame_34497d9734a343c6e4c38b4f0585ce64) {
        Py_DECREF(frame_34497d9734a343c6e4c38b4f0585ce64);
    }
    cache_frame_34497d9734a343c6e4c38b4f0585ce64 = NULL;

    assertFrameObject(frame_34497d9734a343c6e4c38b4f0585ce64);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_6390b7f7acb0d560e13329b28fdb6941;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6390b7f7acb0d560e13329b28fdb6941 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6390b7f7acb0d560e13329b28fdb6941, codeobj_6390b7f7acb0d560e13329b28fdb6941, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_6390b7f7acb0d560e13329b28fdb6941 = cache_frame_6390b7f7acb0d560e13329b28fdb6941;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6390b7f7acb0d560e13329b28fdb6941);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6390b7f7acb0d560e13329b28fdb6941) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_6390b7f7acb0d560e13329b28fdb6941->m_frame.f_lineno = 392;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 392;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6390b7f7acb0d560e13329b28fdb6941);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6390b7f7acb0d560e13329b28fdb6941);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6390b7f7acb0d560e13329b28fdb6941);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6390b7f7acb0d560e13329b28fdb6941, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6390b7f7acb0d560e13329b28fdb6941->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6390b7f7acb0d560e13329b28fdb6941, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6390b7f7acb0d560e13329b28fdb6941,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_6390b7f7acb0d560e13329b28fdb6941 == cache_frame_6390b7f7acb0d560e13329b28fdb6941) {
        Py_DECREF(frame_6390b7f7acb0d560e13329b28fdb6941);
    }
    cache_frame_6390b7f7acb0d560e13329b28fdb6941 = NULL;

    assertFrameObject(frame_6390b7f7acb0d560e13329b28fdb6941);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_db559a66c57804d1299b0a78f87fee65;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_db559a66c57804d1299b0a78f87fee65 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_db559a66c57804d1299b0a78f87fee65, codeobj_db559a66c57804d1299b0a78f87fee65, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_db559a66c57804d1299b0a78f87fee65 = cache_frame_db559a66c57804d1299b0a78f87fee65;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_db559a66c57804d1299b0a78f87fee65);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_db559a66c57804d1299b0a78f87fee65) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_db559a66c57804d1299b0a78f87fee65->m_frame.f_lineno = 396;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 396;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_db559a66c57804d1299b0a78f87fee65);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_db559a66c57804d1299b0a78f87fee65);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_db559a66c57804d1299b0a78f87fee65);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_db559a66c57804d1299b0a78f87fee65, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_db559a66c57804d1299b0a78f87fee65->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_db559a66c57804d1299b0a78f87fee65, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_db559a66c57804d1299b0a78f87fee65,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_db559a66c57804d1299b0a78f87fee65 == cache_frame_db559a66c57804d1299b0a78f87fee65) {
        Py_DECREF(frame_db559a66c57804d1299b0a78f87fee65);
    }
    cache_frame_db559a66c57804d1299b0a78f87fee65 = NULL;

    assertFrameObject(frame_db559a66c57804d1299b0a78f87fee65);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_7c100bf546aed522cbd46c14979c3efc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7c100bf546aed522cbd46c14979c3efc = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7c100bf546aed522cbd46c14979c3efc, codeobj_7c100bf546aed522cbd46c14979c3efc, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_7c100bf546aed522cbd46c14979c3efc = cache_frame_7c100bf546aed522cbd46c14979c3efc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7c100bf546aed522cbd46c14979c3efc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7c100bf546aed522cbd46c14979c3efc) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_7c100bf546aed522cbd46c14979c3efc->m_frame.f_lineno = 400;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 400;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c100bf546aed522cbd46c14979c3efc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c100bf546aed522cbd46c14979c3efc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c100bf546aed522cbd46c14979c3efc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7c100bf546aed522cbd46c14979c3efc, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7c100bf546aed522cbd46c14979c3efc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7c100bf546aed522cbd46c14979c3efc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7c100bf546aed522cbd46c14979c3efc,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_7c100bf546aed522cbd46c14979c3efc == cache_frame_7c100bf546aed522cbd46c14979c3efc) {
        Py_DECREF(frame_7c100bf546aed522cbd46c14979c3efc);
    }
    cache_frame_7c100bf546aed522cbd46c14979c3efc = NULL;

    assertFrameObject(frame_7c100bf546aed522cbd46c14979c3efc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_29fb47d6e17a7db0be35c6eeddb22698;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_29fb47d6e17a7db0be35c6eeddb22698 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_29fb47d6e17a7db0be35c6eeddb22698, codeobj_29fb47d6e17a7db0be35c6eeddb22698, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_29fb47d6e17a7db0be35c6eeddb22698 = cache_frame_29fb47d6e17a7db0be35c6eeddb22698;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_29fb47d6e17a7db0be35c6eeddb22698);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_29fb47d6e17a7db0be35c6eeddb22698) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_cls);
        tmp_called_instance_1 = par_cls;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_29fb47d6e17a7db0be35c6eeddb22698->m_frame.f_lineno = 404;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 404;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_29fb47d6e17a7db0be35c6eeddb22698);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_29fb47d6e17a7db0be35c6eeddb22698);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_29fb47d6e17a7db0be35c6eeddb22698);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_29fb47d6e17a7db0be35c6eeddb22698, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_29fb47d6e17a7db0be35c6eeddb22698->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_29fb47d6e17a7db0be35c6eeddb22698, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_29fb47d6e17a7db0be35c6eeddb22698,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_29fb47d6e17a7db0be35c6eeddb22698 == cache_frame_29fb47d6e17a7db0be35c6eeddb22698) {
        Py_DECREF(frame_29fb47d6e17a7db0be35c6eeddb22698);
    }
    cache_frame_29fb47d6e17a7db0be35c6eeddb22698 = NULL;

    assertFrameObject(frame_29fb47d6e17a7db0be35c6eeddb22698);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_emit = python_pars[1];
    struct Nuitka_FrameObject *frame_3dd985f11eb0390621d8aa4f697a7080;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3dd985f11eb0390621d8aa4f697a7080 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3dd985f11eb0390621d8aa4f697a7080, codeobj_3dd985f11eb0390621d8aa4f697a7080, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3dd985f11eb0390621d8aa4f697a7080 = cache_frame_3dd985f11eb0390621d8aa4f697a7080;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3dd985f11eb0390621d8aa4f697a7080);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3dd985f11eb0390621d8aa4f697a7080) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_emit);
        tmp_called_name_1 = par_emit;
        CHECK_OBJECT(par_cls);
        tmp_args_element_name_1 = par_cls;
        frame_3dd985f11eb0390621d8aa4f697a7080->m_frame.f_lineno = 408;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 408;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dd985f11eb0390621d8aa4f697a7080);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dd985f11eb0390621d8aa4f697a7080);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3dd985f11eb0390621d8aa4f697a7080, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3dd985f11eb0390621d8aa4f697a7080->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3dd985f11eb0390621d8aa4f697a7080, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3dd985f11eb0390621d8aa4f697a7080,
        type_description_1,
        par_cls,
        par_emit
    );


    // Release cached frame.
    if (frame_3dd985f11eb0390621d8aa4f697a7080 == cache_frame_3dd985f11eb0390621d8aa4f697a7080) {
        Py_DECREF(frame_3dd985f11eb0390621d8aa4f697a7080);
    }
    cache_frame_3dd985f11eb0390621d8aa4f697a7080 = NULL;

    assertFrameObject(frame_3dd985f11eb0390621d8aa4f697a7080);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_emit);
    Py_DECREF(par_emit);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_emit);
    Py_DECREF(par_emit);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_02a760bb24dd602344ff02253e7d2d49;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_02a760bb24dd602344ff02253e7d2d49 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_02a760bb24dd602344ff02253e7d2d49, codeobj_02a760bb24dd602344ff02253e7d2d49, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_02a760bb24dd602344ff02253e7d2d49 = cache_frame_02a760bb24dd602344ff02253e7d2d49;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_02a760bb24dd602344ff02253e7d2d49);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_02a760bb24dd602344ff02253e7d2d49) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 414;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_02a760bb24dd602344ff02253e7d2d49);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_02a760bb24dd602344ff02253e7d2d49);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_02a760bb24dd602344ff02253e7d2d49);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_02a760bb24dd602344ff02253e7d2d49, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_02a760bb24dd602344ff02253e7d2d49->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_02a760bb24dd602344ff02253e7d2d49, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_02a760bb24dd602344ff02253e7d2d49,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_02a760bb24dd602344ff02253e7d2d49 == cache_frame_02a760bb24dd602344ff02253e7d2d49) {
        Py_DECREF(frame_02a760bb24dd602344ff02253e7d2d49);
    }
    cache_frame_02a760bb24dd602344ff02253e7d2d49 = NULL;

    assertFrameObject(frame_02a760bb24dd602344ff02253e7d2d49);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_92c12f700eb21f649d49d8acb8025fa1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_92c12f700eb21f649d49d8acb8025fa1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_92c12f700eb21f649d49d8acb8025fa1, codeobj_92c12f700eb21f649d49d8acb8025fa1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_92c12f700eb21f649d49d8acb8025fa1 = cache_frame_92c12f700eb21f649d49d8acb8025fa1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_92c12f700eb21f649d49d8acb8025fa1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_92c12f700eb21f649d49d8acb8025fa1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 418;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c12f700eb21f649d49d8acb8025fa1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c12f700eb21f649d49d8acb8025fa1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92c12f700eb21f649d49d8acb8025fa1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_92c12f700eb21f649d49d8acb8025fa1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_92c12f700eb21f649d49d8acb8025fa1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_92c12f700eb21f649d49d8acb8025fa1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_92c12f700eb21f649d49d8acb8025fa1,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_92c12f700eb21f649d49d8acb8025fa1 == cache_frame_92c12f700eb21f649d49d8acb8025fa1) {
        Py_DECREF(frame_92c12f700eb21f649d49d8acb8025fa1);
    }
    cache_frame_92c12f700eb21f649d49d8acb8025fa1 = NULL;

    assertFrameObject(frame_92c12f700eb21f649d49d8acb8025fa1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_9b596b8c78a93eea39d745589a3900b6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9b596b8c78a93eea39d745589a3900b6 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9b596b8c78a93eea39d745589a3900b6, codeobj_9b596b8c78a93eea39d745589a3900b6, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_9b596b8c78a93eea39d745589a3900b6 = cache_frame_9b596b8c78a93eea39d745589a3900b6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9b596b8c78a93eea39d745589a3900b6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9b596b8c78a93eea39d745589a3900b6) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 422;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b596b8c78a93eea39d745589a3900b6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b596b8c78a93eea39d745589a3900b6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9b596b8c78a93eea39d745589a3900b6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9b596b8c78a93eea39d745589a3900b6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9b596b8c78a93eea39d745589a3900b6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9b596b8c78a93eea39d745589a3900b6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9b596b8c78a93eea39d745589a3900b6,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_9b596b8c78a93eea39d745589a3900b6 == cache_frame_9b596b8c78a93eea39d745589a3900b6) {
        Py_DECREF(frame_9b596b8c78a93eea39d745589a3900b6);
    }
    cache_frame_9b596b8c78a93eea39d745589a3900b6 = NULL;

    assertFrameObject(frame_9b596b8c78a93eea39d745589a3900b6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_cb66089c7c49445489a6df4c43c43e5b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cb66089c7c49445489a6df4c43c43e5b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cb66089c7c49445489a6df4c43c43e5b, codeobj_cb66089c7c49445489a6df4c43c43e5b, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_cb66089c7c49445489a6df4c43c43e5b = cache_frame_cb66089c7c49445489a6df4c43c43e5b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cb66089c7c49445489a6df4c43c43e5b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cb66089c7c49445489a6df4c43c43e5b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 426;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb66089c7c49445489a6df4c43c43e5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb66089c7c49445489a6df4c43c43e5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb66089c7c49445489a6df4c43c43e5b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cb66089c7c49445489a6df4c43c43e5b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cb66089c7c49445489a6df4c43c43e5b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cb66089c7c49445489a6df4c43c43e5b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cb66089c7c49445489a6df4c43c43e5b,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_cb66089c7c49445489a6df4c43c43e5b == cache_frame_cb66089c7c49445489a6df4c43c43e5b) {
        Py_DECREF(frame_cb66089c7c49445489a6df4c43c43e5b);
    }
    cache_frame_cb66089c7c49445489a6df4c43c43e5b = NULL;

    assertFrameObject(frame_cb66089c7c49445489a6df4c43c43e5b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_9f37cab9541cc450eb9c857ae61b29a1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9f37cab9541cc450eb9c857ae61b29a1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9f37cab9541cc450eb9c857ae61b29a1, codeobj_9f37cab9541cc450eb9c857ae61b29a1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_9f37cab9541cc450eb9c857ae61b29a1 = cache_frame_9f37cab9541cc450eb9c857ae61b29a1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9f37cab9541cc450eb9c857ae61b29a1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9f37cab9541cc450eb9c857ae61b29a1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 430;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9f37cab9541cc450eb9c857ae61b29a1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9f37cab9541cc450eb9c857ae61b29a1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9f37cab9541cc450eb9c857ae61b29a1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9f37cab9541cc450eb9c857ae61b29a1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9f37cab9541cc450eb9c857ae61b29a1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9f37cab9541cc450eb9c857ae61b29a1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9f37cab9541cc450eb9c857ae61b29a1,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_9f37cab9541cc450eb9c857ae61b29a1 == cache_frame_9f37cab9541cc450eb9c857ae61b29a1) {
        Py_DECREF(frame_9f37cab9541cc450eb9c857ae61b29a1);
    }
    cache_frame_9f37cab9541cc450eb9c857ae61b29a1 = NULL;

    assertFrameObject(frame_9f37cab9541cc450eb9c857ae61b29a1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_f106a1a4d7fc00f78b1f75bd99972f11;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f106a1a4d7fc00f78b1f75bd99972f11 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f106a1a4d7fc00f78b1f75bd99972f11, codeobj_f106a1a4d7fc00f78b1f75bd99972f11, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_f106a1a4d7fc00f78b1f75bd99972f11 = cache_frame_f106a1a4d7fc00f78b1f75bd99972f11;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f106a1a4d7fc00f78b1f75bd99972f11);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f106a1a4d7fc00f78b1f75bd99972f11) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 434;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f106a1a4d7fc00f78b1f75bd99972f11);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f106a1a4d7fc00f78b1f75bd99972f11);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f106a1a4d7fc00f78b1f75bd99972f11);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f106a1a4d7fc00f78b1f75bd99972f11, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f106a1a4d7fc00f78b1f75bd99972f11->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f106a1a4d7fc00f78b1f75bd99972f11, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f106a1a4d7fc00f78b1f75bd99972f11,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_f106a1a4d7fc00f78b1f75bd99972f11 == cache_frame_f106a1a4d7fc00f78b1f75bd99972f11) {
        Py_DECREF(frame_f106a1a4d7fc00f78b1f75bd99972f11);
    }
    cache_frame_f106a1a4d7fc00f78b1f75bd99972f11 = NULL;

    assertFrameObject(frame_f106a1a4d7fc00f78b1f75bd99972f11);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_ccebd776c0e9937695f958a434521a69;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ccebd776c0e9937695f958a434521a69 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ccebd776c0e9937695f958a434521a69, codeobj_ccebd776c0e9937695f958a434521a69, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_ccebd776c0e9937695f958a434521a69 = cache_frame_ccebd776c0e9937695f958a434521a69;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ccebd776c0e9937695f958a434521a69);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ccebd776c0e9937695f958a434521a69) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 438;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ccebd776c0e9937695f958a434521a69);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ccebd776c0e9937695f958a434521a69);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ccebd776c0e9937695f958a434521a69);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ccebd776c0e9937695f958a434521a69, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ccebd776c0e9937695f958a434521a69->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ccebd776c0e9937695f958a434521a69, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ccebd776c0e9937695f958a434521a69,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_ccebd776c0e9937695f958a434521a69 == cache_frame_ccebd776c0e9937695f958a434521a69) {
        Py_DECREF(frame_ccebd776c0e9937695f958a434521a69);
    }
    cache_frame_ccebd776c0e9937695f958a434521a69 = NULL;

    assertFrameObject(frame_ccebd776c0e9937695f958a434521a69);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_fcfb7c2b1f4bf8340de4834a4181b333;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fcfb7c2b1f4bf8340de4834a4181b333 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fcfb7c2b1f4bf8340de4834a4181b333, codeobj_fcfb7c2b1f4bf8340de4834a4181b333, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_fcfb7c2b1f4bf8340de4834a4181b333 = cache_frame_fcfb7c2b1f4bf8340de4834a4181b333;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fcfb7c2b1f4bf8340de4834a4181b333);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fcfb7c2b1f4bf8340de4834a4181b333) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 442;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcfb7c2b1f4bf8340de4834a4181b333);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcfb7c2b1f4bf8340de4834a4181b333);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fcfb7c2b1f4bf8340de4834a4181b333);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fcfb7c2b1f4bf8340de4834a4181b333, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fcfb7c2b1f4bf8340de4834a4181b333->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fcfb7c2b1f4bf8340de4834a4181b333, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fcfb7c2b1f4bf8340de4834a4181b333,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_fcfb7c2b1f4bf8340de4834a4181b333 == cache_frame_fcfb7c2b1f4bf8340de4834a4181b333) {
        Py_DECREF(frame_fcfb7c2b1f4bf8340de4834a4181b333);
    }
    cache_frame_fcfb7c2b1f4bf8340de4834a4181b333 = NULL;

    assertFrameObject(frame_fcfb7c2b1f4bf8340de4834a4181b333);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_c6072bc075ab36c511024aa4ee91175d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c6072bc075ab36c511024aa4ee91175d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c6072bc075ab36c511024aa4ee91175d, codeobj_c6072bc075ab36c511024aa4ee91175d, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_c6072bc075ab36c511024aa4ee91175d = cache_frame_c6072bc075ab36c511024aa4ee91175d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c6072bc075ab36c511024aa4ee91175d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c6072bc075ab36c511024aa4ee91175d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 446;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c6072bc075ab36c511024aa4ee91175d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c6072bc075ab36c511024aa4ee91175d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c6072bc075ab36c511024aa4ee91175d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c6072bc075ab36c511024aa4ee91175d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c6072bc075ab36c511024aa4ee91175d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c6072bc075ab36c511024aa4ee91175d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c6072bc075ab36c511024aa4ee91175d,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_c6072bc075ab36c511024aa4ee91175d == cache_frame_c6072bc075ab36c511024aa4ee91175d) {
        Py_DECREF(frame_c6072bc075ab36c511024aa4ee91175d);
    }
    cache_frame_c6072bc075ab36c511024aa4ee91175d = NULL;

    assertFrameObject(frame_c6072bc075ab36c511024aa4ee91175d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_d40437d95659f9bf5a7905552e30aca2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d40437d95659f9bf5a7905552e30aca2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d40437d95659f9bf5a7905552e30aca2, codeobj_d40437d95659f9bf5a7905552e30aca2, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_d40437d95659f9bf5a7905552e30aca2 = cache_frame_d40437d95659f9bf5a7905552e30aca2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d40437d95659f9bf5a7905552e30aca2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d40437d95659f9bf5a7905552e30aca2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 450;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d40437d95659f9bf5a7905552e30aca2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d40437d95659f9bf5a7905552e30aca2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d40437d95659f9bf5a7905552e30aca2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d40437d95659f9bf5a7905552e30aca2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d40437d95659f9bf5a7905552e30aca2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d40437d95659f9bf5a7905552e30aca2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d40437d95659f9bf5a7905552e30aca2,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_d40437d95659f9bf5a7905552e30aca2 == cache_frame_d40437d95659f9bf5a7905552e30aca2) {
        Py_DECREF(frame_d40437d95659f9bf5a7905552e30aca2);
    }
    cache_frame_d40437d95659f9bf5a7905552e30aca2 = NULL;

    assertFrameObject(frame_d40437d95659f9bf5a7905552e30aca2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_e5d0fed2b249d1b8ba1ccf80b6875e05;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e5d0fed2b249d1b8ba1ccf80b6875e05 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e5d0fed2b249d1b8ba1ccf80b6875e05, codeobj_e5d0fed2b249d1b8ba1ccf80b6875e05, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_e5d0fed2b249d1b8ba1ccf80b6875e05 = cache_frame_e5d0fed2b249d1b8ba1ccf80b6875e05;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e5d0fed2b249d1b8ba1ccf80b6875e05);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e5d0fed2b249d1b8ba1ccf80b6875e05) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 454;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e5d0fed2b249d1b8ba1ccf80b6875e05);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e5d0fed2b249d1b8ba1ccf80b6875e05);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e5d0fed2b249d1b8ba1ccf80b6875e05);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e5d0fed2b249d1b8ba1ccf80b6875e05, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e5d0fed2b249d1b8ba1ccf80b6875e05->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e5d0fed2b249d1b8ba1ccf80b6875e05, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e5d0fed2b249d1b8ba1ccf80b6875e05,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_e5d0fed2b249d1b8ba1ccf80b6875e05 == cache_frame_e5d0fed2b249d1b8ba1ccf80b6875e05) {
        Py_DECREF(frame_e5d0fed2b249d1b8ba1ccf80b6875e05);
    }
    cache_frame_e5d0fed2b249d1b8ba1ccf80b6875e05 = NULL;

    assertFrameObject(frame_e5d0fed2b249d1b8ba1ccf80b6875e05);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_6517a9e6af7657c6c498ec1df71e5715;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6517a9e6af7657c6c498ec1df71e5715 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6517a9e6af7657c6c498ec1df71e5715, codeobj_6517a9e6af7657c6c498ec1df71e5715, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_6517a9e6af7657c6c498ec1df71e5715 = cache_frame_6517a9e6af7657c6c498ec1df71e5715;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6517a9e6af7657c6c498ec1df71e5715);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6517a9e6af7657c6c498ec1df71e5715) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 458;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6517a9e6af7657c6c498ec1df71e5715);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6517a9e6af7657c6c498ec1df71e5715);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6517a9e6af7657c6c498ec1df71e5715);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6517a9e6af7657c6c498ec1df71e5715, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6517a9e6af7657c6c498ec1df71e5715->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6517a9e6af7657c6c498ec1df71e5715, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6517a9e6af7657c6c498ec1df71e5715,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_6517a9e6af7657c6c498ec1df71e5715 == cache_frame_6517a9e6af7657c6c498ec1df71e5715) {
        Py_DECREF(frame_6517a9e6af7657c6c498ec1df71e5715);
    }
    cache_frame_6517a9e6af7657c6c498ec1df71e5715 = NULL;

    assertFrameObject(frame_6517a9e6af7657c6c498ec1df71e5715);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_8d52d35578ce25dc5ed9bb1ffc8f2a50;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8d52d35578ce25dc5ed9bb1ffc8f2a50 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8d52d35578ce25dc5ed9bb1ffc8f2a50, codeobj_8d52d35578ce25dc5ed9bb1ffc8f2a50, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_8d52d35578ce25dc5ed9bb1ffc8f2a50 = cache_frame_8d52d35578ce25dc5ed9bb1ffc8f2a50;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 462;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8d52d35578ce25dc5ed9bb1ffc8f2a50->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8d52d35578ce25dc5ed9bb1ffc8f2a50, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8d52d35578ce25dc5ed9bb1ffc8f2a50,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_8d52d35578ce25dc5ed9bb1ffc8f2a50 == cache_frame_8d52d35578ce25dc5ed9bb1ffc8f2a50) {
        Py_DECREF(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50);
    }
    cache_frame_8d52d35578ce25dc5ed9bb1ffc8f2a50 = NULL;

    assertFrameObject(frame_8d52d35578ce25dc5ed9bb1ffc8f2a50);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_92ab9ca6c3d62cc16d8e60249b83ab8c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_92ab9ca6c3d62cc16d8e60249b83ab8c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_92ab9ca6c3d62cc16d8e60249b83ab8c, codeobj_92ab9ca6c3d62cc16d8e60249b83ab8c, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_92ab9ca6c3d62cc16d8e60249b83ab8c = cache_frame_92ab9ca6c3d62cc16d8e60249b83ab8c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_92ab9ca6c3d62cc16d8e60249b83ab8c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_92ab9ca6c3d62cc16d8e60249b83ab8c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 466;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92ab9ca6c3d62cc16d8e60249b83ab8c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_92ab9ca6c3d62cc16d8e60249b83ab8c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_92ab9ca6c3d62cc16d8e60249b83ab8c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_92ab9ca6c3d62cc16d8e60249b83ab8c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_92ab9ca6c3d62cc16d8e60249b83ab8c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_92ab9ca6c3d62cc16d8e60249b83ab8c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_92ab9ca6c3d62cc16d8e60249b83ab8c,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_92ab9ca6c3d62cc16d8e60249b83ab8c == cache_frame_92ab9ca6c3d62cc16d8e60249b83ab8c) {
        Py_DECREF(frame_92ab9ca6c3d62cc16d8e60249b83ab8c);
    }
    cache_frame_92ab9ca6c3d62cc16d8e60249b83ab8c = NULL;

    assertFrameObject(frame_92ab9ca6c3d62cc16d8e60249b83ab8c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_cls = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_20fdbaf40e4c640828046210bbe44889;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_20fdbaf40e4c640828046210bbe44889 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_20fdbaf40e4c640828046210bbe44889, codeobj_20fdbaf40e4c640828046210bbe44889, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_20fdbaf40e4c640828046210bbe44889 = cache_frame_20fdbaf40e4c640828046210bbe44889;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_20fdbaf40e4c640828046210bbe44889);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_20fdbaf40e4c640828046210bbe44889) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 470;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_20fdbaf40e4c640828046210bbe44889);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_20fdbaf40e4c640828046210bbe44889);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_20fdbaf40e4c640828046210bbe44889);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_20fdbaf40e4c640828046210bbe44889, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_20fdbaf40e4c640828046210bbe44889->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_20fdbaf40e4c640828046210bbe44889, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_20fdbaf40e4c640828046210bbe44889,
        type_description_1,
        par_cls,
        par_right_shape
    );


    // Release cached frame.
    if (frame_20fdbaf40e4c640828046210bbe44889 == cache_frame_20fdbaf40e4c640828046210bbe44889) {
        Py_DECREF(frame_20fdbaf40e4c640828046210bbe44889);
    }
    cache_frame_20fdbaf40e4c640828046210bbe44889 = NULL;

    assertFrameObject(frame_20fdbaf40e4c640828046210bbe44889);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_cls);
    Py_DECREF(par_cls);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_52_hasShapeSlotLen(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_7375bd3b7c5c494c7b6e41ec225ff82d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7375bd3b7c5c494c7b6e41ec225ff82d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7375bd3b7c5c494c7b6e41ec225ff82d, codeobj_7375bd3b7c5c494c7b6e41ec225ff82d, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_7375bd3b7c5c494c7b6e41ec225ff82d = cache_frame_7375bd3b7c5c494c7b6e41ec225ff82d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7375bd3b7c5c494c7b6e41ec225ff82d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7375bd3b7c5c494c7b6e41ec225ff82d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        frame_7375bd3b7c5c494c7b6e41ec225ff82d->m_frame.f_lineno = 477;
        tmp_called_instance_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_getTypeShape);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 477;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_7375bd3b7c5c494c7b6e41ec225ff82d->m_frame.f_lineno = 477;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotLen);
        Py_DECREF(tmp_called_instance_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 477;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7375bd3b7c5c494c7b6e41ec225ff82d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7375bd3b7c5c494c7b6e41ec225ff82d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7375bd3b7c5c494c7b6e41ec225ff82d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7375bd3b7c5c494c7b6e41ec225ff82d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7375bd3b7c5c494c7b6e41ec225ff82d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7375bd3b7c5c494c7b6e41ec225ff82d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7375bd3b7c5c494c7b6e41ec225ff82d,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_7375bd3b7c5c494c7b6e41ec225ff82d == cache_frame_7375bd3b7c5c494c7b6e41ec225ff82d) {
        Py_DECREF(frame_7375bd3b7c5c494c7b6e41ec225ff82d);
    }
    cache_frame_7375bd3b7c5c494c7b6e41ec225ff82d = NULL;

    assertFrameObject(frame_7375bd3b7c5c494c7b6e41ec225ff82d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_52_hasShapeSlotLen);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_a7baa7c0f07185d9e8b484fee1877a94;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a7baa7c0f07185d9e8b484fee1877a94 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a7baa7c0f07185d9e8b484fee1877a94, codeobj_a7baa7c0f07185d9e8b484fee1877a94, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, 0);
    frame_a7baa7c0f07185d9e8b484fee1877a94 = cache_frame_a7baa7c0f07185d9e8b484fee1877a94;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a7baa7c0f07185d9e8b484fee1877a94);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a7baa7c0f07185d9e8b484fee1877a94) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 485;

            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a7baa7c0f07185d9e8b484fee1877a94);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a7baa7c0f07185d9e8b484fee1877a94);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a7baa7c0f07185d9e8b484fee1877a94);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a7baa7c0f07185d9e8b484fee1877a94, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a7baa7c0f07185d9e8b484fee1877a94->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a7baa7c0f07185d9e8b484fee1877a94, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a7baa7c0f07185d9e8b484fee1877a94,
        type_description_1
    );


    // Release cached frame.
    if (frame_a7baa7c0f07185d9e8b484fee1877a94 == cache_frame_a7baa7c0f07185d9e8b484fee1877a94) {
        Py_DECREF(frame_a7baa7c0f07185d9e8b484fee1877a94);
    }
    cache_frame_a7baa7c0f07185d9e8b484fee1877a94 = NULL;

    assertFrameObject(frame_a7baa7c0f07185d9e8b484fee1877a94);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_54___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_size = python_pars[1];
    PyObject *par_shape = python_pars[2];
    struct Nuitka_FrameObject *frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6, codeobj_3d9d357ef5fd95d0ea8392fcfe0fb9f6, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6 = cache_frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_size);
        tmp_assattr_name_1 = par_size;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_size, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 496;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_shape);
        tmp_assattr_name_2 = par_shape;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain_shape, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 497;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6,
        type_description_1,
        par_self,
        par_size,
        par_shape
    );


    // Release cached frame.
    if (frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6 == cache_frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6) {
        Py_DECREF(frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6);
    }
    cache_frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6 = NULL;

    assertFrameObject(frame_3d9d357ef5fd95d0ea8392fcfe0fb9f6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_54___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);
    CHECK_OBJECT(par_shape);
    Py_DECREF(par_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);
    CHECK_OBJECT(par_shape);
    Py_DECREF(par_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_55_getTypeShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_b584a9e3380c2590713c3f1fcc9529d0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b584a9e3380c2590713c3f1fcc9529d0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b584a9e3380c2590713c3f1fcc9529d0, codeobj_b584a9e3380c2590713c3f1fcc9529d0, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_b584a9e3380c2590713c3f1fcc9529d0 = cache_frame_b584a9e3380c2590713c3f1fcc9529d0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b584a9e3380c2590713c3f1fcc9529d0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b584a9e3380c2590713c3f1fcc9529d0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_shape);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 500;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b584a9e3380c2590713c3f1fcc9529d0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b584a9e3380c2590713c3f1fcc9529d0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b584a9e3380c2590713c3f1fcc9529d0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b584a9e3380c2590713c3f1fcc9529d0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b584a9e3380c2590713c3f1fcc9529d0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b584a9e3380c2590713c3f1fcc9529d0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b584a9e3380c2590713c3f1fcc9529d0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_b584a9e3380c2590713c3f1fcc9529d0 == cache_frame_b584a9e3380c2590713c3f1fcc9529d0) {
        Py_DECREF(frame_b584a9e3380c2590713c3f1fcc9529d0);
    }
    cache_frame_b584a9e3380c2590713c3f1fcc9529d0 = NULL;

    assertFrameObject(frame_b584a9e3380c2590713c3f1fcc9529d0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_55_getTypeShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    tmp_return_value = Py_True;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant);
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_57_hasShapeSlotLen(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_e1ea14b18ebff6d3e87dbd7f9e59473c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e1ea14b18ebff6d3e87dbd7f9e59473c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e1ea14b18ebff6d3e87dbd7f9e59473c, codeobj_e1ea14b18ebff6d3e87dbd7f9e59473c, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_e1ea14b18ebff6d3e87dbd7f9e59473c = cache_frame_e1ea14b18ebff6d3e87dbd7f9e59473c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e1ea14b18ebff6d3e87dbd7f9e59473c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e1ea14b18ebff6d3e87dbd7f9e59473c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_shape);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 507;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_e1ea14b18ebff6d3e87dbd7f9e59473c->m_frame.f_lineno = 507;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotLen);
        Py_DECREF(tmp_called_instance_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 507;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1ea14b18ebff6d3e87dbd7f9e59473c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1ea14b18ebff6d3e87dbd7f9e59473c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1ea14b18ebff6d3e87dbd7f9e59473c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e1ea14b18ebff6d3e87dbd7f9e59473c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e1ea14b18ebff6d3e87dbd7f9e59473c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e1ea14b18ebff6d3e87dbd7f9e59473c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e1ea14b18ebff6d3e87dbd7f9e59473c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_e1ea14b18ebff6d3e87dbd7f9e59473c == cache_frame_e1ea14b18ebff6d3e87dbd7f9e59473c) {
        Py_DECREF(frame_e1ea14b18ebff6d3e87dbd7f9e59473c);
    }
    cache_frame_e1ea14b18ebff6d3e87dbd7f9e59473c = NULL;

    assertFrameObject(frame_e1ea14b18ebff6d3e87dbd7f9e59473c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_57_hasShapeSlotLen);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_58___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_size = python_pars[1];
    PyObject *par_predictor = python_pars[2];
    PyObject *par_shape = python_pars[3];
    struct Nuitka_FrameObject *frame_208a723e26e261a3bf976d79358671a0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    static struct Nuitka_FrameObject *cache_frame_208a723e26e261a3bf976d79358671a0 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_208a723e26e261a3bf976d79358671a0, codeobj_208a723e26e261a3bf976d79358671a0, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_208a723e26e261a3bf976d79358671a0 = cache_frame_208a723e26e261a3bf976d79358671a0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_208a723e26e261a3bf976d79358671a0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_208a723e26e261a3bf976d79358671a0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLargeConstantValue);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLargeConstantValue);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 76415 ], 45, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 514;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_args_element_name_1 = par_self;
        CHECK_OBJECT(par_size);
        tmp_args_element_name_2 = par_size;
        CHECK_OBJECT(par_shape);
        tmp_args_element_name_3 = par_shape;
        frame_208a723e26e261a3bf976d79358671a0->m_frame.f_lineno = 514;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS3(tmp_called_instance_1, const_str_plain___init__, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 514;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_predictor);
        tmp_assattr_name_1 = par_predictor;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_predictor, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 516;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_208a723e26e261a3bf976d79358671a0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_208a723e26e261a3bf976d79358671a0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_208a723e26e261a3bf976d79358671a0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_208a723e26e261a3bf976d79358671a0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_208a723e26e261a3bf976d79358671a0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_208a723e26e261a3bf976d79358671a0,
        type_description_1,
        par_self,
        par_size,
        par_predictor,
        par_shape
    );


    // Release cached frame.
    if (frame_208a723e26e261a3bf976d79358671a0 == cache_frame_208a723e26e261a3bf976d79358671a0) {
        Py_DECREF(frame_208a723e26e261a3bf976d79358671a0);
    }
    cache_frame_208a723e26e261a3bf976d79358671a0 = NULL;

    assertFrameObject(frame_208a723e26e261a3bf976d79358671a0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_58___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);
    CHECK_OBJECT(par_predictor);
    Py_DECREF(par_predictor);
    CHECK_OBJECT(par_shape);
    Py_DECREF(par_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_size);
    Py_DECREF(par_size);
    CHECK_OBJECT(par_predictor);
    Py_DECREF(par_predictor);
    CHECK_OBJECT(par_shape);
    Py_DECREF(par_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    tmp_return_value = Py_True;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter);
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    tmp_return_value = Py_True;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext);
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_FrameObject *frame_7ca2522bf2581894b1beb8f845b610a2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7ca2522bf2581894b1beb8f845b610a2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7ca2522bf2581894b1beb8f845b610a2, codeobj_7ca2522bf2581894b1beb8f845b610a2, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, 0);
    frame_7ca2522bf2581894b1beb8f845b610a2 = cache_frame_7ca2522bf2581894b1beb8f845b610a2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7ca2522bf2581894b1beb8f845b610a2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7ca2522bf2581894b1beb8f845b610a2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeIterator);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeIterator);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 67062 ], 35, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 550;

            goto frame_exception_exit_1;
        }

        tmp_return_value = tmp_mvar_value_1;
        Py_INCREF(tmp_return_value);
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7ca2522bf2581894b1beb8f845b610a2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7ca2522bf2581894b1beb8f845b610a2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7ca2522bf2581894b1beb8f845b610a2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7ca2522bf2581894b1beb8f845b610a2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7ca2522bf2581894b1beb8f845b610a2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7ca2522bf2581894b1beb8f845b610a2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7ca2522bf2581894b1beb8f845b610a2,
        type_description_1
    );


    // Release cached frame.
    if (frame_7ca2522bf2581894b1beb8f845b610a2 == cache_frame_7ca2522bf2581894b1beb8f845b610a2) {
        Py_DECREF(frame_7ca2522bf2581894b1beb8f845b610a2);
    }
    cache_frame_7ca2522bf2581894b1beb8f845b610a2 = NULL;

    assertFrameObject(frame_7ca2522bf2581894b1beb8f845b610a2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter);
    return NULL;

function_exception_exit:
    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    tmp_return_value = Py_True;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains);
    return NULL;


function_return_exit:
   // Function cleanup code if any.


   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_68___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_shapes = python_pars[1];
    struct Nuitka_FrameObject *frame_a28c20139dda310267de405e90aedb3b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a28c20139dda310267de405e90aedb3b = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a28c20139dda310267de405e90aedb3b, codeobj_a28c20139dda310267de405e90aedb3b, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_a28c20139dda310267de405e90aedb3b = cache_frame_a28c20139dda310267de405e90aedb3b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a28c20139dda310267de405e90aedb3b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a28c20139dda310267de405e90aedb3b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_shapes);
        tmp_assattr_name_1 = par_shapes;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_type_shapes, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 571;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 573;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_shapes);
        tmp_compexpr_right_1 = par_shapes;
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 573;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 573;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a28c20139dda310267de405e90aedb3b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a28c20139dda310267de405e90aedb3b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a28c20139dda310267de405e90aedb3b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a28c20139dda310267de405e90aedb3b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a28c20139dda310267de405e90aedb3b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a28c20139dda310267de405e90aedb3b,
        type_description_1,
        par_self,
        par_shapes
    );


    // Release cached frame.
    if (frame_a28c20139dda310267de405e90aedb3b == cache_frame_a28c20139dda310267de405e90aedb3b) {
        Py_DECREF(frame_a28c20139dda310267de405e90aedb3b);
    }
    cache_frame_a28c20139dda310267de405e90aedb3b = NULL;

    assertFrameObject(frame_a28c20139dda310267de405e90aedb3b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_68___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shapes);
    Py_DECREF(par_shapes);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shapes);
    Py_DECREF(par_shapes);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_emit = python_pars[1];
    PyObject *var_type_shape = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_2569be5f046998681575c4cffffe0229;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_2569be5f046998681575c4cffffe0229 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_2569be5f046998681575c4cffffe0229, codeobj_2569be5f046998681575c4cffffe0229, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_2569be5f046998681575c4cffffe0229 = cache_frame_2569be5f046998681575c4cffffe0229;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2569be5f046998681575c4cffffe0229);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2569be5f046998681575c4cffffe0229) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_type_shapes);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 576;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 576;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                exception_lineno = 576;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_type_shape;
            var_type_shape = tmp_assign_source_3;
            Py_INCREF(var_type_shape);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(var_type_shape);
        tmp_called_instance_1 = var_type_shape;
        CHECK_OBJECT(par_emit);
        tmp_args_element_name_1 = par_emit;
        frame_2569be5f046998681575c4cffffe0229->m_frame.f_lineno = 577;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_emitAlternatives, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 577;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 576;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2569be5f046998681575c4cffffe0229);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2569be5f046998681575c4cffffe0229);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2569be5f046998681575c4cffffe0229, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2569be5f046998681575c4cffffe0229->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2569be5f046998681575c4cffffe0229, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2569be5f046998681575c4cffffe0229,
        type_description_1,
        par_self,
        par_emit,
        var_type_shape
    );


    // Release cached frame.
    if (frame_2569be5f046998681575c4cffffe0229 == cache_frame_2569be5f046998681575c4cffffe0229) {
        Py_DECREF(frame_2569be5f046998681575c4cffffe0229);
    }
    cache_frame_2569be5f046998681575c4cffffe0229 = NULL;

    assertFrameObject(frame_2569be5f046998681575c4cffffe0229);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_emit);
    Py_DECREF(par_emit);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_emit);
    Py_DECREF(par_emit);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_operation = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_type_shape = NULL;
    PyObject *var_entry = NULL;
    PyObject *var__description = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_aadd76d1ac15293cca02cc13b85b7e65;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    int tmp_res;
    bool tmp_result;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    static struct Nuitka_FrameObject *cache_frame_aadd76d1ac15293cca02cc13b85b7e65 = NULL;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PySet_New(NULL);
        assert(var_result == NULL);
        var_result = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_aadd76d1ac15293cca02cc13b85b7e65, codeobj_aadd76d1ac15293cca02cc13b85b7e65, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_aadd76d1ac15293cca02cc13b85b7e65 = cache_frame_aadd76d1ac15293cca02cc13b85b7e65;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_aadd76d1ac15293cca02cc13b85b7e65);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_aadd76d1ac15293cca02cc13b85b7e65) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_type_shapes);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 582;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 582;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_3 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooo";
                exception_lineno = 582;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_type_shape;
            var_type_shape = tmp_assign_source_4;
            Py_INCREF(var_type_shape);
            Py_XDECREF(old);
        }

    }
    // Tried code:
    // Tried code:
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_iter_arg_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_operation);
        tmp_called_name_1 = par_operation;
        CHECK_OBJECT(var_type_shape);
        tmp_args_element_name_1 = var_type_shape;
        frame_aadd76d1ac15293cca02cc13b85b7e65->m_frame.f_lineno = 584;
        tmp_iter_arg_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_iter_arg_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 584;
            type_description_1 = "oooooo";
            goto try_except_handler_4;
        }
        tmp_assign_source_5 = MAKE_ITERATOR(tmp_iter_arg_2);
        Py_DECREF(tmp_iter_arg_2);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 584;
            type_description_1 = "oooooo";
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_6 = UNPACK_NEXT(tmp_unpack_1, 0, 2);
        if (tmp_assign_source_6 == NULL) {
            if (!ERROR_OCCURRED()) {
                exception_type = PyExc_StopIteration;
                Py_INCREF(exception_type);
                exception_value = NULL;
                exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            }


            type_description_1 = "oooooo";
            exception_lineno = 584;
            goto try_except_handler_5;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_6;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_7 = UNPACK_NEXT(tmp_unpack_2, 1, 2);
        if (tmp_assign_source_7 == NULL) {
            if (!ERROR_OCCURRED()) {
                exception_type = PyExc_StopIteration;
                Py_INCREF(exception_type);
                exception_value = NULL;
                exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            }


            type_description_1 = "oooooo";
            exception_lineno = 584;
            goto try_except_handler_5;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT(tmp_iterator_name_1); assert(HAS_ITERNEXT(tmp_iterator_name_1));

        tmp_iterator_attempt = (*Py_TYPE(tmp_iterator_name_1)->tp_iternext)(tmp_iterator_name_1);

        if (likely(tmp_iterator_attempt == NULL))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if (error != NULL)
            {
                if (EXCEPTION_MATCH_BOOL_SINGLE(error, PyExc_StopIteration))
                {
                    CLEAR_ERROR_OCCURRED();
                } else {
                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

                    type_description_1 = "oooooo";
                    exception_lineno = 584;
                    goto try_except_handler_5;
                }
            }
        } else {
            Py_DECREF(tmp_iterator_attempt);

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format(PyExc_ValueError, "too many values to unpack");
#else
            PyErr_Format(PyExc_ValueError, "too many values to unpack (expected 2)");
#endif
            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

            type_description_1 = "oooooo";
            exception_lineno = 584;
            goto try_except_handler_5;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_tuple_unpack_1__source_iter);
    Py_DECREF(tmp_tuple_unpack_1__source_iter);
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_4;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_tuple_unpack_1__element_1);
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF(tmp_tuple_unpack_1__element_2);
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_3;
    // End of try:
    try_end_2:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF(exception_preserved_type_1);
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF(exception_preserved_value_1);
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF(exception_preserved_tb_1);

    if (exception_keeper_tb_3 == NULL) {
        exception_keeper_tb_3 = MAKE_TRACEBACK(frame_aadd76d1ac15293cca02cc13b85b7e65, exception_keeper_lineno_3);
    } else if (exception_keeper_lineno_3 != 0) {
        exception_keeper_tb_3 = ADD_TRACEBACK(exception_keeper_tb_3, frame_aadd76d1ac15293cca02cc13b85b7e65, exception_keeper_lineno_3);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3);
    PyException_SetTraceback(exception_keeper_value_3, (PyObject *)exception_keeper_tb_3);
    PUBLISH_EXCEPTION(&exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3);
    // Tried code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_1 = PyExc_TypeError;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 585;
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            PyObject *tmp_raise_value_1;
            PyObject *tmp_tuple_element_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            CHECK_OBJECT(var_type_shape);
            tmp_tuple_element_1 = var_type_shape;
            tmp_raise_value_1 = PyTuple_New(1);
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_raise_value_1, 0, tmp_tuple_element_1);
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_value = tmp_raise_value_1;
            exception_lineno = 586;
            RAISE_EXCEPTION_WITH_VALUE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oooooo";
            goto try_except_handler_6;
        }
        goto branch_end_1;
        branch_no_1:;
        tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        if (unlikely(tmp_result == false)) {
            exception_lineno = 583;
        }

        if (exception_tb && exception_tb->tb_frame == &frame_aadd76d1ac15293cca02cc13b85b7e65->m_frame) frame_aadd76d1ac15293cca02cc13b85b7e65->m_frame.f_lineno = exception_tb->tb_lineno;
        type_description_1 = "oooooo";
        goto try_except_handler_6;
        branch_end_1:;
    }
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape);
    return NULL;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION(exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1);
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_2;
    // End of try:
    // End of try:
    try_end_3:;
    CHECK_OBJECT((PyObject *)tmp_tuple_unpack_1__source_iter);
    Py_DECREF(tmp_tuple_unpack_1__source_iter);
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_8;
        CHECK_OBJECT(tmp_tuple_unpack_1__element_1);
        tmp_assign_source_8 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_entry;
            var_entry = tmp_assign_source_8;
            Py_INCREF(var_entry);
            Py_XDECREF(old);
        }

    }
    Py_XDECREF(tmp_tuple_unpack_1__element_1);
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_9;
        CHECK_OBJECT(tmp_tuple_unpack_1__element_2);
        tmp_assign_source_9 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var__description;
            var__description = tmp_assign_source_9;
            Py_INCREF(var__description);
            Py_XDECREF(old);
        }

    }
    Py_XDECREF(tmp_tuple_unpack_1__element_2);
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(var_entry);
        tmp_compexpr_left_2 = var_entry;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 588;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_2 = tmp_mvar_value_1;
        tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 589;
                type_description_1 = "oooooo";
                goto try_except_handler_2;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto try_return_handler_2;
        }
        branch_no_2:;
    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(var_result);
        tmp_called_instance_1 = var_result;
        CHECK_OBJECT(var_entry);
        tmp_args_element_name_2 = var_entry;
        frame_aadd76d1ac15293cca02cc13b85b7e65->m_frame.f_lineno = 591;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_add, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 591;
            type_description_1 = "oooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 582;
        type_description_1 = "oooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_4;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT((PyObject *)tmp_for_loop_1__iter_value);
    Py_DECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_args_element_name_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78726 ], 49, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 593;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_name_2 = tmp_mvar_value_3;
        CHECK_OBJECT(var_result);
        tmp_args_element_name_3 = var_result;
        frame_aadd76d1ac15293cca02cc13b85b7e65->m_frame.f_lineno = 593;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 593;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aadd76d1ac15293cca02cc13b85b7e65);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_aadd76d1ac15293cca02cc13b85b7e65);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aadd76d1ac15293cca02cc13b85b7e65);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_aadd76d1ac15293cca02cc13b85b7e65, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_aadd76d1ac15293cca02cc13b85b7e65->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_aadd76d1ac15293cca02cc13b85b7e65, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aadd76d1ac15293cca02cc13b85b7e65,
        type_description_1,
        par_self,
        par_operation,
        var_result,
        var_type_shape,
        var_entry,
        var__description
    );


    // Release cached frame.
    if (frame_aadd76d1ac15293cca02cc13b85b7e65 == cache_frame_aadd76d1ac15293cca02cc13b85b7e65) {
        Py_DECREF(frame_aadd76d1ac15293cca02cc13b85b7e65);
    }
    cache_frame_aadd76d1ac15293cca02cc13b85b7e65 = NULL;

    assertFrameObject(frame_aadd76d1ac15293cca02cc13b85b7e65);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    Py_XDECREF(var_entry);
    var_entry = NULL;

    Py_XDECREF(var__description);
    var__description = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)var_result);
    Py_DECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    Py_XDECREF(var_entry);
    var_entry = NULL;

    Py_XDECREF(var__description);
    var__description = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_operation);
    Py_DECREF(par_operation);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_operation);
    Py_DECREF(par_operation);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_e1948cbedd102577e7c86b2494befd90;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e1948cbedd102577e7c86b2494befd90 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e1948cbedd102577e7c86b2494befd90, codeobj_e1948cbedd102577e7c86b2494befd90, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_e1948cbedd102577e7c86b2494befd90 = cache_frame_e1948cbedd102577e7c86b2494befd90;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e1948cbedd102577e7c86b2494befd90);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e1948cbedd102577e7c86b2494befd90) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 596;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 597;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 600;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_e1948cbedd102577e7c86b2494befd90->m_frame.f_lineno = 600;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 600;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 605;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1948cbedd102577e7c86b2494befd90);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1948cbedd102577e7c86b2494befd90);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e1948cbedd102577e7c86b2494befd90);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e1948cbedd102577e7c86b2494befd90, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e1948cbedd102577e7c86b2494befd90->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e1948cbedd102577e7c86b2494befd90, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e1948cbedd102577e7c86b2494befd90,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_e1948cbedd102577e7c86b2494befd90 == cache_frame_e1948cbedd102577e7c86b2494befd90) {
        Py_DECREF(frame_e1948cbedd102577e7c86b2494befd90);
    }
    cache_frame_e1948cbedd102577e7c86b2494befd90 = NULL;

    assertFrameObject(frame_e1948cbedd102577e7c86b2494befd90);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_6302733a60eca15cfc35740f6b43693f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6302733a60eca15cfc35740f6b43693f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6302733a60eca15cfc35740f6b43693f, codeobj_6302733a60eca15cfc35740f6b43693f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_6302733a60eca15cfc35740f6b43693f = cache_frame_6302733a60eca15cfc35740f6b43693f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6302733a60eca15cfc35740f6b43693f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6302733a60eca15cfc35740f6b43693f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryAddShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 601;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 602;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_6302733a60eca15cfc35740f6b43693f->m_frame.f_lineno = 601;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 601;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6302733a60eca15cfc35740f6b43693f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6302733a60eca15cfc35740f6b43693f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6302733a60eca15cfc35740f6b43693f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6302733a60eca15cfc35740f6b43693f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6302733a60eca15cfc35740f6b43693f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6302733a60eca15cfc35740f6b43693f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6302733a60eca15cfc35740f6b43693f,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_6302733a60eca15cfc35740f6b43693f == cache_frame_6302733a60eca15cfc35740f6b43693f) {
        Py_DECREF(frame_6302733a60eca15cfc35740f6b43693f);
    }
    cache_frame_6302733a60eca15cfc35740f6b43693f = NULL;

    assertFrameObject(frame_6302733a60eca15cfc35740f6b43693f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_04bb67784ec2ae1c58a2b767c0192b14;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_04bb67784ec2ae1c58a2b767c0192b14 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_04bb67784ec2ae1c58a2b767c0192b14, codeobj_04bb67784ec2ae1c58a2b767c0192b14, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_04bb67784ec2ae1c58a2b767c0192b14 = cache_frame_04bb67784ec2ae1c58a2b767c0192b14;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_04bb67784ec2ae1c58a2b767c0192b14);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_04bb67784ec2ae1c58a2b767c0192b14) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 609;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 610;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 613;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_04bb67784ec2ae1c58a2b767c0192b14->m_frame.f_lineno = 613;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 613;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 618;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_04bb67784ec2ae1c58a2b767c0192b14);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_04bb67784ec2ae1c58a2b767c0192b14);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_04bb67784ec2ae1c58a2b767c0192b14);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_04bb67784ec2ae1c58a2b767c0192b14, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_04bb67784ec2ae1c58a2b767c0192b14->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_04bb67784ec2ae1c58a2b767c0192b14, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_04bb67784ec2ae1c58a2b767c0192b14,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_04bb67784ec2ae1c58a2b767c0192b14 == cache_frame_04bb67784ec2ae1c58a2b767c0192b14) {
        Py_DECREF(frame_04bb67784ec2ae1c58a2b767c0192b14);
    }
    cache_frame_04bb67784ec2ae1c58a2b767c0192b14 = NULL;

    assertFrameObject(frame_04bb67784ec2ae1c58a2b767c0192b14);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_7c85d5316288c6cbdec21410c52b261d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7c85d5316288c6cbdec21410c52b261d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7c85d5316288c6cbdec21410c52b261d, codeobj_7c85d5316288c6cbdec21410c52b261d, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_7c85d5316288c6cbdec21410c52b261d = cache_frame_7c85d5316288c6cbdec21410c52b261d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7c85d5316288c6cbdec21410c52b261d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7c85d5316288c6cbdec21410c52b261d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinarySubShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 614;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 615;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_7c85d5316288c6cbdec21410c52b261d->m_frame.f_lineno = 614;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 614;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c85d5316288c6cbdec21410c52b261d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c85d5316288c6cbdec21410c52b261d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c85d5316288c6cbdec21410c52b261d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7c85d5316288c6cbdec21410c52b261d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7c85d5316288c6cbdec21410c52b261d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7c85d5316288c6cbdec21410c52b261d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7c85d5316288c6cbdec21410c52b261d,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_7c85d5316288c6cbdec21410c52b261d == cache_frame_7c85d5316288c6cbdec21410c52b261d) {
        Py_DECREF(frame_7c85d5316288c6cbdec21410c52b261d);
    }
    cache_frame_7c85d5316288c6cbdec21410c52b261d = NULL;

    assertFrameObject(frame_7c85d5316288c6cbdec21410c52b261d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_876a1e5fe9d10bccf76f38ef397f6295;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_876a1e5fe9d10bccf76f38ef397f6295 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_876a1e5fe9d10bccf76f38ef397f6295, codeobj_876a1e5fe9d10bccf76f38ef397f6295, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_876a1e5fe9d10bccf76f38ef397f6295 = cache_frame_876a1e5fe9d10bccf76f38ef397f6295;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_876a1e5fe9d10bccf76f38ef397f6295);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_876a1e5fe9d10bccf76f38ef397f6295) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 622;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 623;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 626;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_876a1e5fe9d10bccf76f38ef397f6295->m_frame.f_lineno = 626;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 626;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 631;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_876a1e5fe9d10bccf76f38ef397f6295);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_876a1e5fe9d10bccf76f38ef397f6295);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_876a1e5fe9d10bccf76f38ef397f6295);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_876a1e5fe9d10bccf76f38ef397f6295, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_876a1e5fe9d10bccf76f38ef397f6295->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_876a1e5fe9d10bccf76f38ef397f6295, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_876a1e5fe9d10bccf76f38ef397f6295,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_876a1e5fe9d10bccf76f38ef397f6295 == cache_frame_876a1e5fe9d10bccf76f38ef397f6295) {
        Py_DECREF(frame_876a1e5fe9d10bccf76f38ef397f6295);
    }
    cache_frame_876a1e5fe9d10bccf76f38ef397f6295 = NULL;

    assertFrameObject(frame_876a1e5fe9d10bccf76f38ef397f6295);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_b2a1bf0e8cf458d869fb18b9aca64a04;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b2a1bf0e8cf458d869fb18b9aca64a04 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b2a1bf0e8cf458d869fb18b9aca64a04, codeobj_b2a1bf0e8cf458d869fb18b9aca64a04, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_b2a1bf0e8cf458d869fb18b9aca64a04 = cache_frame_b2a1bf0e8cf458d869fb18b9aca64a04;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b2a1bf0e8cf458d869fb18b9aca64a04);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b2a1bf0e8cf458d869fb18b9aca64a04) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryMultShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 627;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 628;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_b2a1bf0e8cf458d869fb18b9aca64a04->m_frame.f_lineno = 627;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 627;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2a1bf0e8cf458d869fb18b9aca64a04);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2a1bf0e8cf458d869fb18b9aca64a04);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b2a1bf0e8cf458d869fb18b9aca64a04);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b2a1bf0e8cf458d869fb18b9aca64a04, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b2a1bf0e8cf458d869fb18b9aca64a04->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b2a1bf0e8cf458d869fb18b9aca64a04, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b2a1bf0e8cf458d869fb18b9aca64a04,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_b2a1bf0e8cf458d869fb18b9aca64a04 == cache_frame_b2a1bf0e8cf458d869fb18b9aca64a04) {
        Py_DECREF(frame_b2a1bf0e8cf458d869fb18b9aca64a04);
    }
    cache_frame_b2a1bf0e8cf458d869fb18b9aca64a04 = NULL;

    assertFrameObject(frame_b2a1bf0e8cf458d869fb18b9aca64a04);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_1bd7d763ce82777b8bc18c38ea0167ca;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1bd7d763ce82777b8bc18c38ea0167ca = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1bd7d763ce82777b8bc18c38ea0167ca, codeobj_1bd7d763ce82777b8bc18c38ea0167ca, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_1bd7d763ce82777b8bc18c38ea0167ca = cache_frame_1bd7d763ce82777b8bc18c38ea0167ca;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1bd7d763ce82777b8bc18c38ea0167ca);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1bd7d763ce82777b8bc18c38ea0167ca) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 635;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 636;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 639;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_1bd7d763ce82777b8bc18c38ea0167ca->m_frame.f_lineno = 639;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 639;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 644;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1bd7d763ce82777b8bc18c38ea0167ca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1bd7d763ce82777b8bc18c38ea0167ca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1bd7d763ce82777b8bc18c38ea0167ca);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1bd7d763ce82777b8bc18c38ea0167ca, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1bd7d763ce82777b8bc18c38ea0167ca->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1bd7d763ce82777b8bc18c38ea0167ca, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1bd7d763ce82777b8bc18c38ea0167ca,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_1bd7d763ce82777b8bc18c38ea0167ca == cache_frame_1bd7d763ce82777b8bc18c38ea0167ca) {
        Py_DECREF(frame_1bd7d763ce82777b8bc18c38ea0167ca);
    }
    cache_frame_1bd7d763ce82777b8bc18c38ea0167ca = NULL;

    assertFrameObject(frame_1bd7d763ce82777b8bc18c38ea0167ca);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_8cdd1cf02b6e91978eb12c28eb60bd5b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8cdd1cf02b6e91978eb12c28eb60bd5b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8cdd1cf02b6e91978eb12c28eb60bd5b, codeobj_8cdd1cf02b6e91978eb12c28eb60bd5b, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_8cdd1cf02b6e91978eb12c28eb60bd5b = cache_frame_8cdd1cf02b6e91978eb12c28eb60bd5b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8cdd1cf02b6e91978eb12c28eb60bd5b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8cdd1cf02b6e91978eb12c28eb60bd5b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryFloorDivShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 640;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 641;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_8cdd1cf02b6e91978eb12c28eb60bd5b->m_frame.f_lineno = 640;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 640;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8cdd1cf02b6e91978eb12c28eb60bd5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8cdd1cf02b6e91978eb12c28eb60bd5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8cdd1cf02b6e91978eb12c28eb60bd5b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8cdd1cf02b6e91978eb12c28eb60bd5b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8cdd1cf02b6e91978eb12c28eb60bd5b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8cdd1cf02b6e91978eb12c28eb60bd5b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8cdd1cf02b6e91978eb12c28eb60bd5b,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_8cdd1cf02b6e91978eb12c28eb60bd5b == cache_frame_8cdd1cf02b6e91978eb12c28eb60bd5b) {
        Py_DECREF(frame_8cdd1cf02b6e91978eb12c28eb60bd5b);
    }
    cache_frame_8cdd1cf02b6e91978eb12c28eb60bd5b = NULL;

    assertFrameObject(frame_8cdd1cf02b6e91978eb12c28eb60bd5b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_16f3995a02c0e9c79caad0e3968c3371;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_16f3995a02c0e9c79caad0e3968c3371 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_16f3995a02c0e9c79caad0e3968c3371, codeobj_16f3995a02c0e9c79caad0e3968c3371, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_16f3995a02c0e9c79caad0e3968c3371 = cache_frame_16f3995a02c0e9c79caad0e3968c3371;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_16f3995a02c0e9c79caad0e3968c3371);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_16f3995a02c0e9c79caad0e3968c3371) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 648;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 649;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 652;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_16f3995a02c0e9c79caad0e3968c3371->m_frame.f_lineno = 652;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 652;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 657;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_16f3995a02c0e9c79caad0e3968c3371);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_16f3995a02c0e9c79caad0e3968c3371);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_16f3995a02c0e9c79caad0e3968c3371);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_16f3995a02c0e9c79caad0e3968c3371, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_16f3995a02c0e9c79caad0e3968c3371->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_16f3995a02c0e9c79caad0e3968c3371, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_16f3995a02c0e9c79caad0e3968c3371,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_16f3995a02c0e9c79caad0e3968c3371 == cache_frame_16f3995a02c0e9c79caad0e3968c3371) {
        Py_DECREF(frame_16f3995a02c0e9c79caad0e3968c3371);
    }
    cache_frame_16f3995a02c0e9c79caad0e3968c3371 = NULL;

    assertFrameObject(frame_16f3995a02c0e9c79caad0e3968c3371);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_b8bb20277bc146b9f2d9eb297a44862e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b8bb20277bc146b9f2d9eb297a44862e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b8bb20277bc146b9f2d9eb297a44862e, codeobj_b8bb20277bc146b9f2d9eb297a44862e, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_b8bb20277bc146b9f2d9eb297a44862e = cache_frame_b8bb20277bc146b9f2d9eb297a44862e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b8bb20277bc146b9f2d9eb297a44862e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b8bb20277bc146b9f2d9eb297a44862e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryOldDivShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 653;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 654;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_b8bb20277bc146b9f2d9eb297a44862e->m_frame.f_lineno = 653;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 653;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b8bb20277bc146b9f2d9eb297a44862e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b8bb20277bc146b9f2d9eb297a44862e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b8bb20277bc146b9f2d9eb297a44862e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b8bb20277bc146b9f2d9eb297a44862e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b8bb20277bc146b9f2d9eb297a44862e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b8bb20277bc146b9f2d9eb297a44862e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b8bb20277bc146b9f2d9eb297a44862e,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_b8bb20277bc146b9f2d9eb297a44862e == cache_frame_b8bb20277bc146b9f2d9eb297a44862e) {
        Py_DECREF(frame_b8bb20277bc146b9f2d9eb297a44862e);
    }
    cache_frame_b8bb20277bc146b9f2d9eb297a44862e = NULL;

    assertFrameObject(frame_b8bb20277bc146b9f2d9eb297a44862e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_8dd75cae359f2182c58f87b80393d24e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_8dd75cae359f2182c58f87b80393d24e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8dd75cae359f2182c58f87b80393d24e, codeobj_8dd75cae359f2182c58f87b80393d24e, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_8dd75cae359f2182c58f87b80393d24e = cache_frame_8dd75cae359f2182c58f87b80393d24e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8dd75cae359f2182c58f87b80393d24e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8dd75cae359f2182c58f87b80393d24e) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 661;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 662;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 665;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_8dd75cae359f2182c58f87b80393d24e->m_frame.f_lineno = 665;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 665;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 670;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8dd75cae359f2182c58f87b80393d24e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8dd75cae359f2182c58f87b80393d24e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8dd75cae359f2182c58f87b80393d24e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8dd75cae359f2182c58f87b80393d24e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8dd75cae359f2182c58f87b80393d24e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8dd75cae359f2182c58f87b80393d24e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8dd75cae359f2182c58f87b80393d24e,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_8dd75cae359f2182c58f87b80393d24e == cache_frame_8dd75cae359f2182c58f87b80393d24e) {
        Py_DECREF(frame_8dd75cae359f2182c58f87b80393d24e);
    }
    cache_frame_8dd75cae359f2182c58f87b80393d24e = NULL;

    assertFrameObject(frame_8dd75cae359f2182c58f87b80393d24e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_24e64e080f977ec2c688592a89cab564;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_24e64e080f977ec2c688592a89cab564 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_24e64e080f977ec2c688592a89cab564, codeobj_24e64e080f977ec2c688592a89cab564, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_24e64e080f977ec2c688592a89cab564 = cache_frame_24e64e080f977ec2c688592a89cab564;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_24e64e080f977ec2c688592a89cab564);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_24e64e080f977ec2c688592a89cab564) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryTrueDivShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 666;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 667;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_24e64e080f977ec2c688592a89cab564->m_frame.f_lineno = 666;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 666;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e64e080f977ec2c688592a89cab564);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e64e080f977ec2c688592a89cab564);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_24e64e080f977ec2c688592a89cab564);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_24e64e080f977ec2c688592a89cab564, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_24e64e080f977ec2c688592a89cab564->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_24e64e080f977ec2c688592a89cab564, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_24e64e080f977ec2c688592a89cab564,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_24e64e080f977ec2c688592a89cab564 == cache_frame_24e64e080f977ec2c688592a89cab564) {
        Py_DECREF(frame_24e64e080f977ec2c688592a89cab564);
    }
    cache_frame_24e64e080f977ec2c688592a89cab564 = NULL;

    assertFrameObject(frame_24e64e080f977ec2c688592a89cab564);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_a03bf40e3eb8edc8605a7e62ecdd3212;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a03bf40e3eb8edc8605a7e62ecdd3212 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a03bf40e3eb8edc8605a7e62ecdd3212, codeobj_a03bf40e3eb8edc8605a7e62ecdd3212, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_a03bf40e3eb8edc8605a7e62ecdd3212 = cache_frame_a03bf40e3eb8edc8605a7e62ecdd3212;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a03bf40e3eb8edc8605a7e62ecdd3212);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a03bf40e3eb8edc8605a7e62ecdd3212) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 674;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 675;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 678;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_a03bf40e3eb8edc8605a7e62ecdd3212->m_frame.f_lineno = 678;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 678;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 683;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a03bf40e3eb8edc8605a7e62ecdd3212);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a03bf40e3eb8edc8605a7e62ecdd3212);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a03bf40e3eb8edc8605a7e62ecdd3212);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a03bf40e3eb8edc8605a7e62ecdd3212, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a03bf40e3eb8edc8605a7e62ecdd3212->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a03bf40e3eb8edc8605a7e62ecdd3212, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a03bf40e3eb8edc8605a7e62ecdd3212,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_a03bf40e3eb8edc8605a7e62ecdd3212 == cache_frame_a03bf40e3eb8edc8605a7e62ecdd3212) {
        Py_DECREF(frame_a03bf40e3eb8edc8605a7e62ecdd3212);
    }
    cache_frame_a03bf40e3eb8edc8605a7e62ecdd3212 = NULL;

    assertFrameObject(frame_a03bf40e3eb8edc8605a7e62ecdd3212);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_4f7853b32d446d492871a3092798aa20;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_4f7853b32d446d492871a3092798aa20 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4f7853b32d446d492871a3092798aa20, codeobj_4f7853b32d446d492871a3092798aa20, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_4f7853b32d446d492871a3092798aa20 = cache_frame_4f7853b32d446d492871a3092798aa20;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4f7853b32d446d492871a3092798aa20);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4f7853b32d446d492871a3092798aa20) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryModShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 680;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_4f7853b32d446d492871a3092798aa20->m_frame.f_lineno = 679;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 679;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7853b32d446d492871a3092798aa20);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7853b32d446d492871a3092798aa20);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f7853b32d446d492871a3092798aa20);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4f7853b32d446d492871a3092798aa20, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4f7853b32d446d492871a3092798aa20->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4f7853b32d446d492871a3092798aa20, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f7853b32d446d492871a3092798aa20,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_4f7853b32d446d492871a3092798aa20 == cache_frame_4f7853b32d446d492871a3092798aa20) {
        Py_DECREF(frame_4f7853b32d446d492871a3092798aa20);
    }
    cache_frame_4f7853b32d446d492871a3092798aa20 = NULL;

    assertFrameObject(frame_4f7853b32d446d492871a3092798aa20);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_9a1cd419ff5f7369aad29af0cbf529dc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_9a1cd419ff5f7369aad29af0cbf529dc = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9a1cd419ff5f7369aad29af0cbf529dc, codeobj_9a1cd419ff5f7369aad29af0cbf529dc, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_9a1cd419ff5f7369aad29af0cbf529dc = cache_frame_9a1cd419ff5f7369aad29af0cbf529dc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9a1cd419ff5f7369aad29af0cbf529dc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9a1cd419ff5f7369aad29af0cbf529dc) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 687;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 688;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 691;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_9a1cd419ff5f7369aad29af0cbf529dc->m_frame.f_lineno = 691;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 691;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 696;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9a1cd419ff5f7369aad29af0cbf529dc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9a1cd419ff5f7369aad29af0cbf529dc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9a1cd419ff5f7369aad29af0cbf529dc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9a1cd419ff5f7369aad29af0cbf529dc, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9a1cd419ff5f7369aad29af0cbf529dc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9a1cd419ff5f7369aad29af0cbf529dc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9a1cd419ff5f7369aad29af0cbf529dc,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_9a1cd419ff5f7369aad29af0cbf529dc == cache_frame_9a1cd419ff5f7369aad29af0cbf529dc) {
        Py_DECREF(frame_9a1cd419ff5f7369aad29af0cbf529dc);
    }
    cache_frame_9a1cd419ff5f7369aad29af0cbf529dc = NULL;

    assertFrameObject(frame_9a1cd419ff5f7369aad29af0cbf529dc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd, codeobj_cc89ba8a3dc4ca5e9a8187a8b1fe39dd, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd = cache_frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryPowShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 692;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 693;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd->m_frame.f_lineno = 692;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 692;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd == cache_frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd) {
        Py_DECREF(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd);
    }
    cache_frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd = NULL;

    assertFrameObject(frame_cc89ba8a3dc4ca5e9a8187a8b1fe39dd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_3dd45ca70afc01291f9356164bd33100;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_3dd45ca70afc01291f9356164bd33100 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3dd45ca70afc01291f9356164bd33100, codeobj_3dd45ca70afc01291f9356164bd33100, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3dd45ca70afc01291f9356164bd33100 = cache_frame_3dd45ca70afc01291f9356164bd33100;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3dd45ca70afc01291f9356164bd33100);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3dd45ca70afc01291f9356164bd33100) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 700;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 701;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 704;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_3dd45ca70afc01291f9356164bd33100->m_frame.f_lineno = 704;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 704;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 709;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dd45ca70afc01291f9356164bd33100);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dd45ca70afc01291f9356164bd33100);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dd45ca70afc01291f9356164bd33100);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3dd45ca70afc01291f9356164bd33100, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3dd45ca70afc01291f9356164bd33100->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3dd45ca70afc01291f9356164bd33100, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3dd45ca70afc01291f9356164bd33100,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_3dd45ca70afc01291f9356164bd33100 == cache_frame_3dd45ca70afc01291f9356164bd33100) {
        Py_DECREF(frame_3dd45ca70afc01291f9356164bd33100);
    }
    cache_frame_3dd45ca70afc01291f9356164bd33100 = NULL;

    assertFrameObject(frame_3dd45ca70afc01291f9356164bd33100);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_18bda4c64265e404b7aaf22dc15b2d12;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_18bda4c64265e404b7aaf22dc15b2d12 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_18bda4c64265e404b7aaf22dc15b2d12, codeobj_18bda4c64265e404b7aaf22dc15b2d12, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_18bda4c64265e404b7aaf22dc15b2d12 = cache_frame_18bda4c64265e404b7aaf22dc15b2d12;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_18bda4c64265e404b7aaf22dc15b2d12);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_18bda4c64265e404b7aaf22dc15b2d12) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryLShiftShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 705;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 706;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_18bda4c64265e404b7aaf22dc15b2d12->m_frame.f_lineno = 705;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 705;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_18bda4c64265e404b7aaf22dc15b2d12);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_18bda4c64265e404b7aaf22dc15b2d12);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_18bda4c64265e404b7aaf22dc15b2d12);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_18bda4c64265e404b7aaf22dc15b2d12, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_18bda4c64265e404b7aaf22dc15b2d12->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_18bda4c64265e404b7aaf22dc15b2d12, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_18bda4c64265e404b7aaf22dc15b2d12,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_18bda4c64265e404b7aaf22dc15b2d12 == cache_frame_18bda4c64265e404b7aaf22dc15b2d12) {
        Py_DECREF(frame_18bda4c64265e404b7aaf22dc15b2d12);
    }
    cache_frame_18bda4c64265e404b7aaf22dc15b2d12 = NULL;

    assertFrameObject(frame_18bda4c64265e404b7aaf22dc15b2d12);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_3645059692b6a687f1cc693a5e2a7992;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_3645059692b6a687f1cc693a5e2a7992 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3645059692b6a687f1cc693a5e2a7992, codeobj_3645059692b6a687f1cc693a5e2a7992, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3645059692b6a687f1cc693a5e2a7992 = cache_frame_3645059692b6a687f1cc693a5e2a7992;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3645059692b6a687f1cc693a5e2a7992);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3645059692b6a687f1cc693a5e2a7992) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 713;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 714;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 717;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_3645059692b6a687f1cc693a5e2a7992->m_frame.f_lineno = 717;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 717;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 722;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3645059692b6a687f1cc693a5e2a7992);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3645059692b6a687f1cc693a5e2a7992);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3645059692b6a687f1cc693a5e2a7992);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3645059692b6a687f1cc693a5e2a7992, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3645059692b6a687f1cc693a5e2a7992->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3645059692b6a687f1cc693a5e2a7992, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3645059692b6a687f1cc693a5e2a7992,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_3645059692b6a687f1cc693a5e2a7992 == cache_frame_3645059692b6a687f1cc693a5e2a7992) {
        Py_DECREF(frame_3645059692b6a687f1cc693a5e2a7992);
    }
    cache_frame_3645059692b6a687f1cc693a5e2a7992 = NULL;

    assertFrameObject(frame_3645059692b6a687f1cc693a5e2a7992);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_0deae47aea120f40c053e988347a77a8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0deae47aea120f40c053e988347a77a8 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0deae47aea120f40c053e988347a77a8, codeobj_0deae47aea120f40c053e988347a77a8, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_0deae47aea120f40c053e988347a77a8 = cache_frame_0deae47aea120f40c053e988347a77a8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0deae47aea120f40c053e988347a77a8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0deae47aea120f40c053e988347a77a8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryRShiftShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 718;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 719;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_0deae47aea120f40c053e988347a77a8->m_frame.f_lineno = 718;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 718;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0deae47aea120f40c053e988347a77a8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0deae47aea120f40c053e988347a77a8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0deae47aea120f40c053e988347a77a8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0deae47aea120f40c053e988347a77a8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0deae47aea120f40c053e988347a77a8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0deae47aea120f40c053e988347a77a8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0deae47aea120f40c053e988347a77a8,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_0deae47aea120f40c053e988347a77a8 == cache_frame_0deae47aea120f40c053e988347a77a8) {
        Py_DECREF(frame_0deae47aea120f40c053e988347a77a8);
    }
    cache_frame_0deae47aea120f40c053e988347a77a8 = NULL;

    assertFrameObject(frame_0deae47aea120f40c053e988347a77a8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_87f148f9ab85354cc524c43c25996583;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_87f148f9ab85354cc524c43c25996583 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_87f148f9ab85354cc524c43c25996583, codeobj_87f148f9ab85354cc524c43c25996583, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_87f148f9ab85354cc524c43c25996583 = cache_frame_87f148f9ab85354cc524c43c25996583;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_87f148f9ab85354cc524c43c25996583);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_87f148f9ab85354cc524c43c25996583) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 726;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 727;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 730;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_87f148f9ab85354cc524c43c25996583->m_frame.f_lineno = 730;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 730;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 735;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_87f148f9ab85354cc524c43c25996583);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_87f148f9ab85354cc524c43c25996583);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_87f148f9ab85354cc524c43c25996583);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_87f148f9ab85354cc524c43c25996583, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_87f148f9ab85354cc524c43c25996583->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_87f148f9ab85354cc524c43c25996583, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_87f148f9ab85354cc524c43c25996583,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_87f148f9ab85354cc524c43c25996583 == cache_frame_87f148f9ab85354cc524c43c25996583) {
        Py_DECREF(frame_87f148f9ab85354cc524c43c25996583);
    }
    cache_frame_87f148f9ab85354cc524c43c25996583 = NULL;

    assertFrameObject(frame_87f148f9ab85354cc524c43c25996583);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_f95de718f13fcea583daf1efacdefdb0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_f95de718f13fcea583daf1efacdefdb0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f95de718f13fcea583daf1efacdefdb0, codeobj_f95de718f13fcea583daf1efacdefdb0, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_f95de718f13fcea583daf1efacdefdb0 = cache_frame_f95de718f13fcea583daf1efacdefdb0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f95de718f13fcea583daf1efacdefdb0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f95de718f13fcea583daf1efacdefdb0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryBitOrShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 731;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 732;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_f95de718f13fcea583daf1efacdefdb0->m_frame.f_lineno = 731;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 731;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f95de718f13fcea583daf1efacdefdb0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f95de718f13fcea583daf1efacdefdb0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f95de718f13fcea583daf1efacdefdb0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f95de718f13fcea583daf1efacdefdb0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f95de718f13fcea583daf1efacdefdb0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f95de718f13fcea583daf1efacdefdb0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f95de718f13fcea583daf1efacdefdb0,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_f95de718f13fcea583daf1efacdefdb0 == cache_frame_f95de718f13fcea583daf1efacdefdb0) {
        Py_DECREF(frame_f95de718f13fcea583daf1efacdefdb0);
    }
    cache_frame_f95de718f13fcea583daf1efacdefdb0 = NULL;

    assertFrameObject(frame_f95de718f13fcea583daf1efacdefdb0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_fb6c31fd0fb939d2e4c0c9e55ad06301;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_fb6c31fd0fb939d2e4c0c9e55ad06301 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_fb6c31fd0fb939d2e4c0c9e55ad06301, codeobj_fb6c31fd0fb939d2e4c0c9e55ad06301, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_fb6c31fd0fb939d2e4c0c9e55ad06301 = cache_frame_fb6c31fd0fb939d2e4c0c9e55ad06301;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fb6c31fd0fb939d2e4c0c9e55ad06301);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fb6c31fd0fb939d2e4c0c9e55ad06301) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 739;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 740;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 743;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_fb6c31fd0fb939d2e4c0c9e55ad06301->m_frame.f_lineno = 743;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 743;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 748;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fb6c31fd0fb939d2e4c0c9e55ad06301);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fb6c31fd0fb939d2e4c0c9e55ad06301);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fb6c31fd0fb939d2e4c0c9e55ad06301);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fb6c31fd0fb939d2e4c0c9e55ad06301, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fb6c31fd0fb939d2e4c0c9e55ad06301->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fb6c31fd0fb939d2e4c0c9e55ad06301, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_fb6c31fd0fb939d2e4c0c9e55ad06301,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_fb6c31fd0fb939d2e4c0c9e55ad06301 == cache_frame_fb6c31fd0fb939d2e4c0c9e55ad06301) {
        Py_DECREF(frame_fb6c31fd0fb939d2e4c0c9e55ad06301);
    }
    cache_frame_fb6c31fd0fb939d2e4c0c9e55ad06301 = NULL;

    assertFrameObject(frame_fb6c31fd0fb939d2e4c0c9e55ad06301);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_76ee1733c9e71f1b5d4cbcef34146606;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_76ee1733c9e71f1b5d4cbcef34146606 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_76ee1733c9e71f1b5d4cbcef34146606, codeobj_76ee1733c9e71f1b5d4cbcef34146606, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_76ee1733c9e71f1b5d4cbcef34146606 = cache_frame_76ee1733c9e71f1b5d4cbcef34146606;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_76ee1733c9e71f1b5d4cbcef34146606);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_76ee1733c9e71f1b5d4cbcef34146606) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryBitAndShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 744;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 745;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_76ee1733c9e71f1b5d4cbcef34146606->m_frame.f_lineno = 744;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 744;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_76ee1733c9e71f1b5d4cbcef34146606);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_76ee1733c9e71f1b5d4cbcef34146606);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_76ee1733c9e71f1b5d4cbcef34146606);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_76ee1733c9e71f1b5d4cbcef34146606, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_76ee1733c9e71f1b5d4cbcef34146606->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_76ee1733c9e71f1b5d4cbcef34146606, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_76ee1733c9e71f1b5d4cbcef34146606,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_76ee1733c9e71f1b5d4cbcef34146606 == cache_frame_76ee1733c9e71f1b5d4cbcef34146606) {
        Py_DECREF(frame_76ee1733c9e71f1b5d4cbcef34146606);
    }
    cache_frame_76ee1733c9e71f1b5d4cbcef34146606 = NULL;

    assertFrameObject(frame_76ee1733c9e71f1b5d4cbcef34146606);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_2ff7ba750e4d1ecf070df3a4a0896ed0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2ff7ba750e4d1ecf070df3a4a0896ed0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2ff7ba750e4d1ecf070df3a4a0896ed0, codeobj_2ff7ba750e4d1ecf070df3a4a0896ed0, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_2ff7ba750e4d1ecf070df3a4a0896ed0 = cache_frame_2ff7ba750e4d1ecf070df3a4a0896ed0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2ff7ba750e4d1ecf070df3a4a0896ed0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2ff7ba750e4d1ecf070df3a4a0896ed0) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 752;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 753;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 756;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_2ff7ba750e4d1ecf070df3a4a0896ed0->m_frame.f_lineno = 756;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 756;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 761;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ff7ba750e4d1ecf070df3a4a0896ed0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ff7ba750e4d1ecf070df3a4a0896ed0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ff7ba750e4d1ecf070df3a4a0896ed0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2ff7ba750e4d1ecf070df3a4a0896ed0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2ff7ba750e4d1ecf070df3a4a0896ed0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2ff7ba750e4d1ecf070df3a4a0896ed0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2ff7ba750e4d1ecf070df3a4a0896ed0,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_2ff7ba750e4d1ecf070df3a4a0896ed0 == cache_frame_2ff7ba750e4d1ecf070df3a4a0896ed0) {
        Py_DECREF(frame_2ff7ba750e4d1ecf070df3a4a0896ed0);
    }
    cache_frame_2ff7ba750e4d1ecf070df3a4a0896ed0 = NULL;

    assertFrameObject(frame_2ff7ba750e4d1ecf070df3a4a0896ed0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_d26a4ad1ef1a2f2b0ab74283bf91d39c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d26a4ad1ef1a2f2b0ab74283bf91d39c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d26a4ad1ef1a2f2b0ab74283bf91d39c, codeobj_d26a4ad1ef1a2f2b0ab74283bf91d39c, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_d26a4ad1ef1a2f2b0ab74283bf91d39c = cache_frame_d26a4ad1ef1a2f2b0ab74283bf91d39c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryBitXorShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 757;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 758;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_d26a4ad1ef1a2f2b0ab74283bf91d39c->m_frame.f_lineno = 757;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 757;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d26a4ad1ef1a2f2b0ab74283bf91d39c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d26a4ad1ef1a2f2b0ab74283bf91d39c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d26a4ad1ef1a2f2b0ab74283bf91d39c,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_d26a4ad1ef1a2f2b0ab74283bf91d39c == cache_frame_d26a4ad1ef1a2f2b0ab74283bf91d39c) {
        Py_DECREF(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c);
    }
    cache_frame_d26a4ad1ef1a2f2b0ab74283bf91d39c = NULL;

    assertFrameObject(frame_d26a4ad1ef1a2f2b0ab74283bf91d39c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_80ca9f6e6aceaa2ee897274b7bf46769;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_80ca9f6e6aceaa2ee897274b7bf46769 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_80ca9f6e6aceaa2ee897274b7bf46769, codeobj_80ca9f6e6aceaa2ee897274b7bf46769, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_80ca9f6e6aceaa2ee897274b7bf46769 = cache_frame_80ca9f6e6aceaa2ee897274b7bf46769;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_80ca9f6e6aceaa2ee897274b7bf46769);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_80ca9f6e6aceaa2ee897274b7bf46769) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 765;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 766;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 769;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_80ca9f6e6aceaa2ee897274b7bf46769->m_frame.f_lineno = 769;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 769;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 774;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80ca9f6e6aceaa2ee897274b7bf46769);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_80ca9f6e6aceaa2ee897274b7bf46769);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_80ca9f6e6aceaa2ee897274b7bf46769);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_80ca9f6e6aceaa2ee897274b7bf46769, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_80ca9f6e6aceaa2ee897274b7bf46769->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_80ca9f6e6aceaa2ee897274b7bf46769, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_80ca9f6e6aceaa2ee897274b7bf46769,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_80ca9f6e6aceaa2ee897274b7bf46769 == cache_frame_80ca9f6e6aceaa2ee897274b7bf46769) {
        Py_DECREF(frame_80ca9f6e6aceaa2ee897274b7bf46769);
    }
    cache_frame_80ca9f6e6aceaa2ee897274b7bf46769 = NULL;

    assertFrameObject(frame_80ca9f6e6aceaa2ee897274b7bf46769);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_26bc50f31cbb49207bb35be4ca0587b0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_26bc50f31cbb49207bb35be4ca0587b0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_26bc50f31cbb49207bb35be4ca0587b0, codeobj_26bc50f31cbb49207bb35be4ca0587b0, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_26bc50f31cbb49207bb35be4ca0587b0 = cache_frame_26bc50f31cbb49207bb35be4ca0587b0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_26bc50f31cbb49207bb35be4ca0587b0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_26bc50f31cbb49207bb35be4ca0587b0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryMatMultShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 770;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 771;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_26bc50f31cbb49207bb35be4ca0587b0->m_frame.f_lineno = 770;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 770;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_26bc50f31cbb49207bb35be4ca0587b0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_26bc50f31cbb49207bb35be4ca0587b0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_26bc50f31cbb49207bb35be4ca0587b0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_26bc50f31cbb49207bb35be4ca0587b0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_26bc50f31cbb49207bb35be4ca0587b0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_26bc50f31cbb49207bb35be4ca0587b0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_26bc50f31cbb49207bb35be4ca0587b0,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_26bc50f31cbb49207bb35be4ca0587b0 == cache_frame_26bc50f31cbb49207bb35be4ca0587b0) {
        Py_DECREF(frame_26bc50f31cbb49207bb35be4ca0587b0);
    }
    cache_frame_26bc50f31cbb49207bb35be4ca0587b0 = NULL;

    assertFrameObject(frame_26bc50f31cbb49207bb35be4ca0587b0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_5cf72a68714c34d1eca72117e53cd4c7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_5cf72a68714c34d1eca72117e53cd4c7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5cf72a68714c34d1eca72117e53cd4c7, codeobj_5cf72a68714c34d1eca72117e53cd4c7, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_5cf72a68714c34d1eca72117e53cd4c7 = cache_frame_5cf72a68714c34d1eca72117e53cd4c7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5cf72a68714c34d1eca72117e53cd4c7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5cf72a68714c34d1eca72117e53cd4c7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 778;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 779;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        goto branch_end_1;
        branch_no_1:;
        {
            PyObject *tmp_tuple_element_1;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_1;
            PyObject *tmp_kw_name_1;
            PyObject *tmp_dict_key_1;
            PyObject *tmp_dict_value_1;
            PyObject *tmp_mvar_value_3;
            CHECK_OBJECT(par_self);
            tmp_source_name_1 = par_self;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectInitialShape);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 782;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_dict_key_1 = const_str_plain_operation;
            tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape$$$function_1_lambda();

            ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
            Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


            tmp_kw_name_1 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
            Py_DECREF(tmp_dict_value_1);
            assert(!(tmp_res != 0));
            frame_5cf72a68714c34d1eca72117e53cd4c7->m_frame.f_lineno = 782;
            tmp_tuple_element_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);
            if (tmp_tuple_element_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 782;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_1);
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

            if (unlikely(tmp_mvar_value_3 == NULL)) {
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
            }

            if (tmp_mvar_value_3 == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 787;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_1 = tmp_mvar_value_3;
            Py_INCREF(tmp_tuple_element_1);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_1);
            goto frame_return_exit_1;
        }
        branch_end_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5cf72a68714c34d1eca72117e53cd4c7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5cf72a68714c34d1eca72117e53cd4c7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5cf72a68714c34d1eca72117e53cd4c7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5cf72a68714c34d1eca72117e53cd4c7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5cf72a68714c34d1eca72117e53cd4c7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5cf72a68714c34d1eca72117e53cd4c7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5cf72a68714c34d1eca72117e53cd4c7,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_5cf72a68714c34d1eca72117e53cd4c7 == cache_frame_5cf72a68714c34d1eca72117e53cd4c7) {
        Py_DECREF(frame_5cf72a68714c34d1eca72117e53cd4c7);
    }
    cache_frame_5cf72a68714c34d1eca72117e53cd4c7 = NULL;

    assertFrameObject(frame_5cf72a68714c34d1eca72117e53cd4c7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_0333d7f7a3f0e07402c652ec964b3d26;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_0333d7f7a3f0e07402c652ec964b3d26 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0333d7f7a3f0e07402c652ec964b3d26, codeobj_0333d7f7a3f0e07402c652ec964b3d26, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_0333d7f7a3f0e07402c652ec964b3d26 = cache_frame_0333d7f7a3f0e07402c652ec964b3d26;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0333d7f7a3f0e07402c652ec964b3d26);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0333d7f7a3f0e07402c652ec964b3d26) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getComparisonLtShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 783;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 784;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_0333d7f7a3f0e07402c652ec964b3d26->m_frame.f_lineno = 783;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 783;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0333d7f7a3f0e07402c652ec964b3d26);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0333d7f7a3f0e07402c652ec964b3d26);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0333d7f7a3f0e07402c652ec964b3d26);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0333d7f7a3f0e07402c652ec964b3d26, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0333d7f7a3f0e07402c652ec964b3d26->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0333d7f7a3f0e07402c652ec964b3d26, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0333d7f7a3f0e07402c652ec964b3d26,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_0333d7f7a3f0e07402c652ec964b3d26 == cache_frame_0333d7f7a3f0e07402c652ec964b3d26) {
        Py_DECREF(frame_0333d7f7a3f0e07402c652ec964b3d26);
    }
    cache_frame_0333d7f7a3f0e07402c652ec964b3d26 = NULL;

    assertFrameObject(frame_0333d7f7a3f0e07402c652ec964b3d26);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_86_getComparisonLteShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_aab3111a94fa8100bd8f5d5fb097a9d7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_aab3111a94fa8100bd8f5d5fb097a9d7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_aab3111a94fa8100bd8f5d5fb097a9d7, codeobj_aab3111a94fa8100bd8f5d5fb097a9d7, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_aab3111a94fa8100bd8f5d5fb097a9d7 = cache_frame_aab3111a94fa8100bd8f5d5fb097a9d7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_aab3111a94fa8100bd8f5d5fb097a9d7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_aab3111a94fa8100bd8f5d5fb097a9d7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_aab3111a94fa8100bd8f5d5fb097a9d7->m_frame.f_lineno = 791;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 791;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aab3111a94fa8100bd8f5d5fb097a9d7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_aab3111a94fa8100bd8f5d5fb097a9d7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aab3111a94fa8100bd8f5d5fb097a9d7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_aab3111a94fa8100bd8f5d5fb097a9d7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_aab3111a94fa8100bd8f5d5fb097a9d7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_aab3111a94fa8100bd8f5d5fb097a9d7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_aab3111a94fa8100bd8f5d5fb097a9d7,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_aab3111a94fa8100bd8f5d5fb097a9d7 == cache_frame_aab3111a94fa8100bd8f5d5fb097a9d7) {
        Py_DECREF(frame_aab3111a94fa8100bd8f5d5fb097a9d7);
    }
    cache_frame_aab3111a94fa8100bd8f5d5fb097a9d7 = NULL;

    assertFrameObject(frame_aab3111a94fa8100bd8f5d5fb097a9d7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_86_getComparisonLteShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_87_getComparisonGtShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_03b6369ad1eae0faab06dedb33f72ed3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_03b6369ad1eae0faab06dedb33f72ed3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_03b6369ad1eae0faab06dedb33f72ed3, codeobj_03b6369ad1eae0faab06dedb33f72ed3, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_03b6369ad1eae0faab06dedb33f72ed3 = cache_frame_03b6369ad1eae0faab06dedb33f72ed3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_03b6369ad1eae0faab06dedb33f72ed3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_03b6369ad1eae0faab06dedb33f72ed3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_03b6369ad1eae0faab06dedb33f72ed3->m_frame.f_lineno = 794;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 794;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_03b6369ad1eae0faab06dedb33f72ed3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_03b6369ad1eae0faab06dedb33f72ed3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_03b6369ad1eae0faab06dedb33f72ed3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_03b6369ad1eae0faab06dedb33f72ed3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_03b6369ad1eae0faab06dedb33f72ed3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_03b6369ad1eae0faab06dedb33f72ed3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_03b6369ad1eae0faab06dedb33f72ed3,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_03b6369ad1eae0faab06dedb33f72ed3 == cache_frame_03b6369ad1eae0faab06dedb33f72ed3) {
        Py_DECREF(frame_03b6369ad1eae0faab06dedb33f72ed3);
    }
    cache_frame_03b6369ad1eae0faab06dedb33f72ed3 = NULL;

    assertFrameObject(frame_03b6369ad1eae0faab06dedb33f72ed3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_87_getComparisonGtShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_88_getComparisonGteShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_daf8c11419498c5f135c12cffe0042c9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_daf8c11419498c5f135c12cffe0042c9 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_daf8c11419498c5f135c12cffe0042c9, codeobj_daf8c11419498c5f135c12cffe0042c9, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_daf8c11419498c5f135c12cffe0042c9 = cache_frame_daf8c11419498c5f135c12cffe0042c9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_daf8c11419498c5f135c12cffe0042c9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_daf8c11419498c5f135c12cffe0042c9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_daf8c11419498c5f135c12cffe0042c9->m_frame.f_lineno = 797;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 797;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_daf8c11419498c5f135c12cffe0042c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_daf8c11419498c5f135c12cffe0042c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_daf8c11419498c5f135c12cffe0042c9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_daf8c11419498c5f135c12cffe0042c9, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_daf8c11419498c5f135c12cffe0042c9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_daf8c11419498c5f135c12cffe0042c9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_daf8c11419498c5f135c12cffe0042c9,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_daf8c11419498c5f135c12cffe0042c9 == cache_frame_daf8c11419498c5f135c12cffe0042c9) {
        Py_DECREF(frame_daf8c11419498c5f135c12cffe0042c9);
    }
    cache_frame_daf8c11419498c5f135c12cffe0042c9 = NULL;

    assertFrameObject(frame_daf8c11419498c5f135c12cffe0042c9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_88_getComparisonGteShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_89_getComparisonEqShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_d267c448b6251b74e5be0a1f61bbb709;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_d267c448b6251b74e5be0a1f61bbb709 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_d267c448b6251b74e5be0a1f61bbb709, codeobj_d267c448b6251b74e5be0a1f61bbb709, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_d267c448b6251b74e5be0a1f61bbb709 = cache_frame_d267c448b6251b74e5be0a1f61bbb709;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d267c448b6251b74e5be0a1f61bbb709);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d267c448b6251b74e5be0a1f61bbb709) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_d267c448b6251b74e5be0a1f61bbb709->m_frame.f_lineno = 800;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 800;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d267c448b6251b74e5be0a1f61bbb709);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d267c448b6251b74e5be0a1f61bbb709);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d267c448b6251b74e5be0a1f61bbb709);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d267c448b6251b74e5be0a1f61bbb709, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_d267c448b6251b74e5be0a1f61bbb709->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d267c448b6251b74e5be0a1f61bbb709, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_d267c448b6251b74e5be0a1f61bbb709,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_d267c448b6251b74e5be0a1f61bbb709 == cache_frame_d267c448b6251b74e5be0a1f61bbb709) {
        Py_DECREF(frame_d267c448b6251b74e5be0a1f61bbb709);
    }
    cache_frame_d267c448b6251b74e5be0a1f61bbb709 = NULL;

    assertFrameObject(frame_d267c448b6251b74e5be0a1f61bbb709);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_89_getComparisonEqShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_90_getComparisonNeqShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_875572138db468037ef97f678b91cfcd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_875572138db468037ef97f678b91cfcd = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_875572138db468037ef97f678b91cfcd, codeobj_875572138db468037ef97f678b91cfcd, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_875572138db468037ef97f678b91cfcd = cache_frame_875572138db468037ef97f678b91cfcd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_875572138db468037ef97f678b91cfcd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_875572138db468037ef97f678b91cfcd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_875572138db468037ef97f678b91cfcd->m_frame.f_lineno = 803;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 803;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_875572138db468037ef97f678b91cfcd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_875572138db468037ef97f678b91cfcd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_875572138db468037ef97f678b91cfcd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_875572138db468037ef97f678b91cfcd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_875572138db468037ef97f678b91cfcd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_875572138db468037ef97f678b91cfcd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_875572138db468037ef97f678b91cfcd,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_875572138db468037ef97f678b91cfcd == cache_frame_875572138db468037ef97f678b91cfcd) {
        Py_DECREF(frame_875572138db468037ef97f678b91cfcd);
    }
    cache_frame_875572138db468037ef97f678b91cfcd = NULL;

    assertFrameObject(frame_875572138db468037ef97f678b91cfcd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_90_getComparisonNeqShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_91___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_shapes = python_pars[1];
    struct Nuitka_FrameObject *frame_825ccb8ddbea6048defc2fcd9766b195;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_825ccb8ddbea6048defc2fcd9766b195 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_825ccb8ddbea6048defc2fcd9766b195, codeobj_825ccb8ddbea6048defc2fcd9766b195, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_825ccb8ddbea6048defc2fcd9766b195 = cache_frame_825ccb8ddbea6048defc2fcd9766b195;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_825ccb8ddbea6048defc2fcd9766b195);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_825ccb8ddbea6048defc2fcd9766b195) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_shapes);
        tmp_assattr_name_1 = par_shapes;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_type_shapes, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 820;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 822;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_left_1 = tmp_mvar_value_1;
        CHECK_OBJECT(par_shapes);
        tmp_compexpr_right_1 = par_shapes;
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 822;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 822;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_825ccb8ddbea6048defc2fcd9766b195);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_825ccb8ddbea6048defc2fcd9766b195);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_825ccb8ddbea6048defc2fcd9766b195, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_825ccb8ddbea6048defc2fcd9766b195->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_825ccb8ddbea6048defc2fcd9766b195, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_825ccb8ddbea6048defc2fcd9766b195,
        type_description_1,
        par_self,
        par_shapes
    );


    // Release cached frame.
    if (frame_825ccb8ddbea6048defc2fcd9766b195 == cache_frame_825ccb8ddbea6048defc2fcd9766b195) {
        Py_DECREF(frame_825ccb8ddbea6048defc2fcd9766b195);
    }
    cache_frame_825ccb8ddbea6048defc2fcd9766b195 = NULL;

    assertFrameObject(frame_825ccb8ddbea6048defc2fcd9766b195);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_91___init__);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shapes);
    Py_DECREF(par_shapes);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shapes);
    Py_DECREF(par_shapes);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_emit = python_pars[1];
    PyObject *var_type_shape = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_37abb6baa47331d3a21966c1a9dcd9a1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_37abb6baa47331d3a21966c1a9dcd9a1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_37abb6baa47331d3a21966c1a9dcd9a1, codeobj_37abb6baa47331d3a21966c1a9dcd9a1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_37abb6baa47331d3a21966c1a9dcd9a1 = cache_frame_37abb6baa47331d3a21966c1a9dcd9a1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_37abb6baa47331d3a21966c1a9dcd9a1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_37abb6baa47331d3a21966c1a9dcd9a1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_type_shapes);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 825;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 825;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_1;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_2;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_2 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_2 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooo";
                exception_lineno = 825;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_2;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_3 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_type_shape;
            var_type_shape = tmp_assign_source_3;
            Py_INCREF(var_type_shape);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(var_type_shape);
        tmp_called_instance_1 = var_type_shape;
        CHECK_OBJECT(par_emit);
        tmp_args_element_name_1 = par_emit;
        frame_37abb6baa47331d3a21966c1a9dcd9a1->m_frame.f_lineno = 826;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_emitAlternatives, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 826;
            type_description_1 = "ooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 825;
        type_description_1 = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_37abb6baa47331d3a21966c1a9dcd9a1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_37abb6baa47331d3a21966c1a9dcd9a1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_37abb6baa47331d3a21966c1a9dcd9a1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_37abb6baa47331d3a21966c1a9dcd9a1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_37abb6baa47331d3a21966c1a9dcd9a1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_37abb6baa47331d3a21966c1a9dcd9a1,
        type_description_1,
        par_self,
        par_emit,
        var_type_shape
    );


    // Release cached frame.
    if (frame_37abb6baa47331d3a21966c1a9dcd9a1 == cache_frame_37abb6baa47331d3a21966c1a9dcd9a1) {
        Py_DECREF(frame_37abb6baa47331d3a21966c1a9dcd9a1);
    }
    cache_frame_37abb6baa47331d3a21966c1a9dcd9a1 = NULL;

    assertFrameObject(frame_37abb6baa47331d3a21966c1a9dcd9a1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_emit);
    Py_DECREF(par_emit);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_emit);
    Py_DECREF(par_emit);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_operation = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_escape_description = NULL;
    PyObject *var_single = NULL;
    PyObject *var_type_shape = NULL;
    PyObject *var_entry = NULL;
    PyObject *var_description = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    struct Nuitka_FrameObject *frame_4f95aee009bf65dad8462a36a27ef7b2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_iterator_attempt;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_4f95aee009bf65dad8462a36a27ef7b2 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert(var_result == NULL);
        Py_INCREF(tmp_assign_source_1);
        var_result = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = Py_None;
        assert(var_escape_description == NULL);
        Py_INCREF(tmp_assign_source_2);
        var_escape_description = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = Py_True;
        assert(var_single == NULL);
        Py_INCREF(tmp_assign_source_3);
        var_single = tmp_assign_source_3;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_4f95aee009bf65dad8462a36a27ef7b2, codeobj_4f95aee009bf65dad8462a36a27ef7b2, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_4f95aee009bf65dad8462a36a27ef7b2 = cache_frame_4f95aee009bf65dad8462a36a27ef7b2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4f95aee009bf65dad8462a36a27ef7b2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4f95aee009bf65dad8462a36a27ef7b2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_type_shapes);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 833;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 833;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_4;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_5 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                exception_lineno = 833;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_6;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_6 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_type_shape;
            var_type_shape = tmp_assign_source_6;
            Py_INCREF(var_type_shape);
            Py_XDECREF(old);
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_iter_arg_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_operation);
        tmp_called_name_1 = par_operation;
        CHECK_OBJECT(var_type_shape);
        tmp_args_element_name_1 = var_type_shape;
        frame_4f95aee009bf65dad8462a36a27ef7b2->m_frame.f_lineno = 834;
        tmp_iter_arg_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_iter_arg_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        tmp_assign_source_7 = MAKE_ITERATOR(tmp_iter_arg_2);
        Py_DECREF(tmp_iter_arg_2);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 834;
            type_description_1 = "oooooooo";
            goto try_except_handler_3;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__source_iter;
            tmp_tuple_unpack_1__source_iter = tmp_assign_source_7;
            Py_XDECREF(old);
        }

    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_unpack_1;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_8 = UNPACK_NEXT(tmp_unpack_1, 0, 2);
        if (tmp_assign_source_8 == NULL) {
            if (!ERROR_OCCURRED()) {
                exception_type = PyExc_StopIteration;
                Py_INCREF(exception_type);
                exception_value = NULL;
                exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            }


            type_description_1 = "oooooooo";
            exception_lineno = 834;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_1;
            tmp_tuple_unpack_1__element_1 = tmp_assign_source_8;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_unpack_2;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;
        tmp_assign_source_9 = UNPACK_NEXT(tmp_unpack_2, 1, 2);
        if (tmp_assign_source_9 == NULL) {
            if (!ERROR_OCCURRED()) {
                exception_type = PyExc_StopIteration;
                Py_INCREF(exception_type);
                exception_value = NULL;
                exception_tb = NULL;
            } else {
                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            }


            type_description_1 = "oooooooo";
            exception_lineno = 834;
            goto try_except_handler_4;
        }
        {
            PyObject *old = tmp_tuple_unpack_1__element_2;
            tmp_tuple_unpack_1__element_2 = tmp_assign_source_9;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_iterator_name_1;
        CHECK_OBJECT(tmp_tuple_unpack_1__source_iter);
        tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;
        // Check if iterator has left-over elements.
        CHECK_OBJECT(tmp_iterator_name_1); assert(HAS_ITERNEXT(tmp_iterator_name_1));

        tmp_iterator_attempt = (*Py_TYPE(tmp_iterator_name_1)->tp_iternext)(tmp_iterator_name_1);

        if (likely(tmp_iterator_attempt == NULL))
        {
            PyObject *error = GET_ERROR_OCCURRED();

            if (error != NULL)
            {
                if (EXCEPTION_MATCH_BOOL_SINGLE(error, PyExc_StopIteration))
                {
                    CLEAR_ERROR_OCCURRED();
                } else {
                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

                    type_description_1 = "oooooooo";
                    exception_lineno = 834;
                    goto try_except_handler_4;
                }
            }
        } else {
            Py_DECREF(tmp_iterator_attempt);

            // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
            PyErr_Format(PyExc_ValueError, "too many values to unpack");
#else
            PyErr_Format(PyExc_ValueError, "too many values to unpack (expected 2)");
#endif
            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);

            type_description_1 = "oooooooo";
            exception_lineno = 834;
            goto try_except_handler_4;
        }
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_tuple_unpack_1__source_iter);
    Py_DECREF(tmp_tuple_unpack_1__source_iter);
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_tuple_unpack_1__element_1);
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF(tmp_tuple_unpack_1__element_2);
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)tmp_tuple_unpack_1__source_iter);
    Py_DECREF(tmp_tuple_unpack_1__source_iter);
    tmp_tuple_unpack_1__source_iter = NULL;

    {
        PyObject *tmp_assign_source_10;
        CHECK_OBJECT(tmp_tuple_unpack_1__element_1);
        tmp_assign_source_10 = tmp_tuple_unpack_1__element_1;
        {
            PyObject *old = var_entry;
            var_entry = tmp_assign_source_10;
            Py_INCREF(var_entry);
            Py_XDECREF(old);
        }

    }
    Py_XDECREF(tmp_tuple_unpack_1__element_1);
    tmp_tuple_unpack_1__element_1 = NULL;

    {
        PyObject *tmp_assign_source_11;
        CHECK_OBJECT(tmp_tuple_unpack_1__element_2);
        tmp_assign_source_11 = tmp_tuple_unpack_1__element_2;
        {
            PyObject *old = var_description;
            var_description = tmp_assign_source_11;
            Py_INCREF(var_description);
            Py_XDECREF(old);
        }

    }
    Py_XDECREF(tmp_tuple_unpack_1__element_2);
    tmp_tuple_unpack_1__element_2 = NULL;

    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(var_entry);
        tmp_compexpr_left_1 = var_entry;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 836;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 837;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto try_return_handler_2;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        if (var_single == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "single");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 839;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }

        tmp_truth_name_1 = CHECK_IF_TRUE(var_single);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 839;
            type_description_1 = "oooooooo";
            goto try_except_handler_2;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            nuitka_bool tmp_condition_result_3;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            if (var_result == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 840;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }

            tmp_compexpr_left_2 = var_result;
            tmp_compexpr_right_2 = Py_None;
            tmp_condition_result_3 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_assign_source_12;
                CHECK_OBJECT(var_entry);
                tmp_assign_source_12 = var_entry;
                {
                    PyObject *old = var_result;
                    var_result = tmp_assign_source_12;
                    Py_INCREF(var_result);
                    Py_XDECREF(old);
                }

            }
            {
                PyObject *tmp_assign_source_13;
                CHECK_OBJECT(var_description);
                tmp_assign_source_13 = var_description;
                {
                    PyObject *old = var_escape_description;
                    var_escape_description = tmp_assign_source_13;
                    Py_INCREF(var_escape_description);
                    Py_XDECREF(old);
                }

            }
            goto branch_end_3;
            branch_no_3:;
            {
                nuitka_bool tmp_condition_result_4;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                if (var_result == NULL) {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF(exception_type);
                    exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 846;
                    type_description_1 = "oooooooo";
                    goto try_except_handler_2;
                }

                tmp_compexpr_left_3 = var_result;
                CHECK_OBJECT(var_entry);
                tmp_compexpr_right_3 = var_entry;
                tmp_condition_result_4 = (tmp_compexpr_left_3 != tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_4;
                } else {
                    goto branch_no_4;
                }
                branch_yes_4:;
                {
                    PyObject *tmp_assign_source_14;
                    tmp_assign_source_14 = Py_False;
                    {
                        PyObject *old = var_single;
                        var_single = tmp_assign_source_14;
                        Py_INCREF(var_single);
                        Py_XDECREF(old);
                    }

                }
                {
                    PyObject *tmp_assign_source_15;
                    PyObject *tmp_set_arg_1;
                    PyObject *tmp_tuple_element_1;
                    if (var_result == NULL) {

                        exception_type = PyExc_UnboundLocalError;
                        Py_INCREF(exception_type);
                        exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                        exception_tb = NULL;
                        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                        CHAIN_EXCEPTION(exception_value);

                        exception_lineno = 848;
                        type_description_1 = "oooooooo";
                        goto try_except_handler_2;
                    }

                    tmp_tuple_element_1 = var_result;
                    tmp_set_arg_1 = PyTuple_New(2);
                    Py_INCREF(tmp_tuple_element_1);
                    PyTuple_SET_ITEM(tmp_set_arg_1, 0, tmp_tuple_element_1);
                    CHECK_OBJECT(var_entry);
                    tmp_tuple_element_1 = var_entry;
                    Py_INCREF(tmp_tuple_element_1);
                    PyTuple_SET_ITEM(tmp_set_arg_1, 1, tmp_tuple_element_1);
                    tmp_assign_source_15 = PySet_New(tmp_set_arg_1);
                    Py_DECREF(tmp_set_arg_1);
                    if (tmp_assign_source_15 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 848;
                        type_description_1 = "oooooooo";
                        goto try_except_handler_2;
                    }
                    {
                        PyObject *old = var_result;
                        var_result = tmp_assign_source_15;
                        Py_XDECREF(old);
                    }

                }
                {
                    PyObject *tmp_assign_source_16;
                    PyObject *tmp_set_arg_2;
                    PyObject *tmp_tuple_element_2;
                    if (var_escape_description == NULL) {

                        exception_type = PyExc_UnboundLocalError;
                        Py_INCREF(exception_type);
                        exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "escape_description");
                        exception_tb = NULL;
                        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                        CHAIN_EXCEPTION(exception_value);

                        exception_lineno = 850;
                        type_description_1 = "oooooooo";
                        goto try_except_handler_2;
                    }

                    tmp_tuple_element_2 = var_escape_description;
                    tmp_set_arg_2 = PyTuple_New(2);
                    Py_INCREF(tmp_tuple_element_2);
                    PyTuple_SET_ITEM(tmp_set_arg_2, 0, tmp_tuple_element_2);
                    CHECK_OBJECT(var_description);
                    tmp_tuple_element_2 = var_description;
                    Py_INCREF(tmp_tuple_element_2);
                    PyTuple_SET_ITEM(tmp_set_arg_2, 1, tmp_tuple_element_2);
                    tmp_assign_source_16 = PySet_New(tmp_set_arg_2);
                    Py_DECREF(tmp_set_arg_2);
                    if (tmp_assign_source_16 == NULL) {
                        assert(ERROR_OCCURRED());

                        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                        exception_lineno = 850;
                        type_description_1 = "oooooooo";
                        goto try_except_handler_2;
                    }
                    {
                        PyObject *old = var_escape_description;
                        var_escape_description = tmp_assign_source_16;
                        Py_XDECREF(old);
                    }

                }
                branch_no_4:;
            }
            branch_end_3:;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_called_instance_1;
            PyObject *tmp_call_result_1;
            PyObject *tmp_args_element_name_2;
            if (var_result == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 852;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_1 = var_result;
            CHECK_OBJECT(var_entry);
            tmp_args_element_name_2 = var_entry;
            frame_4f95aee009bf65dad8462a36a27ef7b2->m_frame.f_lineno = 852;
            {
                PyObject *call_args[] = {tmp_args_element_name_2};
                tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_add, call_args);
            }

            if (tmp_call_result_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 852;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_1);
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_call_result_2;
            PyObject *tmp_args_element_name_3;
            if (var_escape_description == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "escape_description");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 853;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }

            tmp_called_instance_2 = var_escape_description;
            CHECK_OBJECT(var_description);
            tmp_args_element_name_3 = var_description;
            frame_4f95aee009bf65dad8462a36a27ef7b2->m_frame.f_lineno = 853;
            {
                PyObject *call_args[] = {tmp_args_element_name_3};
                tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_add, call_args);
            }

            if (tmp_call_result_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 853;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            Py_DECREF(tmp_call_result_2);
        }
        branch_end_2:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 833;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_3;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT((PyObject *)tmp_for_loop_1__iter_value);
    Py_DECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        nuitka_bool tmp_condition_result_5;
        int tmp_truth_name_2;
        if (var_single == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "single");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 855;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_truth_name_2 = CHECK_IF_TRUE(var_single);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 855;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_5 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_compexpr_left_4;
            PyObject *tmp_compexpr_right_4;
            if (var_result == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 856;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_compexpr_left_4 = var_result;
            tmp_compexpr_right_4 = Py_None;
            tmp_condition_result_6 = (tmp_compexpr_left_4 == tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
                goto branch_yes_6;
            } else {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_raise_type_1;
                tmp_raise_type_1 = PyExc_AssertionError;
                exception_type = tmp_raise_type_1;
                Py_INCREF(tmp_raise_type_1);
                exception_lineno = 856;
                RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            branch_no_6:;
        }
        {
            PyObject *tmp_tuple_element_3;
            if (var_result == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 857;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_3 = var_result;
            tmp_return_value = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_3);
            if (var_escape_description == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "escape_description");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 857;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_3 = var_escape_description;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_3);
            goto frame_return_exit_1;
        }
        goto branch_end_5;
        branch_no_5:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_5;
            PyObject *tmp_compexpr_right_5;
            PyObject *tmp_len_arg_1;
            if (var_escape_description == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "escape_description");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 859;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_len_arg_1 = var_escape_description;
            tmp_compexpr_left_5 = BUILTIN_LEN(tmp_len_arg_1);
            if (tmp_compexpr_left_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 859;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_compexpr_right_5 = const_int_pos_1;
            tmp_res = RICH_COMPARE_BOOL_GT_OBJECT_OBJECT(tmp_compexpr_left_5, tmp_compexpr_right_5);
            Py_DECREF(tmp_compexpr_left_5);
            assert(!(tmp_res == -1));
            tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
                goto branch_yes_7;
            } else {
                goto branch_no_7;
            }
            branch_yes_7:;
            {
                nuitka_bool tmp_condition_result_8;
                PyObject *tmp_compexpr_left_6;
                PyObject *tmp_compexpr_right_6;
                PyObject *tmp_mvar_value_3;
                tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

                if (unlikely(tmp_mvar_value_3 == NULL)) {
                    tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
                }

                if (tmp_mvar_value_3 == NULL) {

                    exception_type = PyExc_NameError;
                    Py_INCREF(exception_type);
                    exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 860;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_left_6 = tmp_mvar_value_3;
                if (var_escape_description == NULL) {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF(exception_type);
                    exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "escape_description");
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 860;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }

                tmp_compexpr_right_6 = var_escape_description;
                tmp_res = PySequence_Contains(tmp_compexpr_right_6, tmp_compexpr_left_6);
                if (tmp_res == -1) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 860;
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                tmp_condition_result_8 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_8;
                } else {
                    goto branch_no_8;
                }
                branch_yes_8:;
                {
                    PyObject *tmp_assign_source_17;
                    PyObject *tmp_mvar_value_4;
                    tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

                    if (unlikely(tmp_mvar_value_4 == NULL)) {
                        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
                    }

                    if (tmp_mvar_value_4 == NULL) {

                        exception_type = PyExc_NameError;
                        Py_INCREF(exception_type);
                        exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
                        exception_tb = NULL;
                        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                        CHAIN_EXCEPTION(exception_value);

                        exception_lineno = 861;
                        type_description_1 = "oooooooo";
                        goto frame_exception_exit_1;
                    }

                    tmp_assign_source_17 = tmp_mvar_value_4;
                    {
                        PyObject *old = var_escape_description;
                        var_escape_description = tmp_assign_source_17;
                        Py_INCREF(var_escape_description);
                        Py_XDECREF(old);
                    }

                }
                goto branch_end_8;
                branch_no_8:;
                {
                    PyObject *tmp_raise_type_2;
                    tmp_raise_type_2 = PyExc_AssertionError;
                    exception_type = tmp_raise_type_2;
                    Py_INCREF(tmp_raise_type_2);
                    exception_lineno = 863;
                    RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
                    type_description_1 = "oooooooo";
                    goto frame_exception_exit_1;
                }
                branch_end_8:;
            }
            branch_no_7:;
        }
        {
            PyObject *tmp_tuple_element_4;
            PyObject *tmp_called_name_2;
            PyObject *tmp_mvar_value_5;
            PyObject *tmp_args_element_name_4;
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);

            if (unlikely(tmp_mvar_value_5 == NULL)) {
                tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative);
            }

            if (tmp_mvar_value_5 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78676 ], 50, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 865;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_called_name_2 = tmp_mvar_value_5;
            if (var_result == NULL) {

                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 865;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_args_element_name_4 = var_result;
            frame_4f95aee009bf65dad8462a36a27ef7b2->m_frame.f_lineno = 865;
            tmp_tuple_element_4 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_4);
            if (tmp_tuple_element_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 865;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }
            tmp_return_value = PyTuple_New(2);
            PyTuple_SET_ITEM(tmp_return_value, 0, tmp_tuple_element_4);
            if (var_escape_description == NULL) {
                Py_DECREF(tmp_return_value);
                exception_type = PyExc_UnboundLocalError;
                Py_INCREF(exception_type);
                exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "escape_description");
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 865;
                type_description_1 = "oooooooo";
                goto frame_exception_exit_1;
            }

            tmp_tuple_element_4 = var_escape_description;
            Py_INCREF(tmp_tuple_element_4);
            PyTuple_SET_ITEM(tmp_return_value, 1, tmp_tuple_element_4);
            goto frame_return_exit_1;
        }
        branch_end_5:;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f95aee009bf65dad8462a36a27ef7b2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f95aee009bf65dad8462a36a27ef7b2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4f95aee009bf65dad8462a36a27ef7b2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4f95aee009bf65dad8462a36a27ef7b2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4f95aee009bf65dad8462a36a27ef7b2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4f95aee009bf65dad8462a36a27ef7b2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4f95aee009bf65dad8462a36a27ef7b2,
        type_description_1,
        par_self,
        par_operation,
        var_result,
        var_escape_description,
        var_single,
        var_type_shape,
        var_entry,
        var_description
    );


    // Release cached frame.
    if (frame_4f95aee009bf65dad8462a36a27ef7b2 == cache_frame_4f95aee009bf65dad8462a36a27ef7b2) {
        Py_DECREF(frame_4f95aee009bf65dad8462a36a27ef7b2);
    }
    cache_frame_4f95aee009bf65dad8462a36a27ef7b2 = NULL;

    assertFrameObject(frame_4f95aee009bf65dad8462a36a27ef7b2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_escape_description);
    var_escape_description = NULL;

    Py_XDECREF(var_single);
    var_single = NULL;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    Py_XDECREF(var_entry);
    var_entry = NULL;

    Py_XDECREF(var_description);
    var_description = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_escape_description);
    var_escape_description = NULL;

    Py_XDECREF(var_single);
    var_single = NULL;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    Py_XDECREF(var_entry);
    var_entry = NULL;

    Py_XDECREF(var_description);
    var_description = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_operation);
    Py_DECREF(par_operation);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_operation);
    Py_DECREF(par_operation);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_3aea18dc8eb5b018ebd7f4ecac8bb769;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_3aea18dc8eb5b018ebd7f4ecac8bb769 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3aea18dc8eb5b018ebd7f4ecac8bb769, codeobj_3aea18dc8eb5b018ebd7f4ecac8bb769, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3aea18dc8eb5b018ebd7f4ecac8bb769 = cache_frame_3aea18dc8eb5b018ebd7f4ecac8bb769;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3aea18dc8eb5b018ebd7f4ecac8bb769);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3aea18dc8eb5b018ebd7f4ecac8bb769) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 868;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 869;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 871;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_3aea18dc8eb5b018ebd7f4ecac8bb769->m_frame.f_lineno = 871;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 871;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aea18dc8eb5b018ebd7f4ecac8bb769);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aea18dc8eb5b018ebd7f4ecac8bb769);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aea18dc8eb5b018ebd7f4ecac8bb769);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3aea18dc8eb5b018ebd7f4ecac8bb769, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3aea18dc8eb5b018ebd7f4ecac8bb769->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3aea18dc8eb5b018ebd7f4ecac8bb769, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3aea18dc8eb5b018ebd7f4ecac8bb769,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_3aea18dc8eb5b018ebd7f4ecac8bb769 == cache_frame_3aea18dc8eb5b018ebd7f4ecac8bb769) {
        Py_DECREF(frame_3aea18dc8eb5b018ebd7f4ecac8bb769);
    }
    cache_frame_3aea18dc8eb5b018ebd7f4ecac8bb769 = NULL;

    assertFrameObject(frame_3aea18dc8eb5b018ebd7f4ecac8bb769);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_298fce9d2aa2b6ff2b7027183ccc4ed1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_298fce9d2aa2b6ff2b7027183ccc4ed1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_298fce9d2aa2b6ff2b7027183ccc4ed1, codeobj_298fce9d2aa2b6ff2b7027183ccc4ed1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_298fce9d2aa2b6ff2b7027183ccc4ed1 = cache_frame_298fce9d2aa2b6ff2b7027183ccc4ed1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_298fce9d2aa2b6ff2b7027183ccc4ed1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_298fce9d2aa2b6ff2b7027183ccc4ed1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryAddShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 872;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 873;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_298fce9d2aa2b6ff2b7027183ccc4ed1->m_frame.f_lineno = 872;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 872;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_298fce9d2aa2b6ff2b7027183ccc4ed1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_298fce9d2aa2b6ff2b7027183ccc4ed1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_298fce9d2aa2b6ff2b7027183ccc4ed1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_298fce9d2aa2b6ff2b7027183ccc4ed1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_298fce9d2aa2b6ff2b7027183ccc4ed1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_298fce9d2aa2b6ff2b7027183ccc4ed1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_298fce9d2aa2b6ff2b7027183ccc4ed1,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_298fce9d2aa2b6ff2b7027183ccc4ed1 == cache_frame_298fce9d2aa2b6ff2b7027183ccc4ed1) {
        Py_DECREF(frame_298fce9d2aa2b6ff2b7027183ccc4ed1);
    }
    cache_frame_298fce9d2aa2b6ff2b7027183ccc4ed1 = NULL;

    assertFrameObject(frame_298fce9d2aa2b6ff2b7027183ccc4ed1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_89c2e72108c717d051bc2f3380028c01;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_89c2e72108c717d051bc2f3380028c01 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_89c2e72108c717d051bc2f3380028c01, codeobj_89c2e72108c717d051bc2f3380028c01, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_89c2e72108c717d051bc2f3380028c01 = cache_frame_89c2e72108c717d051bc2f3380028c01;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_89c2e72108c717d051bc2f3380028c01);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_89c2e72108c717d051bc2f3380028c01) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 878;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 879;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 881;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_89c2e72108c717d051bc2f3380028c01->m_frame.f_lineno = 881;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 881;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_89c2e72108c717d051bc2f3380028c01);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_89c2e72108c717d051bc2f3380028c01);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_89c2e72108c717d051bc2f3380028c01);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_89c2e72108c717d051bc2f3380028c01, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_89c2e72108c717d051bc2f3380028c01->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_89c2e72108c717d051bc2f3380028c01, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_89c2e72108c717d051bc2f3380028c01,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_89c2e72108c717d051bc2f3380028c01 == cache_frame_89c2e72108c717d051bc2f3380028c01) {
        Py_DECREF(frame_89c2e72108c717d051bc2f3380028c01);
    }
    cache_frame_89c2e72108c717d051bc2f3380028c01 = NULL;

    assertFrameObject(frame_89c2e72108c717d051bc2f3380028c01);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_c28932552839632b2b12c0c3408e4ea3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c28932552839632b2b12c0c3408e4ea3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c28932552839632b2b12c0c3408e4ea3, codeobj_c28932552839632b2b12c0c3408e4ea3, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_c28932552839632b2b12c0c3408e4ea3 = cache_frame_c28932552839632b2b12c0c3408e4ea3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c28932552839632b2b12c0c3408e4ea3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c28932552839632b2b12c0c3408e4ea3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinarySubShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 882;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 883;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_c28932552839632b2b12c0c3408e4ea3->m_frame.f_lineno = 882;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 882;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c28932552839632b2b12c0c3408e4ea3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c28932552839632b2b12c0c3408e4ea3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c28932552839632b2b12c0c3408e4ea3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c28932552839632b2b12c0c3408e4ea3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c28932552839632b2b12c0c3408e4ea3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c28932552839632b2b12c0c3408e4ea3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c28932552839632b2b12c0c3408e4ea3,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_c28932552839632b2b12c0c3408e4ea3 == cache_frame_c28932552839632b2b12c0c3408e4ea3) {
        Py_DECREF(frame_c28932552839632b2b12c0c3408e4ea3);
    }
    cache_frame_c28932552839632b2b12c0c3408e4ea3 = NULL;

    assertFrameObject(frame_c28932552839632b2b12c0c3408e4ea3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_cf4ec8f3fd82f729a4fed2653f5c444f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_cf4ec8f3fd82f729a4fed2653f5c444f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cf4ec8f3fd82f729a4fed2653f5c444f, codeobj_cf4ec8f3fd82f729a4fed2653f5c444f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_cf4ec8f3fd82f729a4fed2653f5c444f = cache_frame_cf4ec8f3fd82f729a4fed2653f5c444f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cf4ec8f3fd82f729a4fed2653f5c444f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cf4ec8f3fd82f729a4fed2653f5c444f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 888;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 889;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 891;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_cf4ec8f3fd82f729a4fed2653f5c444f->m_frame.f_lineno = 891;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 891;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf4ec8f3fd82f729a4fed2653f5c444f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf4ec8f3fd82f729a4fed2653f5c444f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf4ec8f3fd82f729a4fed2653f5c444f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cf4ec8f3fd82f729a4fed2653f5c444f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cf4ec8f3fd82f729a4fed2653f5c444f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cf4ec8f3fd82f729a4fed2653f5c444f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cf4ec8f3fd82f729a4fed2653f5c444f,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_cf4ec8f3fd82f729a4fed2653f5c444f == cache_frame_cf4ec8f3fd82f729a4fed2653f5c444f) {
        Py_DECREF(frame_cf4ec8f3fd82f729a4fed2653f5c444f);
    }
    cache_frame_cf4ec8f3fd82f729a4fed2653f5c444f = NULL;

    assertFrameObject(frame_cf4ec8f3fd82f729a4fed2653f5c444f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_8c07135053c1f08248f8e07045be6e55;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_8c07135053c1f08248f8e07045be6e55 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_8c07135053c1f08248f8e07045be6e55, codeobj_8c07135053c1f08248f8e07045be6e55, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_8c07135053c1f08248f8e07045be6e55 = cache_frame_8c07135053c1f08248f8e07045be6e55;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8c07135053c1f08248f8e07045be6e55);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8c07135053c1f08248f8e07045be6e55) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryMultShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 892;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 893;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_8c07135053c1f08248f8e07045be6e55->m_frame.f_lineno = 892;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 892;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c07135053c1f08248f8e07045be6e55);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c07135053c1f08248f8e07045be6e55);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8c07135053c1f08248f8e07045be6e55);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8c07135053c1f08248f8e07045be6e55, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_8c07135053c1f08248f8e07045be6e55->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8c07135053c1f08248f8e07045be6e55, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_8c07135053c1f08248f8e07045be6e55,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_8c07135053c1f08248f8e07045be6e55 == cache_frame_8c07135053c1f08248f8e07045be6e55) {
        Py_DECREF(frame_8c07135053c1f08248f8e07045be6e55);
    }
    cache_frame_8c07135053c1f08248f8e07045be6e55 = NULL;

    assertFrameObject(frame_8c07135053c1f08248f8e07045be6e55);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_b22d37a6a511a522a7e064ecabab8350;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b22d37a6a511a522a7e064ecabab8350 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b22d37a6a511a522a7e064ecabab8350, codeobj_b22d37a6a511a522a7e064ecabab8350, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_b22d37a6a511a522a7e064ecabab8350 = cache_frame_b22d37a6a511a522a7e064ecabab8350;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b22d37a6a511a522a7e064ecabab8350);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b22d37a6a511a522a7e064ecabab8350) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 898;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 899;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 901;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_b22d37a6a511a522a7e064ecabab8350->m_frame.f_lineno = 901;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 901;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b22d37a6a511a522a7e064ecabab8350);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b22d37a6a511a522a7e064ecabab8350);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b22d37a6a511a522a7e064ecabab8350);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b22d37a6a511a522a7e064ecabab8350, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b22d37a6a511a522a7e064ecabab8350->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b22d37a6a511a522a7e064ecabab8350, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b22d37a6a511a522a7e064ecabab8350,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_b22d37a6a511a522a7e064ecabab8350 == cache_frame_b22d37a6a511a522a7e064ecabab8350) {
        Py_DECREF(frame_b22d37a6a511a522a7e064ecabab8350);
    }
    cache_frame_b22d37a6a511a522a7e064ecabab8350 = NULL;

    assertFrameObject(frame_b22d37a6a511a522a7e064ecabab8350);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_3f41991df1be5fc8332b7034fc522534;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3f41991df1be5fc8332b7034fc522534 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3f41991df1be5fc8332b7034fc522534, codeobj_3f41991df1be5fc8332b7034fc522534, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3f41991df1be5fc8332b7034fc522534 = cache_frame_3f41991df1be5fc8332b7034fc522534;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3f41991df1be5fc8332b7034fc522534);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3f41991df1be5fc8332b7034fc522534) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryFloorDivShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 902;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 903;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_3f41991df1be5fc8332b7034fc522534->m_frame.f_lineno = 902;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 902;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f41991df1be5fc8332b7034fc522534);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f41991df1be5fc8332b7034fc522534);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3f41991df1be5fc8332b7034fc522534);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3f41991df1be5fc8332b7034fc522534, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3f41991df1be5fc8332b7034fc522534->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3f41991df1be5fc8332b7034fc522534, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3f41991df1be5fc8332b7034fc522534,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_3f41991df1be5fc8332b7034fc522534 == cache_frame_3f41991df1be5fc8332b7034fc522534) {
        Py_DECREF(frame_3f41991df1be5fc8332b7034fc522534);
    }
    cache_frame_3f41991df1be5fc8332b7034fc522534 = NULL;

    assertFrameObject(frame_3f41991df1be5fc8332b7034fc522534);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_99127d41fd2b0d07a06cc6547a8fe896;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_99127d41fd2b0d07a06cc6547a8fe896 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_99127d41fd2b0d07a06cc6547a8fe896, codeobj_99127d41fd2b0d07a06cc6547a8fe896, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_99127d41fd2b0d07a06cc6547a8fe896 = cache_frame_99127d41fd2b0d07a06cc6547a8fe896;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_99127d41fd2b0d07a06cc6547a8fe896);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_99127d41fd2b0d07a06cc6547a8fe896) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 908;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 909;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 911;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_99127d41fd2b0d07a06cc6547a8fe896->m_frame.f_lineno = 911;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 911;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_99127d41fd2b0d07a06cc6547a8fe896);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_99127d41fd2b0d07a06cc6547a8fe896);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_99127d41fd2b0d07a06cc6547a8fe896);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_99127d41fd2b0d07a06cc6547a8fe896, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_99127d41fd2b0d07a06cc6547a8fe896->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_99127d41fd2b0d07a06cc6547a8fe896, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_99127d41fd2b0d07a06cc6547a8fe896,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_99127d41fd2b0d07a06cc6547a8fe896 == cache_frame_99127d41fd2b0d07a06cc6547a8fe896) {
        Py_DECREF(frame_99127d41fd2b0d07a06cc6547a8fe896);
    }
    cache_frame_99127d41fd2b0d07a06cc6547a8fe896 = NULL;

    assertFrameObject(frame_99127d41fd2b0d07a06cc6547a8fe896);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_3aa00639304e27a92d16236ecf68307c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3aa00639304e27a92d16236ecf68307c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3aa00639304e27a92d16236ecf68307c, codeobj_3aa00639304e27a92d16236ecf68307c, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3aa00639304e27a92d16236ecf68307c = cache_frame_3aa00639304e27a92d16236ecf68307c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3aa00639304e27a92d16236ecf68307c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3aa00639304e27a92d16236ecf68307c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryOldDivShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 912;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 913;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_3aa00639304e27a92d16236ecf68307c->m_frame.f_lineno = 912;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 912;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aa00639304e27a92d16236ecf68307c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aa00639304e27a92d16236ecf68307c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aa00639304e27a92d16236ecf68307c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3aa00639304e27a92d16236ecf68307c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3aa00639304e27a92d16236ecf68307c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3aa00639304e27a92d16236ecf68307c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3aa00639304e27a92d16236ecf68307c,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_3aa00639304e27a92d16236ecf68307c == cache_frame_3aa00639304e27a92d16236ecf68307c) {
        Py_DECREF(frame_3aa00639304e27a92d16236ecf68307c);
    }
    cache_frame_3aa00639304e27a92d16236ecf68307c = NULL;

    assertFrameObject(frame_3aa00639304e27a92d16236ecf68307c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_b7c9f7c3ee3a065c315692d6d6b121d6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b7c9f7c3ee3a065c315692d6d6b121d6 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b7c9f7c3ee3a065c315692d6d6b121d6, codeobj_b7c9f7c3ee3a065c315692d6d6b121d6, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_b7c9f7c3ee3a065c315692d6d6b121d6 = cache_frame_b7c9f7c3ee3a065c315692d6d6b121d6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b7c9f7c3ee3a065c315692d6d6b121d6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b7c9f7c3ee3a065c315692d6d6b121d6) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 918;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 919;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 921;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_b7c9f7c3ee3a065c315692d6d6b121d6->m_frame.f_lineno = 921;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 921;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7c9f7c3ee3a065c315692d6d6b121d6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7c9f7c3ee3a065c315692d6d6b121d6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b7c9f7c3ee3a065c315692d6d6b121d6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b7c9f7c3ee3a065c315692d6d6b121d6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b7c9f7c3ee3a065c315692d6d6b121d6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b7c9f7c3ee3a065c315692d6d6b121d6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b7c9f7c3ee3a065c315692d6d6b121d6,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_b7c9f7c3ee3a065c315692d6d6b121d6 == cache_frame_b7c9f7c3ee3a065c315692d6d6b121d6) {
        Py_DECREF(frame_b7c9f7c3ee3a065c315692d6d6b121d6);
    }
    cache_frame_b7c9f7c3ee3a065c315692d6d6b121d6 = NULL;

    assertFrameObject(frame_b7c9f7c3ee3a065c315692d6d6b121d6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_16d5e8aa45f52a0ffbe0ad9ded831f67;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_16d5e8aa45f52a0ffbe0ad9ded831f67 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_16d5e8aa45f52a0ffbe0ad9ded831f67, codeobj_16d5e8aa45f52a0ffbe0ad9ded831f67, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_16d5e8aa45f52a0ffbe0ad9ded831f67 = cache_frame_16d5e8aa45f52a0ffbe0ad9ded831f67;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_16d5e8aa45f52a0ffbe0ad9ded831f67);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_16d5e8aa45f52a0ffbe0ad9ded831f67) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryTrueDivShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 922;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 923;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_16d5e8aa45f52a0ffbe0ad9ded831f67->m_frame.f_lineno = 922;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 922;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_16d5e8aa45f52a0ffbe0ad9ded831f67);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_16d5e8aa45f52a0ffbe0ad9ded831f67);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_16d5e8aa45f52a0ffbe0ad9ded831f67);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_16d5e8aa45f52a0ffbe0ad9ded831f67, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_16d5e8aa45f52a0ffbe0ad9ded831f67->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_16d5e8aa45f52a0ffbe0ad9ded831f67, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_16d5e8aa45f52a0ffbe0ad9ded831f67,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_16d5e8aa45f52a0ffbe0ad9ded831f67 == cache_frame_16d5e8aa45f52a0ffbe0ad9ded831f67) {
        Py_DECREF(frame_16d5e8aa45f52a0ffbe0ad9ded831f67);
    }
    cache_frame_16d5e8aa45f52a0ffbe0ad9ded831f67 = NULL;

    assertFrameObject(frame_16d5e8aa45f52a0ffbe0ad9ded831f67);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_499f52653ddcc4cf7b070bb86ee33cb5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_499f52653ddcc4cf7b070bb86ee33cb5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_499f52653ddcc4cf7b070bb86ee33cb5, codeobj_499f52653ddcc4cf7b070bb86ee33cb5, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_499f52653ddcc4cf7b070bb86ee33cb5 = cache_frame_499f52653ddcc4cf7b070bb86ee33cb5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_499f52653ddcc4cf7b070bb86ee33cb5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_499f52653ddcc4cf7b070bb86ee33cb5) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 928;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 929;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 931;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_499f52653ddcc4cf7b070bb86ee33cb5->m_frame.f_lineno = 931;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 931;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_499f52653ddcc4cf7b070bb86ee33cb5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_499f52653ddcc4cf7b070bb86ee33cb5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_499f52653ddcc4cf7b070bb86ee33cb5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_499f52653ddcc4cf7b070bb86ee33cb5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_499f52653ddcc4cf7b070bb86ee33cb5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_499f52653ddcc4cf7b070bb86ee33cb5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_499f52653ddcc4cf7b070bb86ee33cb5,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_499f52653ddcc4cf7b070bb86ee33cb5 == cache_frame_499f52653ddcc4cf7b070bb86ee33cb5) {
        Py_DECREF(frame_499f52653ddcc4cf7b070bb86ee33cb5);
    }
    cache_frame_499f52653ddcc4cf7b070bb86ee33cb5 = NULL;

    assertFrameObject(frame_499f52653ddcc4cf7b070bb86ee33cb5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_cf083e9cfbad2c159d4aced3a9ce2f13;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cf083e9cfbad2c159d4aced3a9ce2f13 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cf083e9cfbad2c159d4aced3a9ce2f13, codeobj_cf083e9cfbad2c159d4aced3a9ce2f13, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_cf083e9cfbad2c159d4aced3a9ce2f13 = cache_frame_cf083e9cfbad2c159d4aced3a9ce2f13;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cf083e9cfbad2c159d4aced3a9ce2f13);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cf083e9cfbad2c159d4aced3a9ce2f13) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryModShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 932;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 933;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_cf083e9cfbad2c159d4aced3a9ce2f13->m_frame.f_lineno = 932;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 932;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf083e9cfbad2c159d4aced3a9ce2f13);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf083e9cfbad2c159d4aced3a9ce2f13);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cf083e9cfbad2c159d4aced3a9ce2f13);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cf083e9cfbad2c159d4aced3a9ce2f13, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cf083e9cfbad2c159d4aced3a9ce2f13->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cf083e9cfbad2c159d4aced3a9ce2f13, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cf083e9cfbad2c159d4aced3a9ce2f13,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_cf083e9cfbad2c159d4aced3a9ce2f13 == cache_frame_cf083e9cfbad2c159d4aced3a9ce2f13) {
        Py_DECREF(frame_cf083e9cfbad2c159d4aced3a9ce2f13);
    }
    cache_frame_cf083e9cfbad2c159d4aced3a9ce2f13 = NULL;

    assertFrameObject(frame_cf083e9cfbad2c159d4aced3a9ce2f13);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_1d78d973fdfa93709e28c3b9fb0259d5;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1d78d973fdfa93709e28c3b9fb0259d5 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1d78d973fdfa93709e28c3b9fb0259d5, codeobj_1d78d973fdfa93709e28c3b9fb0259d5, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_1d78d973fdfa93709e28c3b9fb0259d5 = cache_frame_1d78d973fdfa93709e28c3b9fb0259d5;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1d78d973fdfa93709e28c3b9fb0259d5);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1d78d973fdfa93709e28c3b9fb0259d5) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 938;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 939;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 941;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_1d78d973fdfa93709e28c3b9fb0259d5->m_frame.f_lineno = 941;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 941;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1d78d973fdfa93709e28c3b9fb0259d5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1d78d973fdfa93709e28c3b9fb0259d5);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1d78d973fdfa93709e28c3b9fb0259d5);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1d78d973fdfa93709e28c3b9fb0259d5, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1d78d973fdfa93709e28c3b9fb0259d5->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1d78d973fdfa93709e28c3b9fb0259d5, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1d78d973fdfa93709e28c3b9fb0259d5,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_1d78d973fdfa93709e28c3b9fb0259d5 == cache_frame_1d78d973fdfa93709e28c3b9fb0259d5) {
        Py_DECREF(frame_1d78d973fdfa93709e28c3b9fb0259d5);
    }
    cache_frame_1d78d973fdfa93709e28c3b9fb0259d5 = NULL;

    assertFrameObject(frame_1d78d973fdfa93709e28c3b9fb0259d5);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_ae60fc6cc678c38925186346b02b8b4d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ae60fc6cc678c38925186346b02b8b4d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ae60fc6cc678c38925186346b02b8b4d, codeobj_ae60fc6cc678c38925186346b02b8b4d, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_ae60fc6cc678c38925186346b02b8b4d = cache_frame_ae60fc6cc678c38925186346b02b8b4d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ae60fc6cc678c38925186346b02b8b4d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ae60fc6cc678c38925186346b02b8b4d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryPowShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 942;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 943;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_ae60fc6cc678c38925186346b02b8b4d->m_frame.f_lineno = 942;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 942;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ae60fc6cc678c38925186346b02b8b4d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ae60fc6cc678c38925186346b02b8b4d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ae60fc6cc678c38925186346b02b8b4d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ae60fc6cc678c38925186346b02b8b4d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ae60fc6cc678c38925186346b02b8b4d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ae60fc6cc678c38925186346b02b8b4d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ae60fc6cc678c38925186346b02b8b4d,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_ae60fc6cc678c38925186346b02b8b4d == cache_frame_ae60fc6cc678c38925186346b02b8b4d) {
        Py_DECREF(frame_ae60fc6cc678c38925186346b02b8b4d);
    }
    cache_frame_ae60fc6cc678c38925186346b02b8b4d = NULL;

    assertFrameObject(frame_ae60fc6cc678c38925186346b02b8b4d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_a591b45e141f9e1407e183961bfaacf7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a591b45e141f9e1407e183961bfaacf7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a591b45e141f9e1407e183961bfaacf7, codeobj_a591b45e141f9e1407e183961bfaacf7, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_a591b45e141f9e1407e183961bfaacf7 = cache_frame_a591b45e141f9e1407e183961bfaacf7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a591b45e141f9e1407e183961bfaacf7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a591b45e141f9e1407e183961bfaacf7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 948;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 949;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 951;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_a591b45e141f9e1407e183961bfaacf7->m_frame.f_lineno = 951;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 951;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a591b45e141f9e1407e183961bfaacf7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a591b45e141f9e1407e183961bfaacf7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a591b45e141f9e1407e183961bfaacf7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a591b45e141f9e1407e183961bfaacf7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a591b45e141f9e1407e183961bfaacf7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a591b45e141f9e1407e183961bfaacf7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a591b45e141f9e1407e183961bfaacf7,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_a591b45e141f9e1407e183961bfaacf7 == cache_frame_a591b45e141f9e1407e183961bfaacf7) {
        Py_DECREF(frame_a591b45e141f9e1407e183961bfaacf7);
    }
    cache_frame_a591b45e141f9e1407e183961bfaacf7 = NULL;

    assertFrameObject(frame_a591b45e141f9e1407e183961bfaacf7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_c6fedd91871b754cb84e7622a10d1bf8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c6fedd91871b754cb84e7622a10d1bf8 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c6fedd91871b754cb84e7622a10d1bf8, codeobj_c6fedd91871b754cb84e7622a10d1bf8, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_c6fedd91871b754cb84e7622a10d1bf8 = cache_frame_c6fedd91871b754cb84e7622a10d1bf8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c6fedd91871b754cb84e7622a10d1bf8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c6fedd91871b754cb84e7622a10d1bf8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryLShiftShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 952;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 953;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_c6fedd91871b754cb84e7622a10d1bf8->m_frame.f_lineno = 952;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 952;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c6fedd91871b754cb84e7622a10d1bf8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c6fedd91871b754cb84e7622a10d1bf8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c6fedd91871b754cb84e7622a10d1bf8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c6fedd91871b754cb84e7622a10d1bf8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c6fedd91871b754cb84e7622a10d1bf8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c6fedd91871b754cb84e7622a10d1bf8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c6fedd91871b754cb84e7622a10d1bf8,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_c6fedd91871b754cb84e7622a10d1bf8 == cache_frame_c6fedd91871b754cb84e7622a10d1bf8) {
        Py_DECREF(frame_c6fedd91871b754cb84e7622a10d1bf8);
    }
    cache_frame_c6fedd91871b754cb84e7622a10d1bf8 = NULL;

    assertFrameObject(frame_c6fedd91871b754cb84e7622a10d1bf8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_89a8f8ac78edc545758a6558f344ee65;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_89a8f8ac78edc545758a6558f344ee65 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_89a8f8ac78edc545758a6558f344ee65, codeobj_89a8f8ac78edc545758a6558f344ee65, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_89a8f8ac78edc545758a6558f344ee65 = cache_frame_89a8f8ac78edc545758a6558f344ee65;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_89a8f8ac78edc545758a6558f344ee65);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_89a8f8ac78edc545758a6558f344ee65) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 958;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 959;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 961;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_89a8f8ac78edc545758a6558f344ee65->m_frame.f_lineno = 961;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 961;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_89a8f8ac78edc545758a6558f344ee65);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_89a8f8ac78edc545758a6558f344ee65);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_89a8f8ac78edc545758a6558f344ee65);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_89a8f8ac78edc545758a6558f344ee65, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_89a8f8ac78edc545758a6558f344ee65->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_89a8f8ac78edc545758a6558f344ee65, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_89a8f8ac78edc545758a6558f344ee65,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_89a8f8ac78edc545758a6558f344ee65 == cache_frame_89a8f8ac78edc545758a6558f344ee65) {
        Py_DECREF(frame_89a8f8ac78edc545758a6558f344ee65);
    }
    cache_frame_89a8f8ac78edc545758a6558f344ee65 = NULL;

    assertFrameObject(frame_89a8f8ac78edc545758a6558f344ee65);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_a00d35d4a235c5f8456762b71f4a78d8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a00d35d4a235c5f8456762b71f4a78d8 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a00d35d4a235c5f8456762b71f4a78d8, codeobj_a00d35d4a235c5f8456762b71f4a78d8, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_a00d35d4a235c5f8456762b71f4a78d8 = cache_frame_a00d35d4a235c5f8456762b71f4a78d8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a00d35d4a235c5f8456762b71f4a78d8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a00d35d4a235c5f8456762b71f4a78d8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryRShiftShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 962;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 963;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_a00d35d4a235c5f8456762b71f4a78d8->m_frame.f_lineno = 962;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 962;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a00d35d4a235c5f8456762b71f4a78d8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a00d35d4a235c5f8456762b71f4a78d8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a00d35d4a235c5f8456762b71f4a78d8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a00d35d4a235c5f8456762b71f4a78d8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a00d35d4a235c5f8456762b71f4a78d8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a00d35d4a235c5f8456762b71f4a78d8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a00d35d4a235c5f8456762b71f4a78d8,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_a00d35d4a235c5f8456762b71f4a78d8 == cache_frame_a00d35d4a235c5f8456762b71f4a78d8) {
        Py_DECREF(frame_a00d35d4a235c5f8456762b71f4a78d8);
    }
    cache_frame_a00d35d4a235c5f8456762b71f4a78d8 = NULL;

    assertFrameObject(frame_a00d35d4a235c5f8456762b71f4a78d8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_022829a966c1f23e7ccf00bde09aee2d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_022829a966c1f23e7ccf00bde09aee2d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_022829a966c1f23e7ccf00bde09aee2d, codeobj_022829a966c1f23e7ccf00bde09aee2d, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_022829a966c1f23e7ccf00bde09aee2d = cache_frame_022829a966c1f23e7ccf00bde09aee2d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_022829a966c1f23e7ccf00bde09aee2d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_022829a966c1f23e7ccf00bde09aee2d) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 968;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 969;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 971;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_022829a966c1f23e7ccf00bde09aee2d->m_frame.f_lineno = 971;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 971;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_022829a966c1f23e7ccf00bde09aee2d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_022829a966c1f23e7ccf00bde09aee2d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_022829a966c1f23e7ccf00bde09aee2d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_022829a966c1f23e7ccf00bde09aee2d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_022829a966c1f23e7ccf00bde09aee2d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_022829a966c1f23e7ccf00bde09aee2d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_022829a966c1f23e7ccf00bde09aee2d,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_022829a966c1f23e7ccf00bde09aee2d == cache_frame_022829a966c1f23e7ccf00bde09aee2d) {
        Py_DECREF(frame_022829a966c1f23e7ccf00bde09aee2d);
    }
    cache_frame_022829a966c1f23e7ccf00bde09aee2d = NULL;

    assertFrameObject(frame_022829a966c1f23e7ccf00bde09aee2d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_b106615f89fdb156afc27cd670a27ae1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_b106615f89fdb156afc27cd670a27ae1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_b106615f89fdb156afc27cd670a27ae1, codeobj_b106615f89fdb156afc27cd670a27ae1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_b106615f89fdb156afc27cd670a27ae1 = cache_frame_b106615f89fdb156afc27cd670a27ae1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b106615f89fdb156afc27cd670a27ae1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b106615f89fdb156afc27cd670a27ae1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryBitOrShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 972;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 973;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_b106615f89fdb156afc27cd670a27ae1->m_frame.f_lineno = 972;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 972;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b106615f89fdb156afc27cd670a27ae1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b106615f89fdb156afc27cd670a27ae1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b106615f89fdb156afc27cd670a27ae1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b106615f89fdb156afc27cd670a27ae1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_b106615f89fdb156afc27cd670a27ae1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b106615f89fdb156afc27cd670a27ae1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_b106615f89fdb156afc27cd670a27ae1,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_b106615f89fdb156afc27cd670a27ae1 == cache_frame_b106615f89fdb156afc27cd670a27ae1) {
        Py_DECREF(frame_b106615f89fdb156afc27cd670a27ae1);
    }
    cache_frame_b106615f89fdb156afc27cd670a27ae1 = NULL;

    assertFrameObject(frame_b106615f89fdb156afc27cd670a27ae1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_59ddd5bade3e7d7071096f791af6bb2f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_59ddd5bade3e7d7071096f791af6bb2f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_59ddd5bade3e7d7071096f791af6bb2f, codeobj_59ddd5bade3e7d7071096f791af6bb2f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_59ddd5bade3e7d7071096f791af6bb2f = cache_frame_59ddd5bade3e7d7071096f791af6bb2f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_59ddd5bade3e7d7071096f791af6bb2f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_59ddd5bade3e7d7071096f791af6bb2f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 978;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 979;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 981;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_59ddd5bade3e7d7071096f791af6bb2f->m_frame.f_lineno = 981;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 981;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_59ddd5bade3e7d7071096f791af6bb2f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_59ddd5bade3e7d7071096f791af6bb2f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_59ddd5bade3e7d7071096f791af6bb2f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_59ddd5bade3e7d7071096f791af6bb2f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_59ddd5bade3e7d7071096f791af6bb2f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_59ddd5bade3e7d7071096f791af6bb2f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_59ddd5bade3e7d7071096f791af6bb2f,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_59ddd5bade3e7d7071096f791af6bb2f == cache_frame_59ddd5bade3e7d7071096f791af6bb2f) {
        Py_DECREF(frame_59ddd5bade3e7d7071096f791af6bb2f);
    }
    cache_frame_59ddd5bade3e7d7071096f791af6bb2f = NULL;

    assertFrameObject(frame_59ddd5bade3e7d7071096f791af6bb2f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_5177af75f0d50388640dc79607719db2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5177af75f0d50388640dc79607719db2 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5177af75f0d50388640dc79607719db2, codeobj_5177af75f0d50388640dc79607719db2, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_5177af75f0d50388640dc79607719db2 = cache_frame_5177af75f0d50388640dc79607719db2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5177af75f0d50388640dc79607719db2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5177af75f0d50388640dc79607719db2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryBitAndShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 982;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 983;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_5177af75f0d50388640dc79607719db2->m_frame.f_lineno = 982;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 982;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5177af75f0d50388640dc79607719db2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5177af75f0d50388640dc79607719db2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5177af75f0d50388640dc79607719db2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5177af75f0d50388640dc79607719db2, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5177af75f0d50388640dc79607719db2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5177af75f0d50388640dc79607719db2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5177af75f0d50388640dc79607719db2,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_5177af75f0d50388640dc79607719db2 == cache_frame_5177af75f0d50388640dc79607719db2) {
        Py_DECREF(frame_5177af75f0d50388640dc79607719db2);
    }
    cache_frame_5177af75f0d50388640dc79607719db2 = NULL;

    assertFrameObject(frame_5177af75f0d50388640dc79607719db2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_3dfb915e058f7cd39b9377754263a24f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_3dfb915e058f7cd39b9377754263a24f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3dfb915e058f7cd39b9377754263a24f, codeobj_3dfb915e058f7cd39b9377754263a24f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3dfb915e058f7cd39b9377754263a24f = cache_frame_3dfb915e058f7cd39b9377754263a24f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3dfb915e058f7cd39b9377754263a24f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3dfb915e058f7cd39b9377754263a24f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 988;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 989;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 991;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_3dfb915e058f7cd39b9377754263a24f->m_frame.f_lineno = 991;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 991;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dfb915e058f7cd39b9377754263a24f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dfb915e058f7cd39b9377754263a24f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3dfb915e058f7cd39b9377754263a24f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3dfb915e058f7cd39b9377754263a24f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3dfb915e058f7cd39b9377754263a24f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3dfb915e058f7cd39b9377754263a24f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3dfb915e058f7cd39b9377754263a24f,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_3dfb915e058f7cd39b9377754263a24f == cache_frame_3dfb915e058f7cd39b9377754263a24f) {
        Py_DECREF(frame_3dfb915e058f7cd39b9377754263a24f);
    }
    cache_frame_3dfb915e058f7cd39b9377754263a24f = NULL;

    assertFrameObject(frame_3dfb915e058f7cd39b9377754263a24f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_48a7b3d2a10292d9b503c411427e1f81;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_48a7b3d2a10292d9b503c411427e1f81 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_48a7b3d2a10292d9b503c411427e1f81, codeobj_48a7b3d2a10292d9b503c411427e1f81, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_48a7b3d2a10292d9b503c411427e1f81 = cache_frame_48a7b3d2a10292d9b503c411427e1f81;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_48a7b3d2a10292d9b503c411427e1f81);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_48a7b3d2a10292d9b503c411427e1f81) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryBitXorShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 992;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 993;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_48a7b3d2a10292d9b503c411427e1f81->m_frame.f_lineno = 992;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 992;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_48a7b3d2a10292d9b503c411427e1f81);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_48a7b3d2a10292d9b503c411427e1f81);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_48a7b3d2a10292d9b503c411427e1f81);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_48a7b3d2a10292d9b503c411427e1f81, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_48a7b3d2a10292d9b503c411427e1f81->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_48a7b3d2a10292d9b503c411427e1f81, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_48a7b3d2a10292d9b503c411427e1f81,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_48a7b3d2a10292d9b503c411427e1f81 == cache_frame_48a7b3d2a10292d9b503c411427e1f81) {
        Py_DECREF(frame_48a7b3d2a10292d9b503c411427e1f81);
    }
    cache_frame_48a7b3d2a10292d9b503c411427e1f81 = NULL;

    assertFrameObject(frame_48a7b3d2a10292d9b503c411427e1f81);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_de246dc45def92d44d802cefb7b0ae4b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_de246dc45def92d44d802cefb7b0ae4b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_de246dc45def92d44d802cefb7b0ae4b, codeobj_de246dc45def92d44d802cefb7b0ae4b, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_de246dc45def92d44d802cefb7b0ae4b = cache_frame_de246dc45def92d44d802cefb7b0ae4b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_de246dc45def92d44d802cefb7b0ae4b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_de246dc45def92d44d802cefb7b0ae4b) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 998;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 999;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1001;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_de246dc45def92d44d802cefb7b0ae4b->m_frame.f_lineno = 1001;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1001;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de246dc45def92d44d802cefb7b0ae4b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_de246dc45def92d44d802cefb7b0ae4b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_de246dc45def92d44d802cefb7b0ae4b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_de246dc45def92d44d802cefb7b0ae4b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_de246dc45def92d44d802cefb7b0ae4b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_de246dc45def92d44d802cefb7b0ae4b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_de246dc45def92d44d802cefb7b0ae4b,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_de246dc45def92d44d802cefb7b0ae4b == cache_frame_de246dc45def92d44d802cefb7b0ae4b) {
        Py_DECREF(frame_de246dc45def92d44d802cefb7b0ae4b);
    }
    cache_frame_de246dc45def92d44d802cefb7b0ae4b = NULL;

    assertFrameObject(frame_de246dc45def92d44d802cefb7b0ae4b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_82587817d4eefe554b1bf051b3a97d84;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_82587817d4eefe554b1bf051b3a97d84 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_82587817d4eefe554b1bf051b3a97d84, codeobj_82587817d4eefe554b1bf051b3a97d84, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_82587817d4eefe554b1bf051b3a97d84 = cache_frame_82587817d4eefe554b1bf051b3a97d84;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_82587817d4eefe554b1bf051b3a97d84);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_82587817d4eefe554b1bf051b3a97d84) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getOperationBinaryMatMultShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1002;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1003;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_82587817d4eefe554b1bf051b3a97d84->m_frame.f_lineno = 1002;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1002;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_82587817d4eefe554b1bf051b3a97d84);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_82587817d4eefe554b1bf051b3a97d84);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_82587817d4eefe554b1bf051b3a97d84);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_82587817d4eefe554b1bf051b3a97d84, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_82587817d4eefe554b1bf051b3a97d84->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_82587817d4eefe554b1bf051b3a97d84, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_82587817d4eefe554b1bf051b3a97d84,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_82587817d4eefe554b1bf051b3a97d84 == cache_frame_82587817d4eefe554b1bf051b3a97d84) {
        Py_DECREF(frame_82587817d4eefe554b1bf051b3a97d84);
    }
    cache_frame_82587817d4eefe554b1bf051b3a97d84 = NULL;

    assertFrameObject(frame_82587817d4eefe554b1bf051b3a97d84);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_108_getOperationBinaryAddLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_32b984094e77316abf5e33762f53b721;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_32b984094e77316abf5e33762f53b721 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_32b984094e77316abf5e33762f53b721, codeobj_32b984094e77316abf5e33762f53b721, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_32b984094e77316abf5e33762f53b721 = cache_frame_32b984094e77316abf5e33762f53b721;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_32b984094e77316abf5e33762f53b721);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_32b984094e77316abf5e33762f53b721) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1010;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1010;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1012;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryAddShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1013;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_32b984094e77316abf5e33762f53b721->m_frame.f_lineno = 1012;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1012;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_32b984094e77316abf5e33762f53b721);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_32b984094e77316abf5e33762f53b721);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_32b984094e77316abf5e33762f53b721);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_32b984094e77316abf5e33762f53b721, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_32b984094e77316abf5e33762f53b721->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_32b984094e77316abf5e33762f53b721, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_32b984094e77316abf5e33762f53b721,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_32b984094e77316abf5e33762f53b721 == cache_frame_32b984094e77316abf5e33762f53b721) {
        Py_DECREF(frame_32b984094e77316abf5e33762f53b721);
    }
    cache_frame_32b984094e77316abf5e33762f53b721 = NULL;

    assertFrameObject(frame_32b984094e77316abf5e33762f53b721);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_108_getOperationBinaryAddLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_109_getOperationBinarySubLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_2e3216b1267876dc850124ca8effd7c7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2e3216b1267876dc850124ca8effd7c7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2e3216b1267876dc850124ca8effd7c7, codeobj_2e3216b1267876dc850124ca8effd7c7, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_2e3216b1267876dc850124ca8effd7c7 = cache_frame_2e3216b1267876dc850124ca8effd7c7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2e3216b1267876dc850124ca8effd7c7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2e3216b1267876dc850124ca8effd7c7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1019;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1019;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1021;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinarySubShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1022;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_2e3216b1267876dc850124ca8effd7c7->m_frame.f_lineno = 1021;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1021;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e3216b1267876dc850124ca8effd7c7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e3216b1267876dc850124ca8effd7c7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e3216b1267876dc850124ca8effd7c7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2e3216b1267876dc850124ca8effd7c7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2e3216b1267876dc850124ca8effd7c7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2e3216b1267876dc850124ca8effd7c7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2e3216b1267876dc850124ca8effd7c7,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_2e3216b1267876dc850124ca8effd7c7 == cache_frame_2e3216b1267876dc850124ca8effd7c7) {
        Py_DECREF(frame_2e3216b1267876dc850124ca8effd7c7);
    }
    cache_frame_2e3216b1267876dc850124ca8effd7c7 = NULL;

    assertFrameObject(frame_2e3216b1267876dc850124ca8effd7c7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_109_getOperationBinarySubLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_110_getOperationBinaryMultLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_c3da3b096edbebbddbe97561bde3609f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c3da3b096edbebbddbe97561bde3609f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c3da3b096edbebbddbe97561bde3609f, codeobj_c3da3b096edbebbddbe97561bde3609f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_c3da3b096edbebbddbe97561bde3609f = cache_frame_c3da3b096edbebbddbe97561bde3609f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c3da3b096edbebbddbe97561bde3609f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c3da3b096edbebbddbe97561bde3609f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1026;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1026;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1028;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryMultShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1029;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_c3da3b096edbebbddbe97561bde3609f->m_frame.f_lineno = 1028;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1028;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c3da3b096edbebbddbe97561bde3609f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c3da3b096edbebbddbe97561bde3609f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c3da3b096edbebbddbe97561bde3609f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c3da3b096edbebbddbe97561bde3609f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c3da3b096edbebbddbe97561bde3609f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c3da3b096edbebbddbe97561bde3609f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c3da3b096edbebbddbe97561bde3609f,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_c3da3b096edbebbddbe97561bde3609f == cache_frame_c3da3b096edbebbddbe97561bde3609f) {
        Py_DECREF(frame_c3da3b096edbebbddbe97561bde3609f);
    }
    cache_frame_c3da3b096edbebbddbe97561bde3609f = NULL;

    assertFrameObject(frame_c3da3b096edbebbddbe97561bde3609f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_110_getOperationBinaryMultLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_111_getOperationBinaryFloorDivLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_c714d2a2f7bfad7079061d65fe46ada6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_c714d2a2f7bfad7079061d65fe46ada6 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c714d2a2f7bfad7079061d65fe46ada6, codeobj_c714d2a2f7bfad7079061d65fe46ada6, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_c714d2a2f7bfad7079061d65fe46ada6 = cache_frame_c714d2a2f7bfad7079061d65fe46ada6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c714d2a2f7bfad7079061d65fe46ada6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c714d2a2f7bfad7079061d65fe46ada6) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1033;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1033;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1035;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryFloorDivShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1036;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_c714d2a2f7bfad7079061d65fe46ada6->m_frame.f_lineno = 1035;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1035;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c714d2a2f7bfad7079061d65fe46ada6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c714d2a2f7bfad7079061d65fe46ada6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c714d2a2f7bfad7079061d65fe46ada6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c714d2a2f7bfad7079061d65fe46ada6, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c714d2a2f7bfad7079061d65fe46ada6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c714d2a2f7bfad7079061d65fe46ada6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c714d2a2f7bfad7079061d65fe46ada6,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_c714d2a2f7bfad7079061d65fe46ada6 == cache_frame_c714d2a2f7bfad7079061d65fe46ada6) {
        Py_DECREF(frame_c714d2a2f7bfad7079061d65fe46ada6);
    }
    cache_frame_c714d2a2f7bfad7079061d65fe46ada6 = NULL;

    assertFrameObject(frame_c714d2a2f7bfad7079061d65fe46ada6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_111_getOperationBinaryFloorDivLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_112_getOperationBinaryOldDivLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_a11317166dcd24d5b94654425530a792;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a11317166dcd24d5b94654425530a792 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a11317166dcd24d5b94654425530a792, codeobj_a11317166dcd24d5b94654425530a792, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_a11317166dcd24d5b94654425530a792 = cache_frame_a11317166dcd24d5b94654425530a792;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a11317166dcd24d5b94654425530a792);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a11317166dcd24d5b94654425530a792) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1040;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1040;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1042;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryOldDivShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1043;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_a11317166dcd24d5b94654425530a792->m_frame.f_lineno = 1042;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1042;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a11317166dcd24d5b94654425530a792);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a11317166dcd24d5b94654425530a792);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a11317166dcd24d5b94654425530a792);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a11317166dcd24d5b94654425530a792, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a11317166dcd24d5b94654425530a792->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a11317166dcd24d5b94654425530a792, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a11317166dcd24d5b94654425530a792,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_a11317166dcd24d5b94654425530a792 == cache_frame_a11317166dcd24d5b94654425530a792) {
        Py_DECREF(frame_a11317166dcd24d5b94654425530a792);
    }
    cache_frame_a11317166dcd24d5b94654425530a792 = NULL;

    assertFrameObject(frame_a11317166dcd24d5b94654425530a792);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_112_getOperationBinaryOldDivLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_113_getOperationBinaryTrueDivLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_4e32de501717c1aec308daeedf0101e1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_4e32de501717c1aec308daeedf0101e1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_4e32de501717c1aec308daeedf0101e1, codeobj_4e32de501717c1aec308daeedf0101e1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_4e32de501717c1aec308daeedf0101e1 = cache_frame_4e32de501717c1aec308daeedf0101e1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_4e32de501717c1aec308daeedf0101e1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_4e32de501717c1aec308daeedf0101e1) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1047;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1047;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1049;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryTrueDivShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1050;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_4e32de501717c1aec308daeedf0101e1->m_frame.f_lineno = 1049;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1049;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4e32de501717c1aec308daeedf0101e1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_4e32de501717c1aec308daeedf0101e1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_4e32de501717c1aec308daeedf0101e1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_4e32de501717c1aec308daeedf0101e1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_4e32de501717c1aec308daeedf0101e1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_4e32de501717c1aec308daeedf0101e1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_4e32de501717c1aec308daeedf0101e1,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_4e32de501717c1aec308daeedf0101e1 == cache_frame_4e32de501717c1aec308daeedf0101e1) {
        Py_DECREF(frame_4e32de501717c1aec308daeedf0101e1);
    }
    cache_frame_4e32de501717c1aec308daeedf0101e1 = NULL;

    assertFrameObject(frame_4e32de501717c1aec308daeedf0101e1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_113_getOperationBinaryTrueDivLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_114_getOperationBinaryModLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_e4b9971ff2e44c8eb16719c5a7a83aca;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e4b9971ff2e44c8eb16719c5a7a83aca = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e4b9971ff2e44c8eb16719c5a7a83aca, codeobj_e4b9971ff2e44c8eb16719c5a7a83aca, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_e4b9971ff2e44c8eb16719c5a7a83aca = cache_frame_e4b9971ff2e44c8eb16719c5a7a83aca;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e4b9971ff2e44c8eb16719c5a7a83aca);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e4b9971ff2e44c8eb16719c5a7a83aca) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1054;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1054;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1056;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryModShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1057;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_e4b9971ff2e44c8eb16719c5a7a83aca->m_frame.f_lineno = 1056;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1056;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e4b9971ff2e44c8eb16719c5a7a83aca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e4b9971ff2e44c8eb16719c5a7a83aca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e4b9971ff2e44c8eb16719c5a7a83aca);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e4b9971ff2e44c8eb16719c5a7a83aca, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e4b9971ff2e44c8eb16719c5a7a83aca->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e4b9971ff2e44c8eb16719c5a7a83aca, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e4b9971ff2e44c8eb16719c5a7a83aca,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_e4b9971ff2e44c8eb16719c5a7a83aca == cache_frame_e4b9971ff2e44c8eb16719c5a7a83aca) {
        Py_DECREF(frame_e4b9971ff2e44c8eb16719c5a7a83aca);
    }
    cache_frame_e4b9971ff2e44c8eb16719c5a7a83aca = NULL;

    assertFrameObject(frame_e4b9971ff2e44c8eb16719c5a7a83aca);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_114_getOperationBinaryModLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_115_getOperationBinaryPowLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_816d37b6bd67981dc36715502904915c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_816d37b6bd67981dc36715502904915c = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_816d37b6bd67981dc36715502904915c, codeobj_816d37b6bd67981dc36715502904915c, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_816d37b6bd67981dc36715502904915c = cache_frame_816d37b6bd67981dc36715502904915c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_816d37b6bd67981dc36715502904915c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_816d37b6bd67981dc36715502904915c) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1061;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1061;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryPowShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1064;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_816d37b6bd67981dc36715502904915c->m_frame.f_lineno = 1063;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1063;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_816d37b6bd67981dc36715502904915c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_816d37b6bd67981dc36715502904915c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_816d37b6bd67981dc36715502904915c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_816d37b6bd67981dc36715502904915c, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_816d37b6bd67981dc36715502904915c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_816d37b6bd67981dc36715502904915c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_816d37b6bd67981dc36715502904915c,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_816d37b6bd67981dc36715502904915c == cache_frame_816d37b6bd67981dc36715502904915c) {
        Py_DECREF(frame_816d37b6bd67981dc36715502904915c);
    }
    cache_frame_816d37b6bd67981dc36715502904915c = NULL;

    assertFrameObject(frame_816d37b6bd67981dc36715502904915c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_115_getOperationBinaryPowLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_116_getOperationBinaryLShiftLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_772acebd2213c5bdb8b999e2489f6bca;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_772acebd2213c5bdb8b999e2489f6bca = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_772acebd2213c5bdb8b999e2489f6bca, codeobj_772acebd2213c5bdb8b999e2489f6bca, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_772acebd2213c5bdb8b999e2489f6bca = cache_frame_772acebd2213c5bdb8b999e2489f6bca;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_772acebd2213c5bdb8b999e2489f6bca);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_772acebd2213c5bdb8b999e2489f6bca) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1068;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1068;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1070;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryLShiftShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1071;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_772acebd2213c5bdb8b999e2489f6bca->m_frame.f_lineno = 1070;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1070;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_772acebd2213c5bdb8b999e2489f6bca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_772acebd2213c5bdb8b999e2489f6bca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_772acebd2213c5bdb8b999e2489f6bca);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_772acebd2213c5bdb8b999e2489f6bca, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_772acebd2213c5bdb8b999e2489f6bca->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_772acebd2213c5bdb8b999e2489f6bca, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_772acebd2213c5bdb8b999e2489f6bca,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_772acebd2213c5bdb8b999e2489f6bca == cache_frame_772acebd2213c5bdb8b999e2489f6bca) {
        Py_DECREF(frame_772acebd2213c5bdb8b999e2489f6bca);
    }
    cache_frame_772acebd2213c5bdb8b999e2489f6bca = NULL;

    assertFrameObject(frame_772acebd2213c5bdb8b999e2489f6bca);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_116_getOperationBinaryLShiftLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_117_getOperationBinaryRShiftLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_f9937f0aba6a561a1e4c7b53de1f19ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f9937f0aba6a561a1e4c7b53de1f19ef = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_f9937f0aba6a561a1e4c7b53de1f19ef, codeobj_f9937f0aba6a561a1e4c7b53de1f19ef, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_f9937f0aba6a561a1e4c7b53de1f19ef = cache_frame_f9937f0aba6a561a1e4c7b53de1f19ef;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f9937f0aba6a561a1e4c7b53de1f19ef);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f9937f0aba6a561a1e4c7b53de1f19ef) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1075;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1075;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1077;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryRShiftShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1078;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_f9937f0aba6a561a1e4c7b53de1f19ef->m_frame.f_lineno = 1077;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1077;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f9937f0aba6a561a1e4c7b53de1f19ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f9937f0aba6a561a1e4c7b53de1f19ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f9937f0aba6a561a1e4c7b53de1f19ef);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f9937f0aba6a561a1e4c7b53de1f19ef, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_f9937f0aba6a561a1e4c7b53de1f19ef->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f9937f0aba6a561a1e4c7b53de1f19ef, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_f9937f0aba6a561a1e4c7b53de1f19ef,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_f9937f0aba6a561a1e4c7b53de1f19ef == cache_frame_f9937f0aba6a561a1e4c7b53de1f19ef) {
        Py_DECREF(frame_f9937f0aba6a561a1e4c7b53de1f19ef);
    }
    cache_frame_f9937f0aba6a561a1e4c7b53de1f19ef = NULL;

    assertFrameObject(frame_f9937f0aba6a561a1e4c7b53de1f19ef);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_117_getOperationBinaryRShiftLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_118_getOperationBinaryBitOrLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_a4b3d419635a7d10c41957d99b9159db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a4b3d419635a7d10c41957d99b9159db = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a4b3d419635a7d10c41957d99b9159db, codeobj_a4b3d419635a7d10c41957d99b9159db, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_a4b3d419635a7d10c41957d99b9159db = cache_frame_a4b3d419635a7d10c41957d99b9159db;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a4b3d419635a7d10c41957d99b9159db);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a4b3d419635a7d10c41957d99b9159db) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1082;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1082;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1084;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryBitOrShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1085;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_a4b3d419635a7d10c41957d99b9159db->m_frame.f_lineno = 1084;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1084;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4b3d419635a7d10c41957d99b9159db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4b3d419635a7d10c41957d99b9159db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4b3d419635a7d10c41957d99b9159db);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a4b3d419635a7d10c41957d99b9159db, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a4b3d419635a7d10c41957d99b9159db->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a4b3d419635a7d10c41957d99b9159db, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a4b3d419635a7d10c41957d99b9159db,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_a4b3d419635a7d10c41957d99b9159db == cache_frame_a4b3d419635a7d10c41957d99b9159db) {
        Py_DECREF(frame_a4b3d419635a7d10c41957d99b9159db);
    }
    cache_frame_a4b3d419635a7d10c41957d99b9159db = NULL;

    assertFrameObject(frame_a4b3d419635a7d10c41957d99b9159db);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_118_getOperationBinaryBitOrLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_119_getOperationBinaryBitAndLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_11e7ab378f88e66229cd37c1b8ae6f5a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_11e7ab378f88e66229cd37c1b8ae6f5a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_11e7ab378f88e66229cd37c1b8ae6f5a, codeobj_11e7ab378f88e66229cd37c1b8ae6f5a, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_11e7ab378f88e66229cd37c1b8ae6f5a = cache_frame_11e7ab378f88e66229cd37c1b8ae6f5a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_11e7ab378f88e66229cd37c1b8ae6f5a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_11e7ab378f88e66229cd37c1b8ae6f5a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1089;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1089;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1091;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryBitAndShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1092;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_11e7ab378f88e66229cd37c1b8ae6f5a->m_frame.f_lineno = 1091;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1091;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_11e7ab378f88e66229cd37c1b8ae6f5a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_11e7ab378f88e66229cd37c1b8ae6f5a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_11e7ab378f88e66229cd37c1b8ae6f5a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_11e7ab378f88e66229cd37c1b8ae6f5a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_11e7ab378f88e66229cd37c1b8ae6f5a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_11e7ab378f88e66229cd37c1b8ae6f5a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_11e7ab378f88e66229cd37c1b8ae6f5a,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_11e7ab378f88e66229cd37c1b8ae6f5a == cache_frame_11e7ab378f88e66229cd37c1b8ae6f5a) {
        Py_DECREF(frame_11e7ab378f88e66229cd37c1b8ae6f5a);
    }
    cache_frame_11e7ab378f88e66229cd37c1b8ae6f5a = NULL;

    assertFrameObject(frame_11e7ab378f88e66229cd37c1b8ae6f5a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_119_getOperationBinaryBitAndLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_120_getOperationBinaryBitXorLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_19d7eb5a646720b3401b683db4b2185f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_19d7eb5a646720b3401b683db4b2185f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_19d7eb5a646720b3401b683db4b2185f, codeobj_19d7eb5a646720b3401b683db4b2185f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_19d7eb5a646720b3401b683db4b2185f = cache_frame_19d7eb5a646720b3401b683db4b2185f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_19d7eb5a646720b3401b683db4b2185f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_19d7eb5a646720b3401b683db4b2185f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1096;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1096;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1098;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryBitXorShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1099;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_19d7eb5a646720b3401b683db4b2185f->m_frame.f_lineno = 1098;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1098;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_19d7eb5a646720b3401b683db4b2185f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_19d7eb5a646720b3401b683db4b2185f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_19d7eb5a646720b3401b683db4b2185f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_19d7eb5a646720b3401b683db4b2185f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_19d7eb5a646720b3401b683db4b2185f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_19d7eb5a646720b3401b683db4b2185f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_19d7eb5a646720b3401b683db4b2185f,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_19d7eb5a646720b3401b683db4b2185f == cache_frame_19d7eb5a646720b3401b683db4b2185f) {
        Py_DECREF(frame_19d7eb5a646720b3401b683db4b2185f);
    }
    cache_frame_19d7eb5a646720b3401b683db4b2185f = NULL;

    assertFrameObject(frame_19d7eb5a646720b3401b683db4b2185f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_120_getOperationBinaryBitXorLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_121_getOperationBinaryMatMultLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_2e8d5b7e70c842f835f5724785f66100;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2e8d5b7e70c842f835f5724785f66100 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2e8d5b7e70c842f835f5724785f66100, codeobj_2e8d5b7e70c842f835f5724785f66100, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_2e8d5b7e70c842f835f5724785f66100 = cache_frame_2e8d5b7e70c842f835f5724785f66100;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2e8d5b7e70c842f835f5724785f66100);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2e8d5b7e70c842f835f5724785f66100) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1103;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1103;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1105;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getOperationBinaryMatMultShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1106;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_2e8d5b7e70c842f835f5724785f66100->m_frame.f_lineno = 1105;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1105;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e8d5b7e70c842f835f5724785f66100);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e8d5b7e70c842f835f5724785f66100);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2e8d5b7e70c842f835f5724785f66100);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2e8d5b7e70c842f835f5724785f66100, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2e8d5b7e70c842f835f5724785f66100->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2e8d5b7e70c842f835f5724785f66100, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2e8d5b7e70c842f835f5724785f66100,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_2e8d5b7e70c842f835f5724785f66100 == cache_frame_2e8d5b7e70c842f835f5724785f66100) {
        Py_DECREF(frame_2e8d5b7e70c842f835f5724785f66100);
    }
    cache_frame_2e8d5b7e70c842f835f5724785f66100 = NULL;

    assertFrameObject(frame_2e8d5b7e70c842f835f5724785f66100);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_121_getOperationBinaryMatMultLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_CellObject *par_right_shape = PyCell_NEW1(python_pars[1]);
    struct Nuitka_FrameObject *frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98, codeobj_e8edcee2bcc3a3c47a8e3d80ccbd9d98, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98 = cache_frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(PyCell_GET(par_right_shape));
        tmp_compexpr_left_1 = PyCell_GET(par_right_shape);
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1110;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_mvar_value_2;
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);

            if (unlikely(tmp_mvar_value_2 == NULL)) {
                tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_operation_result_unknown);
            }

            if (tmp_mvar_value_2 == NULL) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 78775 ], 46, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 1111;
                type_description_1 = "oc";
                goto frame_exception_exit_1;
            }

            tmp_return_value = tmp_mvar_value_2;
            Py_INCREF(tmp_return_value);
            goto frame_return_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1113;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        tmp_dict_value_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape$$$function_1_lambda();

        ((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0] = par_right_shape;
        Py_INCREF(((struct Nuitka_FunctionObject *)tmp_dict_value_1)->m_closure[0]);


        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98->m_frame.f_lineno = 1113;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1113;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98 == cache_frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98) {
        Py_DECREF(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98);
    }
    cache_frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98 = NULL;

    assertFrameObject(frame_e8edcee2bcc3a3c47a8e3d80ccbd9d98);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_left_shape = python_pars[0];
    struct Nuitka_FrameObject *frame_70217d00d45fc96da8509d7a100c38b7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_70217d00d45fc96da8509d7a100c38b7 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_70217d00d45fc96da8509d7a100c38b7, codeobj_70217d00d45fc96da8509d7a100c38b7, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_70217d00d45fc96da8509d7a100c38b7 = cache_frame_70217d00d45fc96da8509d7a100c38b7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_70217d00d45fc96da8509d7a100c38b7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_70217d00d45fc96da8509d7a100c38b7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_1 = par_left_shape;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_getComparisonLtShape);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1114;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        if (PyCell_GET(self->m_closure[0]) == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("free variable '%s' referenced before assignment in enclosing scope", "right_shape");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1114;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_1 = PyCell_GET(self->m_closure[0]);
        frame_70217d00d45fc96da8509d7a100c38b7->m_frame.f_lineno = 1114;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1114;
            type_description_1 = "oc";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_70217d00d45fc96da8509d7a100c38b7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_70217d00d45fc96da8509d7a100c38b7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_70217d00d45fc96da8509d7a100c38b7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_70217d00d45fc96da8509d7a100c38b7, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_70217d00d45fc96da8509d7a100c38b7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_70217d00d45fc96da8509d7a100c38b7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_70217d00d45fc96da8509d7a100c38b7,
        type_description_1,
        par_left_shape,
        self->m_closure[0]
    );


    // Release cached frame.
    if (frame_70217d00d45fc96da8509d7a100c38b7 == cache_frame_70217d00d45fc96da8509d7a100c38b7) {
        Py_DECREF(frame_70217d00d45fc96da8509d7a100c38b7);
    }
    cache_frame_70217d00d45fc96da8509d7a100c38b7 = NULL;

    assertFrameObject(frame_70217d00d45fc96da8509d7a100c38b7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_123_getComparisonLtLShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_left_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_0931520935c7e99ab3dcaee9ad1b2b86;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_0931520935c7e99ab3dcaee9ad1b2b86 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_0931520935c7e99ab3dcaee9ad1b2b86, codeobj_0931520935c7e99ab3dcaee9ad1b2b86, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_0931520935c7e99ab3dcaee9ad1b2b86 = cache_frame_0931520935c7e99ab3dcaee9ad1b2b86;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0931520935c7e99ab3dcaee9ad1b2b86);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0931520935c7e99ab3dcaee9ad1b2b86) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_left_shape);
        tmp_compexpr_left_1 = par_left_shape;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1120;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }

        tmp_compexpr_right_1 = tmp_mvar_value_1;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        {
            PyObject *tmp_raise_type_1;
            tmp_raise_type_1 = PyExc_AssertionError;
            exception_type = tmp_raise_type_1;
            Py_INCREF(tmp_raise_type_1);
            exception_lineno = 1120;
            RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        branch_no_1:;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_source_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_source_name_2;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain__collectShapeOperation);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1122;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_operation;
        CHECK_OBJECT(par_left_shape);
        tmp_source_name_2 = par_left_shape;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain_getComparisonLtShape);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1122;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_0931520935c7e99ab3dcaee9ad1b2b86->m_frame.f_lineno = 1122;
        tmp_return_value = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1122;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0931520935c7e99ab3dcaee9ad1b2b86);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0931520935c7e99ab3dcaee9ad1b2b86);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0931520935c7e99ab3dcaee9ad1b2b86);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0931520935c7e99ab3dcaee9ad1b2b86, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_0931520935c7e99ab3dcaee9ad1b2b86->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0931520935c7e99ab3dcaee9ad1b2b86, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_0931520935c7e99ab3dcaee9ad1b2b86,
        type_description_1,
        par_self,
        par_left_shape
    );


    // Release cached frame.
    if (frame_0931520935c7e99ab3dcaee9ad1b2b86 == cache_frame_0931520935c7e99ab3dcaee9ad1b2b86) {
        Py_DECREF(frame_0931520935c7e99ab3dcaee9ad1b2b86);
    }
    cache_frame_0931520935c7e99ab3dcaee9ad1b2b86 = NULL;

    assertFrameObject(frame_0931520935c7e99ab3dcaee9ad1b2b86);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_123_getComparisonLtLShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_left_shape);
    Py_DECREF(par_left_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_124_getComparisonLteShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_634e0d0e6b9ca9e13c2e7613437423ba;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_634e0d0e6b9ca9e13c2e7613437423ba = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_634e0d0e6b9ca9e13c2e7613437423ba, codeobj_634e0d0e6b9ca9e13c2e7613437423ba, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_634e0d0e6b9ca9e13c2e7613437423ba = cache_frame_634e0d0e6b9ca9e13c2e7613437423ba;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_634e0d0e6b9ca9e13c2e7613437423ba);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_634e0d0e6b9ca9e13c2e7613437423ba) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_634e0d0e6b9ca9e13c2e7613437423ba->m_frame.f_lineno = 1125;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1125;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_634e0d0e6b9ca9e13c2e7613437423ba);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_634e0d0e6b9ca9e13c2e7613437423ba);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_634e0d0e6b9ca9e13c2e7613437423ba);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_634e0d0e6b9ca9e13c2e7613437423ba, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_634e0d0e6b9ca9e13c2e7613437423ba->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_634e0d0e6b9ca9e13c2e7613437423ba, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_634e0d0e6b9ca9e13c2e7613437423ba,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_634e0d0e6b9ca9e13c2e7613437423ba == cache_frame_634e0d0e6b9ca9e13c2e7613437423ba) {
        Py_DECREF(frame_634e0d0e6b9ca9e13c2e7613437423ba);
    }
    cache_frame_634e0d0e6b9ca9e13c2e7613437423ba = NULL;

    assertFrameObject(frame_634e0d0e6b9ca9e13c2e7613437423ba);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_124_getComparisonLteShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_125_getComparisonGtShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_c390965f85f4215d855d80d3672dc3ef;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c390965f85f4215d855d80d3672dc3ef = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c390965f85f4215d855d80d3672dc3ef, codeobj_c390965f85f4215d855d80d3672dc3ef, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_c390965f85f4215d855d80d3672dc3ef = cache_frame_c390965f85f4215d855d80d3672dc3ef;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c390965f85f4215d855d80d3672dc3ef);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c390965f85f4215d855d80d3672dc3ef) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_c390965f85f4215d855d80d3672dc3ef->m_frame.f_lineno = 1128;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1128;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c390965f85f4215d855d80d3672dc3ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c390965f85f4215d855d80d3672dc3ef);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c390965f85f4215d855d80d3672dc3ef);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c390965f85f4215d855d80d3672dc3ef, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c390965f85f4215d855d80d3672dc3ef->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c390965f85f4215d855d80d3672dc3ef, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c390965f85f4215d855d80d3672dc3ef,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_c390965f85f4215d855d80d3672dc3ef == cache_frame_c390965f85f4215d855d80d3672dc3ef) {
        Py_DECREF(frame_c390965f85f4215d855d80d3672dc3ef);
    }
    cache_frame_c390965f85f4215d855d80d3672dc3ef = NULL;

    assertFrameObject(frame_c390965f85f4215d855d80d3672dc3ef);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_125_getComparisonGtShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_126_getComparisonGteShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_98a1e21a840c28842f395e2877031f1d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_98a1e21a840c28842f395e2877031f1d = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_98a1e21a840c28842f395e2877031f1d, codeobj_98a1e21a840c28842f395e2877031f1d, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_98a1e21a840c28842f395e2877031f1d = cache_frame_98a1e21a840c28842f395e2877031f1d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_98a1e21a840c28842f395e2877031f1d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_98a1e21a840c28842f395e2877031f1d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_98a1e21a840c28842f395e2877031f1d->m_frame.f_lineno = 1131;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1131;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_98a1e21a840c28842f395e2877031f1d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_98a1e21a840c28842f395e2877031f1d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_98a1e21a840c28842f395e2877031f1d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_98a1e21a840c28842f395e2877031f1d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_98a1e21a840c28842f395e2877031f1d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_98a1e21a840c28842f395e2877031f1d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_98a1e21a840c28842f395e2877031f1d,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_98a1e21a840c28842f395e2877031f1d == cache_frame_98a1e21a840c28842f395e2877031f1d) {
        Py_DECREF(frame_98a1e21a840c28842f395e2877031f1d);
    }
    cache_frame_98a1e21a840c28842f395e2877031f1d = NULL;

    assertFrameObject(frame_98a1e21a840c28842f395e2877031f1d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_126_getComparisonGteShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_127_getComparisonEqShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_70e317dae3fb5986fcb73404909f3e30;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_70e317dae3fb5986fcb73404909f3e30 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_70e317dae3fb5986fcb73404909f3e30, codeobj_70e317dae3fb5986fcb73404909f3e30, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_70e317dae3fb5986fcb73404909f3e30 = cache_frame_70e317dae3fb5986fcb73404909f3e30;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_70e317dae3fb5986fcb73404909f3e30);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_70e317dae3fb5986fcb73404909f3e30) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_70e317dae3fb5986fcb73404909f3e30->m_frame.f_lineno = 1134;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1134;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_70e317dae3fb5986fcb73404909f3e30);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_70e317dae3fb5986fcb73404909f3e30);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_70e317dae3fb5986fcb73404909f3e30);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_70e317dae3fb5986fcb73404909f3e30, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_70e317dae3fb5986fcb73404909f3e30->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_70e317dae3fb5986fcb73404909f3e30, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_70e317dae3fb5986fcb73404909f3e30,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_70e317dae3fb5986fcb73404909f3e30 == cache_frame_70e317dae3fb5986fcb73404909f3e30) {
        Py_DECREF(frame_70e317dae3fb5986fcb73404909f3e30);
    }
    cache_frame_70e317dae3fb5986fcb73404909f3e30 = NULL;

    assertFrameObject(frame_70e317dae3fb5986fcb73404909f3e30);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_127_getComparisonEqShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_128_getComparisonNeqShape(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_right_shape = python_pars[1];
    struct Nuitka_FrameObject *frame_3bbac0237f2002868a95b78402153953;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3bbac0237f2002868a95b78402153953 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3bbac0237f2002868a95b78402153953, codeobj_3bbac0237f2002868a95b78402153953, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *));
    frame_3bbac0237f2002868a95b78402153953 = cache_frame_3bbac0237f2002868a95b78402153953;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3bbac0237f2002868a95b78402153953);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3bbac0237f2002868a95b78402153953) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_right_shape);
        tmp_args_element_name_1 = par_right_shape;
        frame_3bbac0237f2002868a95b78402153953->m_frame.f_lineno = 1137;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getComparisonLtShape, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1137;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3bbac0237f2002868a95b78402153953);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3bbac0237f2002868a95b78402153953);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3bbac0237f2002868a95b78402153953);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3bbac0237f2002868a95b78402153953, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3bbac0237f2002868a95b78402153953->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3bbac0237f2002868a95b78402153953, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3bbac0237f2002868a95b78402153953,
        type_description_1,
        par_self,
        par_right_shape
    );


    // Release cached frame.
    if (frame_3bbac0237f2002868a95b78402153953 == cache_frame_3bbac0237f2002868a95b78402153953) {
        Py_DECREF(frame_3bbac0237f2002868a95b78402153953);
    }
    cache_frame_3bbac0237f2002868a95b78402153953 = NULL;

    assertFrameObject(frame_3bbac0237f2002868a95b78402153953);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_128_getComparisonNeqShape);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_right_shape);
    Py_DECREF(par_right_shape);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_check = python_pars[1];
    PyObject *var_result = NULL;
    PyObject *var_type_shape = NULL;
    PyObject *var_r = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_a818f4846d9afff91b53bc51915b56db;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_a818f4846d9afff91b53bc51915b56db = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = Py_None;
        assert(var_result == NULL);
        Py_INCREF(tmp_assign_source_1);
        var_result = tmp_assign_source_1;
    }
    // Tried code:
    MAKE_OR_REUSE_FRAME(cache_frame_a818f4846d9afff91b53bc51915b56db, codeobj_a818f4846d9afff91b53bc51915b56db, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
    frame_a818f4846d9afff91b53bc51915b56db = cache_frame_a818f4846d9afff91b53bc51915b56db;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a818f4846d9afff91b53bc51915b56db);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a818f4846d9afff91b53bc51915b56db) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_iter_arg_1;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(par_self);
        tmp_source_name_1 = par_self;
        tmp_iter_arg_1 = LOOKUP_ATTRIBUTE(tmp_source_name_1, const_str_plain_type_shapes);
        if (tmp_iter_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1142;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
        Py_DECREF(tmp_iter_arg_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1142;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_2;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_3;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_3 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_3 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooo";
                exception_lineno = 1142;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_3;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_4 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_type_shape;
            var_type_shape = tmp_assign_source_4;
            Py_INCREF(var_type_shape);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_name_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_check);
        tmp_called_name_1 = par_check;
        CHECK_OBJECT(var_type_shape);
        tmp_args_element_name_1 = var_type_shape;
        frame_a818f4846d9afff91b53bc51915b56db->m_frame.f_lineno = 1143;
        tmp_assign_source_5 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1143;
            type_description_1 = "ooooo";
            goto try_except_handler_2;
        }
        {
            PyObject *old = var_r;
            var_r = tmp_assign_source_5;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_r);
        tmp_compexpr_left_1 = var_r;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        tmp_return_value = Py_None;
        Py_INCREF(tmp_return_value);
        goto try_return_handler_2;
        goto branch_end_1;
        branch_no_1:;
        {
            nuitka_bool tmp_condition_result_2;
            PyObject *tmp_compexpr_left_2;
            PyObject *tmp_compexpr_right_2;
            CHECK_OBJECT(var_r);
            tmp_compexpr_left_2 = var_r;
            tmp_compexpr_right_2 = Py_True;
            tmp_condition_result_2 = (tmp_compexpr_left_2 == tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
                goto branch_yes_2;
            } else {
                goto branch_no_2;
            }
            branch_yes_2:;
            {
                nuitka_bool tmp_condition_result_3;
                PyObject *tmp_compexpr_left_3;
                PyObject *tmp_compexpr_right_3;
                if (var_result == NULL) {

                    exception_type = PyExc_UnboundLocalError;
                    Py_INCREF(exception_type);
                    exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                    exception_tb = NULL;
                    NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                    CHAIN_EXCEPTION(exception_value);

                    exception_lineno = 1148;
                    type_description_1 = "ooooo";
                    goto try_except_handler_2;
                }

                tmp_compexpr_left_3 = var_result;
                tmp_compexpr_right_3 = Py_False;
                tmp_condition_result_3 = (tmp_compexpr_left_3 == tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_3;
                } else {
                    goto branch_no_3;
                }
                branch_yes_3:;
                tmp_return_value = Py_None;
                Py_INCREF(tmp_return_value);
                goto try_return_handler_2;
                goto branch_end_3;
                branch_no_3:;
                {
                    nuitka_bool tmp_condition_result_4;
                    PyObject *tmp_compexpr_left_4;
                    PyObject *tmp_compexpr_right_4;
                    if (var_result == NULL) {

                        exception_type = PyExc_UnboundLocalError;
                        Py_INCREF(exception_type);
                        exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                        exception_tb = NULL;
                        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                        CHAIN_EXCEPTION(exception_value);

                        exception_lineno = 1150;
                        type_description_1 = "ooooo";
                        goto try_except_handler_2;
                    }

                    tmp_compexpr_left_4 = var_result;
                    tmp_compexpr_right_4 = Py_None;
                    tmp_condition_result_4 = (tmp_compexpr_left_4 == tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                        goto branch_yes_4;
                    } else {
                        goto branch_no_4;
                    }
                    branch_yes_4:;
                    {
                        PyObject *tmp_assign_source_6;
                        tmp_assign_source_6 = Py_True;
                        {
                            PyObject *old = var_result;
                            var_result = tmp_assign_source_6;
                            Py_INCREF(var_result);
                            Py_XDECREF(old);
                        }

                    }
                    branch_no_4:;
                }
                branch_end_3:;
            }
            goto branch_end_2;
            branch_no_2:;
            {
                nuitka_bool tmp_condition_result_5;
                PyObject *tmp_compexpr_left_5;
                PyObject *tmp_compexpr_right_5;
                CHECK_OBJECT(var_r);
                tmp_compexpr_left_5 = var_r;
                tmp_compexpr_right_5 = Py_False;
                tmp_condition_result_5 = (tmp_compexpr_left_5 == tmp_compexpr_right_5) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
                    goto branch_yes_5;
                } else {
                    goto branch_no_5;
                }
                branch_yes_5:;
                {
                    nuitka_bool tmp_condition_result_6;
                    PyObject *tmp_compexpr_left_6;
                    PyObject *tmp_compexpr_right_6;
                    if (var_result == NULL) {

                        exception_type = PyExc_UnboundLocalError;
                        Py_INCREF(exception_type);
                        exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                        exception_tb = NULL;
                        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                        CHAIN_EXCEPTION(exception_value);

                        exception_lineno = 1153;
                        type_description_1 = "ooooo";
                        goto try_except_handler_2;
                    }

                    tmp_compexpr_left_6 = var_result;
                    tmp_compexpr_right_6 = Py_True;
                    tmp_condition_result_6 = (tmp_compexpr_left_6 == tmp_compexpr_right_6) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                    if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
                        goto branch_yes_6;
                    } else {
                        goto branch_no_6;
                    }
                    branch_yes_6:;
                    tmp_return_value = Py_None;
                    Py_INCREF(tmp_return_value);
                    goto try_return_handler_2;
                    goto branch_end_6;
                    branch_no_6:;
                    {
                        nuitka_bool tmp_condition_result_7;
                        PyObject *tmp_compexpr_left_7;
                        PyObject *tmp_compexpr_right_7;
                        if (var_result == NULL) {

                            exception_type = PyExc_UnboundLocalError;
                            Py_INCREF(exception_type);
                            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
                            exception_tb = NULL;
                            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                            CHAIN_EXCEPTION(exception_value);

                            exception_lineno = 1155;
                            type_description_1 = "ooooo";
                            goto try_except_handler_2;
                        }

                        tmp_compexpr_left_7 = var_result;
                        tmp_compexpr_right_7 = Py_None;
                        tmp_condition_result_7 = (tmp_compexpr_left_7 == tmp_compexpr_right_7) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
                        if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
                            goto branch_yes_7;
                        } else {
                            goto branch_no_7;
                        }
                        branch_yes_7:;
                        {
                            PyObject *tmp_assign_source_7;
                            tmp_assign_source_7 = Py_False;
                            {
                                PyObject *old = var_result;
                                var_result = tmp_assign_source_7;
                                Py_INCREF(var_result);
                                Py_XDECREF(old);
                            }

                        }
                        branch_no_7:;
                    }
                    branch_end_6:;
                }
                branch_no_5:;
            }
            branch_end_2:;
        }
        branch_end_1:;
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1142;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    CHECK_OBJECT((PyObject *)tmp_for_loop_1__iter_value);
    Py_DECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT((PyObject *)tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    if (var_result == NULL) {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF(exception_type);
        exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "result");
        exception_tb = NULL;
        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        CHAIN_EXCEPTION(exception_value);

        exception_lineno = 1158;
        type_description_1 = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_result;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a818f4846d9afff91b53bc51915b56db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a818f4846d9afff91b53bc51915b56db);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a818f4846d9afff91b53bc51915b56db);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a818f4846d9afff91b53bc51915b56db, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a818f4846d9afff91b53bc51915b56db->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a818f4846d9afff91b53bc51915b56db, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a818f4846d9afff91b53bc51915b56db,
        type_description_1,
        par_self,
        par_check,
        var_result,
        var_type_shape,
        var_r
    );


    // Release cached frame.
    if (frame_a818f4846d9afff91b53bc51915b56db == cache_frame_a818f4846d9afff91b53bc51915b56db) {
        Py_DECREF(frame_a818f4846d9afff91b53bc51915b56db);
    }
    cache_frame_a818f4846d9afff91b53bc51915b56db = NULL;

    assertFrameObject(frame_a818f4846d9afff91b53bc51915b56db);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck);
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    Py_XDECREF(var_r);
    var_r = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_result);
    var_result = NULL;

    Py_XDECREF(var_type_shape);
    var_type_shape = NULL;

    Py_XDECREF(var_r);
    var_r = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_check);
    Py_DECREF(par_check);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_check);
    Py_DECREF(par_check);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_cfa96613c609587ff5d56994103aa43b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cfa96613c609587ff5d56994103aa43b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cfa96613c609587ff5d56994103aa43b, codeobj_cfa96613c609587ff5d56994103aa43b, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_cfa96613c609587ff5d56994103aa43b = cache_frame_cfa96613c609587ff5d56994103aa43b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cfa96613c609587ff5d56994103aa43b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cfa96613c609587ff5d56994103aa43b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool$$$function_1_lambda();



        frame_cfa96613c609587ff5d56994103aa43b->m_frame.f_lineno = 1161;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1161;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cfa96613c609587ff5d56994103aa43b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cfa96613c609587ff5d56994103aa43b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cfa96613c609587ff5d56994103aa43b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cfa96613c609587ff5d56994103aa43b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cfa96613c609587ff5d56994103aa43b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cfa96613c609587ff5d56994103aa43b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cfa96613c609587ff5d56994103aa43b,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_cfa96613c609587ff5d56994103aa43b == cache_frame_cfa96613c609587ff5d56994103aa43b) {
        Py_DECREF(frame_cfa96613c609587ff5d56994103aa43b);
    }
    cache_frame_cfa96613c609587ff5d56994103aa43b = NULL;

    assertFrameObject(frame_cfa96613c609587ff5d56994103aa43b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_9213af8db78767aff8cead2d99c1749e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_9213af8db78767aff8cead2d99c1749e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_9213af8db78767aff8cead2d99c1749e, codeobj_9213af8db78767aff8cead2d99c1749e, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_9213af8db78767aff8cead2d99c1749e = cache_frame_9213af8db78767aff8cead2d99c1749e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9213af8db78767aff8cead2d99c1749e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9213af8db78767aff8cead2d99c1749e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_9213af8db78767aff8cead2d99c1749e->m_frame.f_lineno = 1161;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotBool);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1161;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9213af8db78767aff8cead2d99c1749e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9213af8db78767aff8cead2d99c1749e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9213af8db78767aff8cead2d99c1749e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9213af8db78767aff8cead2d99c1749e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_9213af8db78767aff8cead2d99c1749e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9213af8db78767aff8cead2d99c1749e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_9213af8db78767aff8cead2d99c1749e,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_9213af8db78767aff8cead2d99c1749e == cache_frame_9213af8db78767aff8cead2d99c1749e) {
        Py_DECREF(frame_9213af8db78767aff8cead2d99c1749e);
    }
    cache_frame_9213af8db78767aff8cead2d99c1749e = NULL;

    assertFrameObject(frame_9213af8db78767aff8cead2d99c1749e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c215eed7076c01dc4a3d37b768a1c271;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c215eed7076c01dc4a3d37b768a1c271 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_c215eed7076c01dc4a3d37b768a1c271, codeobj_c215eed7076c01dc4a3d37b768a1c271, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_c215eed7076c01dc4a3d37b768a1c271 = cache_frame_c215eed7076c01dc4a3d37b768a1c271;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c215eed7076c01dc4a3d37b768a1c271);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c215eed7076c01dc4a3d37b768a1c271) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen$$$function_1_lambda();



        frame_c215eed7076c01dc4a3d37b768a1c271->m_frame.f_lineno = 1164;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1164;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c215eed7076c01dc4a3d37b768a1c271);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c215eed7076c01dc4a3d37b768a1c271);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c215eed7076c01dc4a3d37b768a1c271);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c215eed7076c01dc4a3d37b768a1c271, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_c215eed7076c01dc4a3d37b768a1c271->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c215eed7076c01dc4a3d37b768a1c271, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_c215eed7076c01dc4a3d37b768a1c271,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c215eed7076c01dc4a3d37b768a1c271 == cache_frame_c215eed7076c01dc4a3d37b768a1c271) {
        Py_DECREF(frame_c215eed7076c01dc4a3d37b768a1c271);
    }
    cache_frame_c215eed7076c01dc4a3d37b768a1c271 = NULL;

    assertFrameObject(frame_c215eed7076c01dc4a3d37b768a1c271);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_7cf65518226adba994bd642d64603a44;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_7cf65518226adba994bd642d64603a44 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_7cf65518226adba994bd642d64603a44, codeobj_7cf65518226adba994bd642d64603a44, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_7cf65518226adba994bd642d64603a44 = cache_frame_7cf65518226adba994bd642d64603a44;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7cf65518226adba994bd642d64603a44);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7cf65518226adba994bd642d64603a44) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_7cf65518226adba994bd642d64603a44->m_frame.f_lineno = 1164;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotLen);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1164;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7cf65518226adba994bd642d64603a44);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7cf65518226adba994bd642d64603a44);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7cf65518226adba994bd642d64603a44);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7cf65518226adba994bd642d64603a44, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_7cf65518226adba994bd642d64603a44->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7cf65518226adba994bd642d64603a44, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_7cf65518226adba994bd642d64603a44,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_7cf65518226adba994bd642d64603a44 == cache_frame_7cf65518226adba994bd642d64603a44) {
        Py_DECREF(frame_7cf65518226adba994bd642d64603a44);
    }
    cache_frame_7cf65518226adba994bd642d64603a44 = NULL;

    assertFrameObject(frame_7cf65518226adba994bd642d64603a44);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_ff4571568d88d9e77d9e1b964de0b0cf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_ff4571568d88d9e77d9e1b964de0b0cf = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_ff4571568d88d9e77d9e1b964de0b0cf, codeobj_ff4571568d88d9e77d9e1b964de0b0cf, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_ff4571568d88d9e77d9e1b964de0b0cf = cache_frame_ff4571568d88d9e77d9e1b964de0b0cf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ff4571568d88d9e77d9e1b964de0b0cf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ff4571568d88d9e77d9e1b964de0b0cf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter$$$function_1_lambda();



        frame_ff4571568d88d9e77d9e1b964de0b0cf->m_frame.f_lineno = 1167;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1167;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff4571568d88d9e77d9e1b964de0b0cf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff4571568d88d9e77d9e1b964de0b0cf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ff4571568d88d9e77d9e1b964de0b0cf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ff4571568d88d9e77d9e1b964de0b0cf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_ff4571568d88d9e77d9e1b964de0b0cf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ff4571568d88d9e77d9e1b964de0b0cf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_ff4571568d88d9e77d9e1b964de0b0cf,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_ff4571568d88d9e77d9e1b964de0b0cf == cache_frame_ff4571568d88d9e77d9e1b964de0b0cf) {
        Py_DECREF(frame_ff4571568d88d9e77d9e1b964de0b0cf);
    }
    cache_frame_ff4571568d88d9e77d9e1b964de0b0cf = NULL;

    assertFrameObject(frame_ff4571568d88d9e77d9e1b964de0b0cf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_1fabff4328626adf4b34b26b8241dfdf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1fabff4328626adf4b34b26b8241dfdf = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_1fabff4328626adf4b34b26b8241dfdf, codeobj_1fabff4328626adf4b34b26b8241dfdf, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_1fabff4328626adf4b34b26b8241dfdf = cache_frame_1fabff4328626adf4b34b26b8241dfdf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1fabff4328626adf4b34b26b8241dfdf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1fabff4328626adf4b34b26b8241dfdf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_1fabff4328626adf4b34b26b8241dfdf->m_frame.f_lineno = 1167;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotIter);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1167;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1fabff4328626adf4b34b26b8241dfdf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1fabff4328626adf4b34b26b8241dfdf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1fabff4328626adf4b34b26b8241dfdf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1fabff4328626adf4b34b26b8241dfdf, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_1fabff4328626adf4b34b26b8241dfdf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1fabff4328626adf4b34b26b8241dfdf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_1fabff4328626adf4b34b26b8241dfdf,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_1fabff4328626adf4b34b26b8241dfdf == cache_frame_1fabff4328626adf4b34b26b8241dfdf) {
        Py_DECREF(frame_1fabff4328626adf4b34b26b8241dfdf);
    }
    cache_frame_1fabff4328626adf4b34b26b8241dfdf = NULL;

    assertFrameObject(frame_1fabff4328626adf4b34b26b8241dfdf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_6ba11ba0e23039b19e0dc773c8a602ea;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6ba11ba0e23039b19e0dc773c8a602ea = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_6ba11ba0e23039b19e0dc773c8a602ea, codeobj_6ba11ba0e23039b19e0dc773c8a602ea, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_6ba11ba0e23039b19e0dc773c8a602ea = cache_frame_6ba11ba0e23039b19e0dc773c8a602ea;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6ba11ba0e23039b19e0dc773c8a602ea);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6ba11ba0e23039b19e0dc773c8a602ea) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext$$$function_1_lambda();



        frame_6ba11ba0e23039b19e0dc773c8a602ea->m_frame.f_lineno = 1170;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1170;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6ba11ba0e23039b19e0dc773c8a602ea);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6ba11ba0e23039b19e0dc773c8a602ea);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6ba11ba0e23039b19e0dc773c8a602ea);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6ba11ba0e23039b19e0dc773c8a602ea, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_6ba11ba0e23039b19e0dc773c8a602ea->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6ba11ba0e23039b19e0dc773c8a602ea, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_6ba11ba0e23039b19e0dc773c8a602ea,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_6ba11ba0e23039b19e0dc773c8a602ea == cache_frame_6ba11ba0e23039b19e0dc773c8a602ea) {
        Py_DECREF(frame_6ba11ba0e23039b19e0dc773c8a602ea);
    }
    cache_frame_6ba11ba0e23039b19e0dc773c8a602ea = NULL;

    assertFrameObject(frame_6ba11ba0e23039b19e0dc773c8a602ea);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3, codeobj_5c1a84bec52aef4d7d0ddcbc4e61e1e3, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3 = cache_frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3->m_frame.f_lineno = 1170;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotNext);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1170;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3 == cache_frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3) {
        Py_DECREF(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3);
    }
    cache_frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3 = NULL;

    assertFrameObject(frame_5c1a84bec52aef4d7d0ddcbc4e61e1e3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_90e4ebaa842519314147c2eda45dd7ae;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_90e4ebaa842519314147c2eda45dd7ae = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_90e4ebaa842519314147c2eda45dd7ae, codeobj_90e4ebaa842519314147c2eda45dd7ae, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_90e4ebaa842519314147c2eda45dd7ae = cache_frame_90e4ebaa842519314147c2eda45dd7ae;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_90e4ebaa842519314147c2eda45dd7ae);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_90e4ebaa842519314147c2eda45dd7ae) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains$$$function_1_lambda();



        frame_90e4ebaa842519314147c2eda45dd7ae->m_frame.f_lineno = 1173;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1173;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_90e4ebaa842519314147c2eda45dd7ae);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_90e4ebaa842519314147c2eda45dd7ae);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_90e4ebaa842519314147c2eda45dd7ae);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_90e4ebaa842519314147c2eda45dd7ae, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_90e4ebaa842519314147c2eda45dd7ae->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_90e4ebaa842519314147c2eda45dd7ae, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_90e4ebaa842519314147c2eda45dd7ae,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_90e4ebaa842519314147c2eda45dd7ae == cache_frame_90e4ebaa842519314147c2eda45dd7ae) {
        Py_DECREF(frame_90e4ebaa842519314147c2eda45dd7ae);
    }
    cache_frame_90e4ebaa842519314147c2eda45dd7ae = NULL;

    assertFrameObject(frame_90e4ebaa842519314147c2eda45dd7ae);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_055e2ca14ff87752a7d8fd63af7652a1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_055e2ca14ff87752a7d8fd63af7652a1 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_055e2ca14ff87752a7d8fd63af7652a1, codeobj_055e2ca14ff87752a7d8fd63af7652a1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_055e2ca14ff87752a7d8fd63af7652a1 = cache_frame_055e2ca14ff87752a7d8fd63af7652a1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_055e2ca14ff87752a7d8fd63af7652a1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_055e2ca14ff87752a7d8fd63af7652a1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_055e2ca14ff87752a7d8fd63af7652a1->m_frame.f_lineno = 1173;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotContains);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1173;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_055e2ca14ff87752a7d8fd63af7652a1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_055e2ca14ff87752a7d8fd63af7652a1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_055e2ca14ff87752a7d8fd63af7652a1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_055e2ca14ff87752a7d8fd63af7652a1, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_055e2ca14ff87752a7d8fd63af7652a1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_055e2ca14ff87752a7d8fd63af7652a1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_055e2ca14ff87752a7d8fd63af7652a1,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_055e2ca14ff87752a7d8fd63af7652a1 == cache_frame_055e2ca14ff87752a7d8fd63af7652a1) {
        Py_DECREF(frame_055e2ca14ff87752a7d8fd63af7652a1);
    }
    cache_frame_055e2ca14ff87752a7d8fd63af7652a1 = NULL;

    assertFrameObject(frame_055e2ca14ff87752a7d8fd63af7652a1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_261904682a894c605dc4a31d2ba13d77;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_261904682a894c605dc4a31d2ba13d77 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_261904682a894c605dc4a31d2ba13d77, codeobj_261904682a894c605dc4a31d2ba13d77, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_261904682a894c605dc4a31d2ba13d77 = cache_frame_261904682a894c605dc4a31d2ba13d77;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_261904682a894c605dc4a31d2ba13d77);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_261904682a894c605dc4a31d2ba13d77) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt$$$function_1_lambda();



        frame_261904682a894c605dc4a31d2ba13d77->m_frame.f_lineno = 1176;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1176;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_261904682a894c605dc4a31d2ba13d77);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_261904682a894c605dc4a31d2ba13d77);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_261904682a894c605dc4a31d2ba13d77);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_261904682a894c605dc4a31d2ba13d77, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_261904682a894c605dc4a31d2ba13d77->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_261904682a894c605dc4a31d2ba13d77, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_261904682a894c605dc4a31d2ba13d77,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_261904682a894c605dc4a31d2ba13d77 == cache_frame_261904682a894c605dc4a31d2ba13d77) {
        Py_DECREF(frame_261904682a894c605dc4a31d2ba13d77);
    }
    cache_frame_261904682a894c605dc4a31d2ba13d77 = NULL;

    assertFrameObject(frame_261904682a894c605dc4a31d2ba13d77);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_cdbf906c0739ab6356e0e347536125aa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_cdbf906c0739ab6356e0e347536125aa = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_cdbf906c0739ab6356e0e347536125aa, codeobj_cdbf906c0739ab6356e0e347536125aa, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_cdbf906c0739ab6356e0e347536125aa = cache_frame_cdbf906c0739ab6356e0e347536125aa;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cdbf906c0739ab6356e0e347536125aa);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cdbf906c0739ab6356e0e347536125aa) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_cdbf906c0739ab6356e0e347536125aa->m_frame.f_lineno = 1176;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotInt);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1176;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdbf906c0739ab6356e0e347536125aa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdbf906c0739ab6356e0e347536125aa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cdbf906c0739ab6356e0e347536125aa);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cdbf906c0739ab6356e0e347536125aa, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_cdbf906c0739ab6356e0e347536125aa->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cdbf906c0739ab6356e0e347536125aa, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_cdbf906c0739ab6356e0e347536125aa,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_cdbf906c0739ab6356e0e347536125aa == cache_frame_cdbf906c0739ab6356e0e347536125aa) {
        Py_DECREF(frame_cdbf906c0739ab6356e0e347536125aa);
    }
    cache_frame_cdbf906c0739ab6356e0e347536125aa = NULL;

    assertFrameObject(frame_cdbf906c0739ab6356e0e347536125aa);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_a347f3f55a405604ff7de8cac0d96fbd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_a347f3f55a405604ff7de8cac0d96fbd = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_a347f3f55a405604ff7de8cac0d96fbd, codeobj_a347f3f55a405604ff7de8cac0d96fbd, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_a347f3f55a405604ff7de8cac0d96fbd = cache_frame_a347f3f55a405604ff7de8cac0d96fbd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a347f3f55a405604ff7de8cac0d96fbd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a347f3f55a405604ff7de8cac0d96fbd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong$$$function_1_lambda();



        frame_a347f3f55a405604ff7de8cac0d96fbd->m_frame.f_lineno = 1179;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1179;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a347f3f55a405604ff7de8cac0d96fbd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a347f3f55a405604ff7de8cac0d96fbd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a347f3f55a405604ff7de8cac0d96fbd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a347f3f55a405604ff7de8cac0d96fbd, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_a347f3f55a405604ff7de8cac0d96fbd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a347f3f55a405604ff7de8cac0d96fbd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_a347f3f55a405604ff7de8cac0d96fbd,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_a347f3f55a405604ff7de8cac0d96fbd == cache_frame_a347f3f55a405604ff7de8cac0d96fbd) {
        Py_DECREF(frame_a347f3f55a405604ff7de8cac0d96fbd);
    }
    cache_frame_a347f3f55a405604ff7de8cac0d96fbd = NULL;

    assertFrameObject(frame_a347f3f55a405604ff7de8cac0d96fbd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_98f81faae2bf81700a9b4d64a2a300b8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_98f81faae2bf81700a9b4d64a2a300b8 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_98f81faae2bf81700a9b4d64a2a300b8, codeobj_98f81faae2bf81700a9b4d64a2a300b8, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_98f81faae2bf81700a9b4d64a2a300b8 = cache_frame_98f81faae2bf81700a9b4d64a2a300b8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_98f81faae2bf81700a9b4d64a2a300b8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_98f81faae2bf81700a9b4d64a2a300b8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_98f81faae2bf81700a9b4d64a2a300b8->m_frame.f_lineno = 1179;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotLong);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1179;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_98f81faae2bf81700a9b4d64a2a300b8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_98f81faae2bf81700a9b4d64a2a300b8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_98f81faae2bf81700a9b4d64a2a300b8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_98f81faae2bf81700a9b4d64a2a300b8, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_98f81faae2bf81700a9b4d64a2a300b8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_98f81faae2bf81700a9b4d64a2a300b8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_98f81faae2bf81700a9b4d64a2a300b8,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_98f81faae2bf81700a9b4d64a2a300b8 == cache_frame_98f81faae2bf81700a9b4d64a2a300b8) {
        Py_DECREF(frame_98f81faae2bf81700a9b4d64a2a300b8);
    }
    cache_frame_98f81faae2bf81700a9b4d64a2a300b8 = NULL;

    assertFrameObject(frame_98f81faae2bf81700a9b4d64a2a300b8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_3c58c0b1373f4cdeab30cf41740a1706;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_3c58c0b1373f4cdeab30cf41740a1706 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_3c58c0b1373f4cdeab30cf41740a1706, codeobj_3c58c0b1373f4cdeab30cf41740a1706, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_3c58c0b1373f4cdeab30cf41740a1706 = cache_frame_3c58c0b1373f4cdeab30cf41740a1706;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3c58c0b1373f4cdeab30cf41740a1706);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3c58c0b1373f4cdeab30cf41740a1706) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat$$$function_1_lambda();



        frame_3c58c0b1373f4cdeab30cf41740a1706->m_frame.f_lineno = 1182;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1182;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3c58c0b1373f4cdeab30cf41740a1706);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3c58c0b1373f4cdeab30cf41740a1706);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3c58c0b1373f4cdeab30cf41740a1706);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3c58c0b1373f4cdeab30cf41740a1706, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_3c58c0b1373f4cdeab30cf41740a1706->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3c58c0b1373f4cdeab30cf41740a1706, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_3c58c0b1373f4cdeab30cf41740a1706,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_3c58c0b1373f4cdeab30cf41740a1706 == cache_frame_3c58c0b1373f4cdeab30cf41740a1706) {
        Py_DECREF(frame_3c58c0b1373f4cdeab30cf41740a1706);
    }
    cache_frame_3c58c0b1373f4cdeab30cf41740a1706 = NULL;

    assertFrameObject(frame_3c58c0b1373f4cdeab30cf41740a1706);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_bcc5afc5622beff01e962364d56f676b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_bcc5afc5622beff01e962364d56f676b = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_bcc5afc5622beff01e962364d56f676b, codeobj_bcc5afc5622beff01e962364d56f676b, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_bcc5afc5622beff01e962364d56f676b = cache_frame_bcc5afc5622beff01e962364d56f676b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bcc5afc5622beff01e962364d56f676b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bcc5afc5622beff01e962364d56f676b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_bcc5afc5622beff01e962364d56f676b->m_frame.f_lineno = 1182;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotFloat);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1182;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bcc5afc5622beff01e962364d56f676b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bcc5afc5622beff01e962364d56f676b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bcc5afc5622beff01e962364d56f676b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bcc5afc5622beff01e962364d56f676b, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_bcc5afc5622beff01e962364d56f676b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bcc5afc5622beff01e962364d56f676b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_bcc5afc5622beff01e962364d56f676b,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_bcc5afc5622beff01e962364d56f676b == cache_frame_bcc5afc5622beff01e962364d56f676b) {
        Py_DECREF(frame_bcc5afc5622beff01e962364d56f676b);
    }
    cache_frame_bcc5afc5622beff01e962364d56f676b = NULL;

    assertFrameObject(frame_bcc5afc5622beff01e962364d56f676b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_2f307bb43cefd698e5c636502311625a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2f307bb43cefd698e5c636502311625a = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_2f307bb43cefd698e5c636502311625a, codeobj_2f307bb43cefd698e5c636502311625a, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_2f307bb43cefd698e5c636502311625a = cache_frame_2f307bb43cefd698e5c636502311625a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2f307bb43cefd698e5c636502311625a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2f307bb43cefd698e5c636502311625a) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex$$$function_1_lambda();



        frame_2f307bb43cefd698e5c636502311625a->m_frame.f_lineno = 1185;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1185;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f307bb43cefd698e5c636502311625a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f307bb43cefd698e5c636502311625a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f307bb43cefd698e5c636502311625a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2f307bb43cefd698e5c636502311625a, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_2f307bb43cefd698e5c636502311625a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2f307bb43cefd698e5c636502311625a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_2f307bb43cefd698e5c636502311625a,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_2f307bb43cefd698e5c636502311625a == cache_frame_2f307bb43cefd698e5c636502311625a) {
        Py_DECREF(frame_2f307bb43cefd698e5c636502311625a);
    }
    cache_frame_2f307bb43cefd698e5c636502311625a = NULL;

    assertFrameObject(frame_2f307bb43cefd698e5c636502311625a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_da56531b628e3ca972ef4a15f3f08a5e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_da56531b628e3ca972ef4a15f3f08a5e = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_da56531b628e3ca972ef4a15f3f08a5e, codeobj_da56531b628e3ca972ef4a15f3f08a5e, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_da56531b628e3ca972ef4a15f3f08a5e = cache_frame_da56531b628e3ca972ef4a15f3f08a5e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_da56531b628e3ca972ef4a15f3f08a5e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_da56531b628e3ca972ef4a15f3f08a5e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_da56531b628e3ca972ef4a15f3f08a5e->m_frame.f_lineno = 1185;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotComplex);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1185;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_da56531b628e3ca972ef4a15f3f08a5e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_da56531b628e3ca972ef4a15f3f08a5e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_da56531b628e3ca972ef4a15f3f08a5e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_da56531b628e3ca972ef4a15f3f08a5e, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_da56531b628e3ca972ef4a15f3f08a5e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_da56531b628e3ca972ef4a15f3f08a5e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_da56531b628e3ca972ef4a15f3f08a5e,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_da56531b628e3ca972ef4a15f3f08a5e == cache_frame_da56531b628e3ca972ef4a15f3f08a5e) {
        Py_DECREF(frame_da56531b628e3ca972ef4a15f3f08a5e);
    }
    cache_frame_da56531b628e3ca972ef4a15f3f08a5e = NULL;

    assertFrameObject(frame_da56531b628e3ca972ef4a15f3f08a5e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_09b833cccf2012f65ae2f8fe2ea9e6f0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_09b833cccf2012f65ae2f8fe2ea9e6f0 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_09b833cccf2012f65ae2f8fe2ea9e6f0, codeobj_09b833cccf2012f65ae2f8fe2ea9e6f0, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_09b833cccf2012f65ae2f8fe2ea9e6f0 = cache_frame_09b833cccf2012f65ae2f8fe2ea9e6f0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_09b833cccf2012f65ae2f8fe2ea9e6f0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_09b833cccf2012f65ae2f8fe2ea9e6f0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes$$$function_1_lambda();



        frame_09b833cccf2012f65ae2f8fe2ea9e6f0->m_frame.f_lineno = 1188;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1188;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_09b833cccf2012f65ae2f8fe2ea9e6f0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_09b833cccf2012f65ae2f8fe2ea9e6f0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_09b833cccf2012f65ae2f8fe2ea9e6f0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_09b833cccf2012f65ae2f8fe2ea9e6f0, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_09b833cccf2012f65ae2f8fe2ea9e6f0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_09b833cccf2012f65ae2f8fe2ea9e6f0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_09b833cccf2012f65ae2f8fe2ea9e6f0,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_09b833cccf2012f65ae2f8fe2ea9e6f0 == cache_frame_09b833cccf2012f65ae2f8fe2ea9e6f0) {
        Py_DECREF(frame_09b833cccf2012f65ae2f8fe2ea9e6f0);
    }
    cache_frame_09b833cccf2012f65ae2f8fe2ea9e6f0 = NULL;

    assertFrameObject(frame_09b833cccf2012f65ae2f8fe2ea9e6f0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_e7c71e6f889cab8489245cf49f121e69;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e7c71e6f889cab8489245cf49f121e69 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_e7c71e6f889cab8489245cf49f121e69, codeobj_e7c71e6f889cab8489245cf49f121e69, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_e7c71e6f889cab8489245cf49f121e69 = cache_frame_e7c71e6f889cab8489245cf49f121e69;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e7c71e6f889cab8489245cf49f121e69);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e7c71e6f889cab8489245cf49f121e69) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_e7c71e6f889cab8489245cf49f121e69->m_frame.f_lineno = 1188;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeSlotBytes);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1188;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7c71e6f889cab8489245cf49f121e69);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7c71e6f889cab8489245cf49f121e69);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e7c71e6f889cab8489245cf49f121e69);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e7c71e6f889cab8489245cf49f121e69, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_e7c71e6f889cab8489245cf49f121e69->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e7c71e6f889cab8489245cf49f121e69, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_e7c71e6f889cab8489245cf49f121e69,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_e7c71e6f889cab8489245cf49f121e69 == cache_frame_e7c71e6f889cab8489245cf49f121e69) {
        Py_DECREF(frame_e7c71e6f889cab8489245cf49f121e69);
    }
    cache_frame_e7c71e6f889cab8489245cf49f121e69 = NULL;

    assertFrameObject(frame_e7c71e6f889cab8489245cf49f121e69);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_366bfe275f86f90b862b24584f82a814;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_366bfe275f86f90b862b24584f82a814 = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_366bfe275f86f90b862b24584f82a814, codeobj_366bfe275f86f90b862b24584f82a814, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_366bfe275f86f90b862b24584f82a814 = cache_frame_366bfe275f86f90b862b24584f82a814;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_366bfe275f86f90b862b24584f82a814);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_366bfe275f86f90b862b24584f82a814) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule$$$function_1_lambda();



        frame_366bfe275f86f90b862b24584f82a814->m_frame.f_lineno = 1191;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__delegatedCheck, call_args);
        }

        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1191;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_366bfe275f86f90b862b24584f82a814);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_366bfe275f86f90b862b24584f82a814);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_366bfe275f86f90b862b24584f82a814);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_366bfe275f86f90b862b24584f82a814, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_366bfe275f86f90b862b24584f82a814->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_366bfe275f86f90b862b24584f82a814, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_366bfe275f86f90b862b24584f82a814,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_366bfe275f86f90b862b24584f82a814 == cache_frame_366bfe275f86f90b862b24584f82a814) {
        Py_DECREF(frame_366bfe275f86f90b862b24584f82a814);
    }
    cache_frame_366bfe275f86f90b862b24584f82a814 = NULL;

    assertFrameObject(frame_366bfe275f86f90b862b24584f82a814);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule$$$function_1_lambda(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_x = python_pars[0];
    struct Nuitka_FrameObject *frame_58219c7fcfbff9bb0579c8d429f43f1f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_58219c7fcfbff9bb0579c8d429f43f1f = NULL;

    // Actual function body.
    MAKE_OR_REUSE_FRAME(cache_frame_58219c7fcfbff9bb0579c8d429f43f1f, codeobj_58219c7fcfbff9bb0579c8d429f43f1f, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
    frame_58219c7fcfbff9bb0579c8d429f43f1f = cache_frame_58219c7fcfbff9bb0579c8d429f43f1f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_58219c7fcfbff9bb0579c8d429f43f1f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_58219c7fcfbff9bb0579c8d429f43f1f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_x);
        tmp_called_instance_1 = par_x;
        frame_58219c7fcfbff9bb0579c8d429f43f1f->m_frame.f_lineno = 1191;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_hasShapeModule);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1191;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_58219c7fcfbff9bb0579c8d429f43f1f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_58219c7fcfbff9bb0579c8d429f43f1f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_58219c7fcfbff9bb0579c8d429f43f1f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_58219c7fcfbff9bb0579c8d429f43f1f, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_58219c7fcfbff9bb0579c8d429f43f1f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_58219c7fcfbff9bb0579c8d429f43f1f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        (struct Nuitka_FrameObject *)frame_58219c7fcfbff9bb0579c8d429f43f1f,
        type_description_1,
        par_x
    );


    // Release cached frame.
    if (frame_58219c7fcfbff9bb0579c8d429f43f1f == cache_frame_58219c7fcfbff9bb0579c8d429f43f1f) {
        Py_DECREF(frame_58219c7fcfbff9bb0579c8d429f43f1f);
    }
    cache_frame_58219c7fcfbff9bb0579c8d429f43f1f = NULL;

    assertFrameObject(frame_58219c7fcfbff9bb0579c8d429f43f1f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule$$$function_1_lambda);
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_x);
    Py_DECREF(par_x);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape,
        const_str_plain_getOperationBinaryModShape,
#if PYTHON_VERSION >= 300
        const_str_digest_024d617040713eb605fdc16d5e8c5e35,
#endif
        codeobj_499f52653ddcc4cf7b070bb86ee33cb5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_dcf51f3801ec287eefe3cc0ece44bb21,
#endif
        codeobj_cf083e9cfbad2c159d4aced3a9ce2f13,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape,
        const_str_plain_getOperationBinaryPowShape,
#if PYTHON_VERSION >= 300
        const_str_digest_5f9120f7f6d51d9ce5732e159b382137,
#endif
        codeobj_1d78d973fdfa93709e28c3b9fb0259d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_6ed0e0b4680a298aee0daa9ebe484594,
#endif
        codeobj_ae60fc6cc678c38925186346b02b8b4d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape,
        const_str_plain_getOperationBinaryLShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_67fabd6d0d4cff0f1dd156de9e6b195c,
#endif
        codeobj_a591b45e141f9e1407e183961bfaacf7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_255d85ab519561f7569c6132871b3a12,
#endif
        codeobj_c6fedd91871b754cb84e7622a10d1bf8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape,
        const_str_plain_getOperationBinaryRShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_625fe1e69ace93fc64749f3af6009f31,
#endif
        codeobj_89a8f8ac78edc545758a6558f344ee65,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_ea4093cba5ec1e09e23d65d8548dcd5b,
#endif
        codeobj_a00d35d4a235c5f8456762b71f4a78d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape,
        const_str_plain_getOperationBinaryBitOrShape,
#if PYTHON_VERSION >= 300
        const_str_digest_acc972e8d43650389227b81299d1ae15,
#endif
        codeobj_022829a966c1f23e7ccf00bde09aee2d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_46234c0d9fa622e2c891a3eeef342f81,
#endif
        codeobj_b106615f89fdb156afc27cd670a27ae1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape,
        const_str_plain_getOperationBinaryBitAndShape,
#if PYTHON_VERSION >= 300
        const_str_digest_194ab90c00e030718b1d173955c51229,
#endif
        codeobj_59ddd5bade3e7d7071096f791af6bb2f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_50adb2c3ec0e699614cd7fbbefc0169b,
#endif
        codeobj_5177af75f0d50388640dc79607719db2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape,
        const_str_plain_getOperationBinaryBitXorShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d00dd524112ac2daf0807f02a08713f5,
#endif
        codeobj_3dfb915e058f7cd39b9377754263a24f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_ce07a58f856c25460ff35b8a5e594d26,
#endif
        codeobj_48a7b3d2a10292d9b503c411427e1f81,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape,
        const_str_plain_getOperationBinaryMatMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_3c0042cdc3c9a57e46849cdc92b3eb3b,
#endif
        codeobj_de246dc45def92d44d802cefb7b0ae4b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_fea64aa82d89c33944e5ab8ceb84ea5f,
#endif
        codeobj_82587817d4eefe554b1bf051b3a97d84,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_108_getOperationBinaryAddLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_108_getOperationBinaryAddLShape,
        const_str_plain_getOperationBinaryAddLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_e05dfff18ab5f0084ec7af38e27e39ec,
#endif
        codeobj_32b984094e77316abf5e33762f53b721,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_109_getOperationBinarySubLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_109_getOperationBinarySubLShape,
        const_str_plain_getOperationBinarySubLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_e28b3e65378741fcd9441531f65e447f,
#endif
        codeobj_2e3216b1267876dc850124ca8effd7c7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_10_hasShapeSlotInt() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotInt,
#if PYTHON_VERSION >= 300
        const_str_digest_e30a07ccc1c2a998704b9606b2835b95,
#endif
        codeobj_ceb5972e74036bff8934f4bde148658d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_110_getOperationBinaryMultLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_110_getOperationBinaryMultLShape,
        const_str_plain_getOperationBinaryMultLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_0a1285450b6c1002a0164d8da0ba1cdc,
#endif
        codeobj_c3da3b096edbebbddbe97561bde3609f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_111_getOperationBinaryFloorDivLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_111_getOperationBinaryFloorDivLShape,
        const_str_plain_getOperationBinaryFloorDivLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_456552722d27a21eddbe73939e12677a,
#endif
        codeobj_c714d2a2f7bfad7079061d65fe46ada6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_112_getOperationBinaryOldDivLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_112_getOperationBinaryOldDivLShape,
        const_str_plain_getOperationBinaryOldDivLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_0594efac62700843ff32809de058caae,
#endif
        codeobj_a11317166dcd24d5b94654425530a792,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_113_getOperationBinaryTrueDivLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_113_getOperationBinaryTrueDivLShape,
        const_str_plain_getOperationBinaryTrueDivLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_76def7778bdd1aae29d1264a72a4ff16,
#endif
        codeobj_4e32de501717c1aec308daeedf0101e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_114_getOperationBinaryModLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_114_getOperationBinaryModLShape,
        const_str_plain_getOperationBinaryModLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_7bb85642334b99ad0049c2629ee11a6d,
#endif
        codeobj_e4b9971ff2e44c8eb16719c5a7a83aca,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_115_getOperationBinaryPowLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_115_getOperationBinaryPowLShape,
        const_str_plain_getOperationBinaryPowLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_e93196de0aa84d7986fb4af03f1bcb72,
#endif
        codeobj_816d37b6bd67981dc36715502904915c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_116_getOperationBinaryLShiftLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_116_getOperationBinaryLShiftLShape,
        const_str_plain_getOperationBinaryLShiftLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_a354cca5276535abe1bef4525c86cc54,
#endif
        codeobj_772acebd2213c5bdb8b999e2489f6bca,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_117_getOperationBinaryRShiftLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_117_getOperationBinaryRShiftLShape,
        const_str_plain_getOperationBinaryRShiftLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_034b2a937fdda560dc9a98763f96162c,
#endif
        codeobj_f9937f0aba6a561a1e4c7b53de1f19ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_118_getOperationBinaryBitOrLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_118_getOperationBinaryBitOrLShape,
        const_str_plain_getOperationBinaryBitOrLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_9b26d03e2a1655101f000317cbb0b0ec,
#endif
        codeobj_a4b3d419635a7d10c41957d99b9159db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_119_getOperationBinaryBitAndLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_119_getOperationBinaryBitAndLShape,
        const_str_plain_getOperationBinaryBitAndLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_2417025a2204fdfd1df0e2bcb92592e8,
#endif
        codeobj_11e7ab378f88e66229cd37c1b8ae6f5a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_11_hasShapeSlotLong() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotLong,
#if PYTHON_VERSION >= 300
        const_str_digest_0251aa253c1cab7b3975aa8a056bcd59,
#endif
        codeobj_2002d456b69ea529e08aed94c4b75e71,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_120_getOperationBinaryBitXorLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_120_getOperationBinaryBitXorLShape,
        const_str_plain_getOperationBinaryBitXorLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_213535de2986e9fe33ceaa61e0fcca40,
#endif
        codeobj_19d7eb5a646720b3401b683db4b2185f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_121_getOperationBinaryMatMultLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_121_getOperationBinaryMatMultLShape,
        const_str_plain_getOperationBinaryMatMultLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_9cae8449d07612259d5c056ed2934071,
#endif
        codeobj_2e8d5b7e70c842f835f5724785f66100,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape,
        const_str_plain_getComparisonLtShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d165cf867ceeb8fac2673d04c18391b5,
#endif
        codeobj_e8edcee2bcc3a3c47a8e3d80ccbd9d98,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_b58f205b283109589d6616923c5e38ce,
#endif
        codeobj_70217d00d45fc96da8509d7a100c38b7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_123_getComparisonLtLShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_123_getComparisonLtLShape,
        const_str_plain_getComparisonLtLShape,
#if PYTHON_VERSION >= 300
        const_str_digest_96451d49b3183e84063fa4b336b9c2d0,
#endif
        codeobj_0931520935c7e99ab3dcaee9ad1b2b86,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_124_getComparisonLteShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_124_getComparisonLteShape,
        const_str_plain_getComparisonLteShape,
#if PYTHON_VERSION >= 300
        const_str_digest_322c0da1f98adfc4e00077e5581652e3,
#endif
        codeobj_634e0d0e6b9ca9e13c2e7613437423ba,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_125_getComparisonGtShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_125_getComparisonGtShape,
        const_str_plain_getComparisonGtShape,
#if PYTHON_VERSION >= 300
        const_str_digest_5eca226fe02ac5de7f4929cfe61fd4e8,
#endif
        codeobj_c390965f85f4215d855d80d3672dc3ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_126_getComparisonGteShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_126_getComparisonGteShape,
        const_str_plain_getComparisonGteShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d83cc59cf648a94cfc73f654ffd0dc34,
#endif
        codeobj_98a1e21a840c28842f395e2877031f1d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_127_getComparisonEqShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_127_getComparisonEqShape,
        const_str_plain_getComparisonEqShape,
#if PYTHON_VERSION >= 300
        const_str_digest_ca1207a01fdb60ef20cd2cafffcf4764,
#endif
        codeobj_70e317dae3fb5986fcb73404909f3e30,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_128_getComparisonNeqShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_128_getComparisonNeqShape,
        const_str_plain_getComparisonNeqShape,
#if PYTHON_VERSION >= 300
        const_str_digest_abb5cd115195ebd171fd19240d19c05c,
#endif
        codeobj_3bbac0237f2002868a95b78402153953,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck,
        const_str_plain__delegatedCheck,
#if PYTHON_VERSION >= 300
        const_str_digest_9dbdf6b6ac13c99241af100a163ecf6e,
#endif
        codeobj_a818f4846d9afff91b53bc51915b56db,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_12_hasShapeSlotFloat() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotFloat,
#if PYTHON_VERSION >= 300
        const_str_digest_df9171a19dc9056c92c0285a45a6639f,
#endif
        codeobj_2f4520eafc261c3a8b579825550a022e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool,
        const_str_plain_hasShapeSlotBool,
#if PYTHON_VERSION >= 300
        const_str_digest_b74e3483c0b7dc405673b6681b893ef1,
#endif
        codeobj_cfa96613c609587ff5d56994103aa43b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_e8c3d9420556b2f8c1303cddaa3f8e40,
#endif
        codeobj_9213af8db78767aff8cead2d99c1749e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen,
        const_str_plain_hasShapeSlotLen,
#if PYTHON_VERSION >= 300
        const_str_digest_1f08c45497409e65e5b6cfc132cdfd37,
#endif
        codeobj_c215eed7076c01dc4a3d37b768a1c271,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_d4eb92a9170cb090d83ff226aec0b12a,
#endif
        codeobj_7cf65518226adba994bd642d64603a44,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter,
        const_str_plain_hasShapeSlotIter,
#if PYTHON_VERSION >= 300
        const_str_digest_22da858206cc847e210a9fa730c577aa,
#endif
        codeobj_ff4571568d88d9e77d9e1b964de0b0cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_597956a8912e09241dc76842ab712a3c,
#endif
        codeobj_1fabff4328626adf4b34b26b8241dfdf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext,
        const_str_plain_hasShapeSlotNext,
#if PYTHON_VERSION >= 300
        const_str_digest_1821e1c4b4c84919918ee3082ed9b2aa,
#endif
        codeobj_6ba11ba0e23039b19e0dc773c8a602ea,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_aa5851757158e07e6201e4ca073299b2,
#endif
        codeobj_5c1a84bec52aef4d7d0ddcbc4e61e1e3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains,
        const_str_plain_hasShapeSlotContains,
#if PYTHON_VERSION >= 300
        const_str_digest_b20249b89da7c7d41d472a96cb3f04f7,
#endif
        codeobj_90e4ebaa842519314147c2eda45dd7ae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_5b903e5051ed33327d0845acb1aa06d6,
#endif
        codeobj_055e2ca14ff87752a7d8fd63af7652a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt,
        const_str_plain_hasShapeSlotInt,
#if PYTHON_VERSION >= 300
        const_str_digest_69612c7138597cea4ca455a4be16865d,
#endif
        codeobj_261904682a894c605dc4a31d2ba13d77,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_9028633f7a2e20ffed935d77dc3cfa39,
#endif
        codeobj_cdbf906c0739ab6356e0e347536125aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong,
        const_str_plain_hasShapeSlotLong,
#if PYTHON_VERSION >= 300
        const_str_digest_86fa1c52e4adde46f77b4c8eff21e870,
#endif
        codeobj_a347f3f55a405604ff7de8cac0d96fbd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_1a03e9ce2e16071a8c173e0843bab7a2,
#endif
        codeobj_98f81faae2bf81700a9b4d64a2a300b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat,
        const_str_plain_hasShapeSlotFloat,
#if PYTHON_VERSION >= 300
        const_str_digest_1b169eed60667f879366fb78beb151ef,
#endif
        codeobj_3c58c0b1373f4cdeab30cf41740a1706,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_cae779c1a1dc30fc8c1cddf76f7f3c16,
#endif
        codeobj_bcc5afc5622beff01e962364d56f676b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex,
        const_str_plain_hasShapeSlotComplex,
#if PYTHON_VERSION >= 300
        const_str_digest_2af96047d68e2c8830c315efb5eb5e6e,
#endif
        codeobj_2f307bb43cefd698e5c636502311625a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_669e15ef7677859ad07cd30927cc4d72,
#endif
        codeobj_da56531b628e3ca972ef4a15f3f08a5e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes,
        const_str_plain_hasShapeSlotBytes,
#if PYTHON_VERSION >= 300
        const_str_digest_328609247c98d96b06f85f1dc9e9a651,
#endif
        codeobj_09b833cccf2012f65ae2f8fe2ea9e6f0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_f96a037699f72408c3e0a6b5d83057b3,
#endif
        codeobj_e7c71e6f889cab8489245cf49f121e69,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_13_hasShapeSlotIter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotIter,
#if PYTHON_VERSION >= 300
        const_str_digest_def9b5bb7f50b71de97a052b638056e8,
#endif
        codeobj_e4ffd958de903bd2c2a7941492898be6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule,
        const_str_plain_hasShapeModule,
#if PYTHON_VERSION >= 300
        const_str_digest_cb155a5768e5f44496815fb1875631eb,
#endif
        codeobj_366bfe275f86f90b862b24584f82a814,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_682498401e8c313f897fef027fe921cc,
#endif
        codeobj_58219c7fcfbff9bb0579c8d429f43f1f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_14_hasShapeSlotNext() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotNext,
#if PYTHON_VERSION >= 300
        const_str_digest_2cd707492de6eec06aba9aa75d93cda7,
#endif
        codeobj_39c42cee787eff76aedb26ca2eb2746f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_15_hasShapeSlotContains() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotContains,
#if PYTHON_VERSION >= 300
        const_str_digest_cb30ed96be09f5491dc64c5417a592d5,
#endif
        codeobj_b52bbf96acad86ac80f5dbb8709c292f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape,
        const_str_plain_getOperationBinaryAddShape,
#if PYTHON_VERSION >= 300
        const_str_digest_a7c0071cf4b3200d86be5a79f1c38d4c,
#endif
        codeobj_678bd036360d1eb3a05a8cdfaa296054,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape,
        const_str_plain_getOperationBinarySubShape,
#if PYTHON_VERSION >= 300
        const_str_digest_7180205ef64e9c18df2d09fcaaa43691,
#endif
        codeobj_378f783feea5c5ee55f1db0e91ea08cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape,
        const_str_plain_getOperationBinaryMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_f8abc771bcfacef2d1c50cb3c2e4e301,
#endif
        codeobj_9c35ab8056efcc1e1a9cbbeae45063e2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape,
        const_str_plain_getOperationBinaryFloorDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_e0bf05a64dce3920b00a790d74a3c152,
#endif
        codeobj_0c1fd16734cb23f268c3b167c098d5b8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_1_getTypeName() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_getTypeName,
#if PYTHON_VERSION >= 300
        const_str_digest_f3c4681ec6b288d03e6a965eb469af08,
#endif
        codeobj_9aab73c7d497adf0ecd3b65c524655cc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape,
        const_str_plain_getOperationBinaryOldDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b6e852c15fbf4de53bee47e76b75421f,
#endif
        codeobj_b1fc41a4b1b55db7c1dab679545abd03,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape,
        const_str_plain_getOperationBinaryTrueDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_92d7bb3869456a3d13d0abb2a892ed4b,
#endif
        codeobj_5116cfd790e929ec7c172c3075615daf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape,
        const_str_plain_getOperationBinaryModShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d2f1e24741c28a03ec32e5b3e138ec1d,
#endif
        codeobj_41ed3b8a61648a26b73c29af4c38df95,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape,
        const_str_plain_getOperationBinaryPowShape,
#if PYTHON_VERSION >= 300
        const_str_digest_99df920857485ae5c8e557b8e1140b04,
#endif
        codeobj_cedcccd9f989b37336d1dea134c62a2f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape,
        const_str_plain_getOperationBinaryLShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d2189c374f6bb9323c899684884dea1a,
#endif
        codeobj_16ae7053c6540f737e1f47f13348d563,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape,
        const_str_plain_getOperationBinaryRShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d8b645143e9f1a455e3cb5b0c969754d,
#endif
        codeobj_4d67752b63622030491af6955ba617a7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape,
        const_str_plain_getOperationBinaryBitOrShape,
#if PYTHON_VERSION >= 300
        const_str_digest_0391c0c81b22fe4c6e9cfbfa036d7f29,
#endif
        codeobj_c18b64232e6fc0478d21a489ab050c32,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape,
        const_str_plain_getOperationBinaryBitAndShape,
#if PYTHON_VERSION >= 300
        const_str_digest_8d861b97287f8c44d00db282d2298711,
#endif
        codeobj_de429e1ffc0386afb873c85570f8584a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape,
        const_str_plain_getOperationBinaryBitXorShape,
#if PYTHON_VERSION >= 300
        const_str_digest_8f64e387ba2d40fbaf2e0c9911337215,
#endif
        codeobj_9b28af0540046a6af23498002ebb11c4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape,
        const_str_plain_getOperationBinaryMatMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_069829ea685b9f6e8c3137a8deda8d06,
#endif
        codeobj_92c1d4b76e96a3fed296e8929c9652c0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType,
        const_str_plain_getCType,
#if PYTHON_VERSION >= 300
        const_str_digest_4f26a96a64793f4392df8222281f5de5,
#endif
        codeobj_5c600498451b8d72313d3e673c48c257,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape,
        const_str_plain_getComparisonLtShape,
#if PYTHON_VERSION >= 300
        const_str_digest_575e9c00e04e5e00338462e0e3cdfa90,
#endif
        codeobj_5366e9a5a3a3a2940f454d9212513daa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape,
        const_str_plain_getComparisonLteShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d90d5c78caabd24db486a4ccbf59cd14,
#endif
        codeobj_34497d9734a343c6e4c38b4f0585ce64,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape,
        const_str_plain_getComparisonGtShape,
#if PYTHON_VERSION >= 300
        const_str_digest_950482538a86eb0630a1ab5b98519299,
#endif
        codeobj_6390b7f7acb0d560e13329b28fdb6941,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape,
        const_str_plain_getComparisonGteShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b8f9f1c9c4c0048542d1f2a992963cd9,
#endif
        codeobj_db559a66c57804d1299b0a78f87fee65,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape,
        const_str_plain_getComparisonEqShape,
#if PYTHON_VERSION >= 300
        const_str_digest_05a78548926bee9c0aa1504a38bc3272,
#endif
        codeobj_7c100bf546aed522cbd46c14979c3efc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape,
        const_str_plain_getComparisonNeqShape,
#if PYTHON_VERSION >= 300
        const_str_digest_4bb83b53e6a8045fe086d9e5bdc97f54,
#endif
        codeobj_29fb47d6e17a7db0be35c6eeddb22698,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives,
        const_str_plain_emitAlternatives,
#if PYTHON_VERSION >= 300
        const_str_digest_34c5d84ff7282938eda842134a3330c8,
#endif
        codeobj_3dd985f11eb0390621d8aa4f697a7080,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape,
        const_str_plain_getOperationBinaryAddShape,
#if PYTHON_VERSION >= 300
        const_str_digest_bab51e387d3153f087b88e7f459e5262,
#endif
        codeobj_02a760bb24dd602344ff02253e7d2d49,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape,
        const_str_plain_getOperationBinarySubShape,
#if PYTHON_VERSION >= 300
        const_str_digest_12887f500372f8562e066c16ba68b9a6,
#endif
        codeobj_92c12f700eb21f649d49d8acb8025fa1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape,
        const_str_plain_getOperationBinaryMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_9947a771fdf7affcb1a68d2b4d5a662a,
#endif
        codeobj_9b596b8c78a93eea39d745589a3900b6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter,
        const_str_plain_getShapeIter,
#if PYTHON_VERSION >= 300
        const_str_digest_09fa250c7788dd76d322da225470e409,
#endif
        codeobj_4a871f328f64bc7fb78c4391d9ae083c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape,
        const_str_plain_getOperationBinaryFloorDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d34491a40e0b3b367fb66022378077d3,
#endif
        codeobj_cb66089c7c49445489a6df4c43c43e5b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape,
        const_str_plain_getOperationBinaryOldDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_03fb79af517e133535ec295810dfac46,
#endif
        codeobj_9f37cab9541cc450eb9c857ae61b29a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape,
        const_str_plain_getOperationBinaryTrueDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b6d23c14d0d4bc9dad07080a16f71e1e,
#endif
        codeobj_f106a1a4d7fc00f78b1f75bd99972f11,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape,
        const_str_plain_getOperationBinaryModShape,
#if PYTHON_VERSION >= 300
        const_str_digest_8e7cf89322c3481963627b7f5dd2d7ce,
#endif
        codeobj_ccebd776c0e9937695f958a434521a69,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape,
        const_str_plain_getOperationBinaryPowShape,
#if PYTHON_VERSION >= 300
        const_str_digest_9478741cfa8b1b672c5ae1b2d6fcd0f3,
#endif
        codeobj_fcfb7c2b1f4bf8340de4834a4181b333,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape,
        const_str_plain_getOperationBinaryLShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b262ff30fa9e5c5b9c7b2430aa61ef08,
#endif
        codeobj_c6072bc075ab36c511024aa4ee91175d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape,
        const_str_plain_getOperationBinaryRShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_f9df910acf0215eaf464f92425dcd002,
#endif
        codeobj_d40437d95659f9bf5a7905552e30aca2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape,
        const_str_plain_getOperationBinaryBitOrShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b6d47b59a5c3db11af01e7a0db94bbe0,
#endif
        codeobj_e5d0fed2b249d1b8ba1ccf80b6875e05,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape,
        const_str_plain_getOperationBinaryBitAndShape,
#if PYTHON_VERSION >= 300
        const_str_digest_84b5e8d5c8b459d742fc3e3a1516a732,
#endif
        codeobj_6517a9e6af7657c6c498ec1df71e5715,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape,
        const_str_plain_getOperationBinaryBitXorShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b238134514f501a27042729c5b3f3441,
#endif
        codeobj_8d52d35578ce25dc5ed9bb1ffc8f2a50,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_4_hasShapeModule() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeModule,
#if PYTHON_VERSION >= 300
        const_str_digest_47c5cdb23723111667af8a2a10d27324,
#endif
        codeobj_09ec202a6c4c061684a9757d62bf95f9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape,
        const_str_plain_getOperationBinaryMatMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_762147b023ade88d738804d3e8476ff8,
#endif
        codeobj_92ab9ca6c3d62cc16d8e60249b83ab8c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape,
        const_str_plain_getComparisonLtShape,
#if PYTHON_VERSION >= 300
        const_str_digest_3f0b0dc1a1fa3987ac4353534e0f5905,
#endif
        codeobj_20fdbaf40e4c640828046210bbe44889,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_52_hasShapeSlotLen() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_52_hasShapeSlotLen,
        const_str_plain_hasShapeSlotLen,
#if PYTHON_VERSION >= 300
        const_str_digest_c04892013b17346e0feb2d7582ab7ae0,
#endif
        codeobj_7375bd3b7c5c494c7b6e41ec225ff82d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape,
        const_str_plain_getTypeShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b867b57ef1511273804bd83b2ec25374,
#endif
        codeobj_a7baa7c0f07185d9e8b484fee1877a94,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_54___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_54___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_0d2c9cef16d5cc0608d81849836c876e,
#endif
        codeobj_3d9d357ef5fd95d0ea8392fcfe0fb9f6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_55_getTypeShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_55_getTypeShape,
        const_str_plain_getTypeShape,
#if PYTHON_VERSION >= 300
        const_str_digest_fe95f50f92c2a05973e7b6fedacebe1d,
#endif
        codeobj_b584a9e3380c2590713c3f1fcc9529d0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant,
        const_str_plain_isConstant,
#if PYTHON_VERSION >= 300
        const_str_digest_5445345d5ab4fea2ae8f2eb419a7a1cd,
#endif
        codeobj_70252d84a66c9c64934c4c4eed81830e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_57_hasShapeSlotLen() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_57_hasShapeSlotLen,
        const_str_plain_hasShapeSlotLen,
#if PYTHON_VERSION >= 300
        const_str_digest_4ab5d94003c31387d8faf22e555d63b0,
#endif
        codeobj_e1ea14b18ebff6d3e87dbd7f9e59473c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_58___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_58___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_b16b9c9441e9c5fc2752839cfa5f5465,
#endif
        codeobj_208a723e26e261a3bf976d79358671a0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_59_hasShapeSlotBool() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotBool,
#if PYTHON_VERSION >= 300
        const_str_digest_fb06347c64ee3b801ccfd4a33d6bc377,
#endif
        codeobj_70f9e31a0a98ee3ca758fa8bf06d7ae9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_5_hasShapeSlotBytes() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotBytes,
#if PYTHON_VERSION >= 300
        const_str_digest_eac2c10d37faadc12734713c9705faa0,
#endif
        codeobj_8fd6898fba148c461cb27db922645580,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_60_hasShapeSlotLen() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotLen,
#if PYTHON_VERSION >= 300
        const_str_digest_652e076dbd067789ae3169ead7b44231,
#endif
        codeobj_c887985073edec097f150e9c98e0cfe9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_61_hasShapeSlotInt() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotInt,
#if PYTHON_VERSION >= 300
        const_str_digest_1f0cdda054450e3fa5634a8722b3e7b8,
#endif
        codeobj_8a7f0f6cb1b6d1a79102c587416607e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_62_hasShapeSlotLong() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotLong,
#if PYTHON_VERSION >= 300
        const_str_digest_1ddcb2b45d6000f54afbf9eb0e90743b,
#endif
        codeobj_b41ca985d47eaf533323004d01c2f936,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_63_hasShapeSlotFloat() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotFloat,
#if PYTHON_VERSION >= 300
        const_str_digest_4283052390ee7abb237257312d760dba,
#endif
        codeobj_0e77d4d63e616eb1a3bc028bbd180e01,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter,
        const_str_plain_hasShapeSlotIter,
#if PYTHON_VERSION >= 300
        const_str_digest_53587ace7c4bf33107ed1f570aadf105,
#endif
        codeobj_954260a5d80350d35448265904c2ece9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext,
        const_str_plain_hasShapeSlotNext,
#if PYTHON_VERSION >= 300
        const_str_digest_ab35dd025889bc45db317c286206826f,
#endif
        codeobj_d162cf51f4337d7c44c85056e237dcd9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter,
        const_str_plain_getShapeIter,
#if PYTHON_VERSION >= 300
        const_str_digest_029bc98430e80320845b687048090956,
#endif
        codeobj_7ca2522bf2581894b1beb8f845b610a2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains,
        const_str_plain_hasShapeSlotContains,
#if PYTHON_VERSION >= 300
        const_str_digest_c8a3b90d77b847ed37d4a0b8bd57ab05,
#endif
        codeobj_cd783a51523183bd96d40e52e2be64d3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_68___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_68___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_7ef113462f316f87e890cdcd1d4b107c,
#endif
        codeobj_a28c20139dda310267de405e90aedb3b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives,
        const_str_plain_emitAlternatives,
#if PYTHON_VERSION >= 300
        const_str_digest_1d7b5f7dfcc811f8fc7513c38a2587d8,
#endif
        codeobj_2569be5f046998681575c4cffffe0229,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_6_hasShapeSlotComplex() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotComplex,
#if PYTHON_VERSION >= 300
        const_str_digest_92fc3e2a785ed05a6acf59211c03e00b,
#endif
        codeobj_b8b3c14b8b2545d9f3a0de139c5cd3f4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape,
        const_str_plain__collectInitialShape,
#if PYTHON_VERSION >= 300
        const_str_digest_96b820c249396a1aca0592af708777cf,
#endif
        codeobj_aadd76d1ac15293cca02cc13b85b7e65,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape,
        const_str_plain_getOperationBinaryAddShape,
#if PYTHON_VERSION >= 300
        const_str_digest_87d515201677c9301fd970b13f35344c,
#endif
        codeobj_e1948cbedd102577e7c86b2494befd90,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_9599c172028796027d409abf82468412,
#endif
        codeobj_6302733a60eca15cfc35740f6b43693f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape,
        const_str_plain_getOperationBinarySubShape,
#if PYTHON_VERSION >= 300
        const_str_digest_aaa846ca7fe03417eeca473ef7d50543,
#endif
        codeobj_04bb67784ec2ae1c58a2b767c0192b14,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_a5d1c8577236b0122906b5451836ac13,
#endif
        codeobj_7c85d5316288c6cbdec21410c52b261d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape,
        const_str_plain_getOperationBinaryMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_7e7788ccf7097b006f15d4ab18035078,
#endif
        codeobj_876a1e5fe9d10bccf76f38ef397f6295,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_4f357c02d4f02597489b79e57bf68d5e,
#endif
        codeobj_b2a1bf0e8cf458d869fb18b9aca64a04,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape,
        const_str_plain_getOperationBinaryFloorDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b527f90acd21e596976714914f889237,
#endif
        codeobj_1bd7d763ce82777b8bc18c38ea0167ca,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_45e740ebd0e72590beff0fbc1084a81e,
#endif
        codeobj_8cdd1cf02b6e91978eb12c28eb60bd5b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape,
        const_str_plain_getOperationBinaryOldDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_33f8b5b02c5515b662664b0259421a7e,
#endif
        codeobj_16f3995a02c0e9c79caad0e3968c3371,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_8e711790dd74232149aab0a58c8a3a7f,
#endif
        codeobj_b8bb20277bc146b9f2d9eb297a44862e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape,
        const_str_plain_getOperationBinaryTrueDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_7a4c138f498be59b81e44a071ffe23e3,
#endif
        codeobj_8dd75cae359f2182c58f87b80393d24e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_f38880eba632621d930a62348aff8df0,
#endif
        codeobj_24e64e080f977ec2c688592a89cab564,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape,
        const_str_plain_getOperationBinaryModShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d53a423951b232e18d93c9f1828c1a3f,
#endif
        codeobj_a03bf40e3eb8edc8605a7e62ecdd3212,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_7a1d07fe183b0c7a628ebe63a5385a45,
#endif
        codeobj_4f7853b32d446d492871a3092798aa20,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape,
        const_str_plain_getOperationBinaryPowShape,
#if PYTHON_VERSION >= 300
        const_str_digest_63d0871f0e62133be883b984a3258a9e,
#endif
        codeobj_9a1cd419ff5f7369aad29af0cbf529dc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_8e5ece21e576f546463bfe5c2f0ba8e5,
#endif
        codeobj_cc89ba8a3dc4ca5e9a8187a8b1fe39dd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape,
        const_str_plain_getOperationBinaryLShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_c54c54e35beee66a709658cabf4884cf,
#endif
        codeobj_3dd45ca70afc01291f9356164bd33100,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_6078755004362c4ae543ea6452fd4308,
#endif
        codeobj_18bda4c64265e404b7aaf22dc15b2d12,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_7_hasShapeSlotBool() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotBool,
#if PYTHON_VERSION >= 300
        const_str_digest_00a09cfe5e24c0a47b44de43f2bc0f40,
#endif
        codeobj_ccbdbf168ce9b29845afaf138f608d62,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape,
        const_str_plain_getOperationBinaryRShiftShape,
#if PYTHON_VERSION >= 300
        const_str_digest_71ed497c2844da7c828242ad2d4aa6af,
#endif
        codeobj_3645059692b6a687f1cc693a5e2a7992,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_9294d61dfee050890f7ed89747a17073,
#endif
        codeobj_0deae47aea120f40c053e988347a77a8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape,
        const_str_plain_getOperationBinaryBitOrShape,
#if PYTHON_VERSION >= 300
        const_str_digest_e3e58d5b79048c12a1260373b81ee46c,
#endif
        codeobj_87f148f9ab85354cc524c43c25996583,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_60d9f6c8d66361ecc95ade1ea639f1a2,
#endif
        codeobj_f95de718f13fcea583daf1efacdefdb0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape,
        const_str_plain_getOperationBinaryBitAndShape,
#if PYTHON_VERSION >= 300
        const_str_digest_cab3b6618917c459acfca3e5ab31358f,
#endif
        codeobj_fb6c31fd0fb939d2e4c0c9e55ad06301,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_78e7f75305f7d62feb3a9dc186636f18,
#endif
        codeobj_76ee1733c9e71f1b5d4cbcef34146606,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape,
        const_str_plain_getOperationBinaryBitXorShape,
#if PYTHON_VERSION >= 300
        const_str_digest_d6bf92263192a5627e57fff8feddd8f5,
#endif
        codeobj_2ff7ba750e4d1ecf070df3a4a0896ed0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_f8b45238e2c8bc14c71e96c1b7a374de,
#endif
        codeobj_d26a4ad1ef1a2f2b0ab74283bf91d39c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape,
        const_str_plain_getOperationBinaryMatMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_9ac60839a4ad81e96900228ba26d8a4b,
#endif
        codeobj_80ca9f6e6aceaa2ee897274b7bf46769,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_5fe1a7c4046b9f2044748f911c36403f,
#endif
        codeobj_26bc50f31cbb49207bb35be4ca0587b0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape,
        const_str_plain_getComparisonLtShape,
#if PYTHON_VERSION >= 300
        const_str_digest_c39bde8b6b341623969694b505be7a70,
#endif
        codeobj_5cf72a68714c34d1eca72117e53cd4c7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_c15c72a7e37e89f81802924290efa8b4,
#endif
        codeobj_0333d7f7a3f0e07402c652ec964b3d26,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_86_getComparisonLteShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_86_getComparisonLteShape,
        const_str_plain_getComparisonLteShape,
#if PYTHON_VERSION >= 300
        const_str_digest_b02c75ea17c35630c1c53481a1915463,
#endif
        codeobj_aab3111a94fa8100bd8f5d5fb097a9d7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_87_getComparisonGtShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_87_getComparisonGtShape,
        const_str_plain_getComparisonGtShape,
#if PYTHON_VERSION >= 300
        const_str_digest_acb5c981f9ec880bb67e20323a9b090c,
#endif
        codeobj_03b6369ad1eae0faab06dedb33f72ed3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_88_getComparisonGteShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_88_getComparisonGteShape,
        const_str_plain_getComparisonGteShape,
#if PYTHON_VERSION >= 300
        const_str_digest_847fbb2c38b79bc7df8d53d0d76e35fe,
#endif
        codeobj_daf8c11419498c5f135c12cffe0042c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_89_getComparisonEqShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_89_getComparisonEqShape,
        const_str_plain_getComparisonEqShape,
#if PYTHON_VERSION >= 300
        const_str_digest_91cd369ed1b9a8fd6ffd7715f35cc157,
#endif
        codeobj_d267c448b6251b74e5be0a1f61bbb709,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_8_hasShapeSlotAbs() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotAbs,
#if PYTHON_VERSION >= 300
        const_str_digest_90f0220328a09edaf62c4482306ba916,
#endif
        codeobj_8925401d2d7666c1c1f7ff4e170d4927,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_90_getComparisonNeqShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_90_getComparisonNeqShape,
        const_str_plain_getComparisonNeqShape,
#if PYTHON_VERSION >= 300
        const_str_digest_c7e895ad3a752f5af11608a55fc3e719,
#endif
        codeobj_875572138db468037ef97f678b91cfcd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_91___init__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_91___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_dcc6e2d69aa8d5793f2331176634f4e0,
#endif
        codeobj_825ccb8ddbea6048defc2fcd9766b195,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives,
        const_str_plain_emitAlternatives,
#if PYTHON_VERSION >= 300
        const_str_digest_6ab4c8ed7aba351c9a8e1e4e1a56ce1a,
#endif
        codeobj_37abb6baa47331d3a21966c1a9dcd9a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation,
        const_str_plain__collectShapeOperation,
#if PYTHON_VERSION >= 300
        const_str_digest_d5cbbc53e11173a4dca6aeb4d5ec4db4,
#endif
        codeobj_4f95aee009bf65dad8462a36a27ef7b2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape,
        const_str_plain_getOperationBinaryAddShape,
#if PYTHON_VERSION >= 300
        const_str_digest_dc11cc451e3f25cc39ee212d19c2267b,
#endif
        codeobj_3aea18dc8eb5b018ebd7f4ecac8bb769,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_365da10cd9378856c420835e2cc7f545,
#endif
        codeobj_298fce9d2aa2b6ff2b7027183ccc4ed1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape,
        const_str_plain_getOperationBinarySubShape,
#if PYTHON_VERSION >= 300
        const_str_digest_6be52d31f524db4ba645af96905d73e9,
#endif
        codeobj_89c2e72108c717d051bc2f3380028c01,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_6f65270eb24f34e894a86c108883d024,
#endif
        codeobj_c28932552839632b2b12c0c3408e4ea3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape,
        const_str_plain_getOperationBinaryMultShape,
#if PYTHON_VERSION >= 300
        const_str_digest_0b24bf1a87dc3a7f1bf92158dade790a,
#endif
        codeobj_cf4ec8f3fd82f729a4fed2653f5c444f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_8f14b440fd6ca8bff343a227d301809d,
#endif
        codeobj_8c07135053c1f08248f8e07045be6e55,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape,
        const_str_plain_getOperationBinaryFloorDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_0008cb4c56ad268bf83a0c41c2a4f36b,
#endif
        codeobj_b22d37a6a511a522a7e064ecabab8350,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_627c1a9a275d106b97f1899bf1ed6756,
#endif
        codeobj_3f41991df1be5fc8332b7034fc522534,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape,
        const_str_plain_getOperationBinaryOldDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_aa65ab12dd477f85bad48af2f0edbfe9,
#endif
        codeobj_99127d41fd2b0d07a06cc6547a8fe896,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_5d4052745f0da93e79fd9db1fa2358ae,
#endif
        codeobj_3aa00639304e27a92d16236ecf68307c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape,
        const_str_plain_getOperationBinaryTrueDivShape,
#if PYTHON_VERSION >= 300
        const_str_digest_380789f8960e6daa2e93c66890a30dca,
#endif
        codeobj_b7c9f7c3ee3a065c315692d6d6b121d6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape$$$function_1_lambda() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape$$$function_1_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 300
        const_str_digest_8c5302682484c126170068b2bd2d33ce,
#endif
        codeobj_16d5e8aa45f52a0ffbe0ad9ded831f67,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        1
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_9_hasShapeSlotLen() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        NULL,
        const_str_plain_hasShapeSlotLen,
#if PYTHON_VERSION >= 300
        const_str_digest_210cf36a20d8be933983da1bd9dc5f0f,
#endif
        codeobj_f7a94311b4b68316590dc83f56d0fdfa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        NULL,
        0
    );

    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_site$$45$packages$nuitka$nodes$shapes$StandardShapes =
{
    PyModuleDef_HEAD_INIT,
    NULL,                /* m_name, filled later */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;
extern PyObject *const_str_empty;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

extern PyTypeObject Nuitka_Loader_Type;

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
// Provide a way to create find a function via its C code and create it back
// in another process, useful for multiprocessing extensions like dill

function_impl_code functable_site$$45$packages$nuitka$nodes$shapes$StandardShapes[] = {
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes$$$function_1_lambda,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule$$$function_1_lambda,
    NULL,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_52_hasShapeSlotLen,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_54___init__,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_55_getTypeShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_57_hasShapeSlotLen,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_58___init__,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_68___init__,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_86_getComparisonLteShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_87_getComparisonGtShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_88_getComparisonGteShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_89_getComparisonEqShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_90_getComparisonNeqShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_91___init__,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_108_getOperationBinaryAddLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_109_getOperationBinarySubLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_110_getOperationBinaryMultLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_111_getOperationBinaryFloorDivLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_112_getOperationBinaryOldDivLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_113_getOperationBinaryTrueDivLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_114_getOperationBinaryModLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_115_getOperationBinaryPowLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_116_getOperationBinaryLShiftLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_117_getOperationBinaryRShiftLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_118_getOperationBinaryBitOrLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_119_getOperationBinaryBitAndLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_120_getOperationBinaryBitXorLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_121_getOperationBinaryMatMultLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_123_getComparisonLtLShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_124_getComparisonLteShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_125_getComparisonGtShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_126_getComparisonGteShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_127_getComparisonEqShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_128_getComparisonNeqShape,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes,
    impl_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule,
    NULL
};

static char const *_reduce_compiled_function_argnames[] = {
    "func",
    NULL
};

static PyObject *_reduce_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject *func;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:reduce_compiled_function", (char **)_reduce_compiled_function_argnames, &func, NULL)) {
        return NULL;
    }

    if (Nuitka_Function_Check(func) == false) {
        PyErr_Format(PyExc_TypeError, "not a compiled function");
        return NULL;
    }

    struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;

    function_impl_code *current = functable_site$$45$packages$nuitka$nodes$shapes$StandardShapes;
    int offset = 0;

    while (*current != NULL) {
        if (*current == function->m_c_code) {
            break;
        }

        current += 1;
        offset += 1;
    }

    if (*current == NULL) {
        PyErr_Format(PyExc_TypeError, "Cannot find compiled function in module.");
        return NULL;
    }

    PyObject *code_object_desc = PyTuple_New(6);
    PyTuple_SET_ITEM0(code_object_desc, 0, function->m_code_object->co_filename);
    PyTuple_SET_ITEM0(code_object_desc, 1, function->m_code_object->co_name);
    PyTuple_SET_ITEM(code_object_desc, 2, PyLong_FromLong(function->m_code_object->co_firstlineno));
    PyTuple_SET_ITEM0(code_object_desc, 3, function->m_code_object->co_varnames);
    PyTuple_SET_ITEM(code_object_desc, 4, PyLong_FromLong(function->m_code_object->co_argcount));
    PyTuple_SET_ITEM(code_object_desc, 5, PyLong_FromLong(function->m_code_object->co_flags));

    CHECK_OBJECT_DEEP(code_object_desc);

    PyObject *result = PyTuple_New(4);
    PyTuple_SET_ITEM(result, 0, PyLong_FromLong(offset));
    PyTuple_SET_ITEM(result, 1, code_object_desc);
    PyTuple_SET_ITEM0(result, 2, function->m_defaults);
    PyTuple_SET_ITEM0(result, 3, function->m_doc != NULL ? function->m_doc : Py_None);

    CHECK_OBJECT_DEEP(result);

    return result;
}

static PyMethodDef _method_def_reduce_compiled_function = {"reduce_compiled_function", (PyCFunction)_reduce_compiled_function,
                                                           METH_VARARGS | METH_KEYWORDS, NULL};

static char const *_create_compiled_function_argnames[] = {
    "func",
    "code_object_desc",
    "defaults",
    "doc",
    NULL
};


static PyObject *_create_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    CHECK_OBJECT_DEEP(args);

    PyObject *func;
    PyObject *code_object_desc;
    PyObject *defaults;
    PyObject *doc;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:create_compiled_function", (char **)_create_compiled_function_argnames, &func, &code_object_desc, &defaults, &doc, NULL)) {
        return NULL;
    }

    int offset = PyLong_AsLong(func);

    if (offset == -1 && ERROR_OCCURRED()) {
        return NULL;
    }

    if (offset > sizeof(functable_site$$45$packages$nuitka$nodes$shapes$StandardShapes) || offset < 0) {
        PyErr_Format(PyExc_TypeError, "Wrong offset for compiled function.");
        return NULL;
    }

    PyObject *filename = PyTuple_GET_ITEM(code_object_desc, 0);
    PyObject *function_name = PyTuple_GET_ITEM(code_object_desc, 1);
    PyObject *line = PyTuple_GET_ITEM(code_object_desc, 2);
    int line_int = PyLong_AsLong(line);
    assert(!ERROR_OCCURRED());

    PyObject *argnames = PyTuple_GET_ITEM(code_object_desc, 3);
    PyObject *arg_count = PyTuple_GET_ITEM(code_object_desc, 4);
    int arg_count_int = PyLong_AsLong(arg_count);
    assert(!ERROR_OCCURRED());
    PyObject *flags = PyTuple_GET_ITEM(code_object_desc, 5);
    int flags_int = PyLong_AsLong(flags);
    assert(!ERROR_OCCURRED());

    PyCodeObject *code_object = MAKE_CODEOBJECT(
        filename,
        line_int,
        flags_int,
        function_name,
        argnames,
        arg_count_int,
        0, // TODO: Missing kw_only_count
        0 // TODO: Missing pos_only_count
    );

    // TODO: More stuff needed for Python3, best to re-order arguments of MAKE_CODEOBJECT.
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        functable_site$$45$packages$nuitka$nodes$shapes$StandardShapes[offset],
        code_object->co_name,
#if PYTHON_VERSION >= 300
        NULL, // TODO: Not transferring qualname yet
#endif
        code_object,
        defaults,
#if PYTHON_VERSION >= 300
        NULL, // kwdefaults are done on the outside currently
        NULL, // TODO: Not transferring annotations
#endif
        module_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        doc,
        0
    );

    return (PyObject *)result;
}

static PyMethodDef _method_def_create_compiled_function = {
    "create_compiled_function",
    (PyCFunction)_create_compiled_function,
    METH_VARARGS | METH_KEYWORDS, NULL
};


#endif

// Internal entry point for module code.
PyObject *modulecode_site$$45$packages$nuitka$nodes$shapes$StandardShapes(char const *module_full_name) {
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if (_init_done) {
        return module_site$$45$packages$nuitka$nodes$shapes$StandardShapes;
    } else {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // May have to activate constants blob.
#if defined(_NUITKA_CONSTANTS_FROM_RESOURCE)
    loadConstantsResource();
#endif

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    PRINT_STRING("site-packages.nuitka.nodes.shapes.StandardShapes: Calling setupMetaPathBasedLoader().\n");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("site-packages.nuitka.nodes.shapes.StandardShapes: Calling createModuleConstants().\n");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("site-packages.nuitka.nodes.shapes.StandardShapes: Calling createModuleCodeObjects().\n");
#endif
    createModuleCodeObjects();

    // PRINT_STRING("in initsite$$45$packages$nuitka$nodes$shapes$StandardShapes\n");

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_site$$45$packages$nuitka$nodes$shapes$StandardShapes = Py_InitModule4(
        module_full_name,        // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No "__doc__" is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    mdef_site$$45$packages$nuitka$nodes$shapes$StandardShapes.m_name = module_full_name;
    module_site$$45$packages$nuitka$nodes$shapes$StandardShapes = PyModule_Create(&mdef_site$$45$packages$nuitka$nodes$shapes$StandardShapes);
#endif

    moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes = MODULE_DICT(module_site$$45$packages$nuitka$nodes$shapes$StandardShapes);

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
    {
        PyObject *function_tables = PyObject_GetAttrString((PyObject *)builtin_module, "compiled_function_tables");
        if (function_tables == NULL)
        {
            DROP_ERROR_OCCURRED();
            function_tables = PyDict_New();
        }
        PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function_tables", function_tables);
        PyObject *funcs = PyTuple_New(2);
        PyTuple_SetItem(funcs, 0, PyCFunction_New(&_method_def_reduce_compiled_function, NULL));
        PyTuple_SetItem(funcs, 1, PyCFunction_New(&_method_def_create_compiled_function, NULL));
        PyDict_SetItemString(function_tables, module_full_name, funcs);
    }
#endif

    // Set "__compiled__" to what version information we have.
    UPDATE_STRING_DICT0(
        moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        UPDATE_STRING_DICT0(
            moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
            (Nuitka_StringObject *)const_str_plain___package__,
            const_str_empty
        );
#elif 0
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___name__);

        UPDATE_STRING_DICT0(
            moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___name__);
        char const *module_name_cstr = PyString_AS_STRING(module_name);

        char const *last_dot = strrchr(module_name_cstr, '.');

        if (last_dot != NULL)
        {
            UPDATE_STRING_DICT1(
                moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize(module_name_cstr, last_dot - module_name_cstr)
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___name__);
        Py_ssize_t dot_index = PyUnicode_Find(module_name, const_str_dot, 0, PyUnicode_GetLength(module_name), -1);

        if (dot_index != -1)
        {
            UPDATE_STRING_DICT1(
                moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring(module_name, 0, dot_index)
            );
        }
#endif
#endif
    }

    CHECK_OBJECT(module_site$$45$packages$nuitka$nodes$shapes$StandardShapes);

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyDict_SetItemString(PyImport_GetModuleDict(), module_full_name, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        assert(r != -1);
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if (GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___builtins__) == NULL)
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict(value);
#endif

        UPDATE_STRING_DICT0(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___builtins__, value);
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type);
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___spec__, Py_None);
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT(bootstrap_module);
        PyObject *module_spec_class = PyObject_GetAttrString(bootstrap_module, "ModuleSpec");
        Py_DECREF(bootstrap_module);

        PyObject *args[] = {
            GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___name__),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF(module_spec_class);

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT(spec_value);

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE(spec_value, const_str_plain_submodule_search_locations, PyList_New(0));
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE(spec_value, const_str_plain__initializing, Py_True);

        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___spec__, spec_value);
    }
#endif
#endif

    // Temp variables if any
    PyObject *outline_0_var___class__ = NULL;
    PyObject *outline_1_var___class__ = NULL;
    PyObject *outline_2_var___class__ = NULL;
    PyObject *outline_3_var___class__ = NULL;
    PyObject *outline_4_var___class__ = NULL;
    PyObject *outline_5_var___class__ = NULL;
    PyObject *outline_6_var___class__ = NULL;
    PyObject *outline_7_var___class__ = NULL;
    PyObject *outline_8_var___class__ = NULL;
    PyObject *tmp_class_creation_1__class_decl_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__prepared = NULL;
    PyObject *tmp_class_creation_2__bases = NULL;
    PyObject *tmp_class_creation_2__class_decl_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_2__prepared = NULL;
    PyObject *tmp_class_creation_3__class_decl_dict = NULL;
    PyObject *tmp_class_creation_3__metaclass = NULL;
    PyObject *tmp_class_creation_3__prepared = NULL;
    PyObject *tmp_class_creation_4__bases = NULL;
    PyObject *tmp_class_creation_4__class_decl_dict = NULL;
    PyObject *tmp_class_creation_4__metaclass = NULL;
    PyObject *tmp_class_creation_4__prepared = NULL;
    PyObject *tmp_class_creation_5__class_decl_dict = NULL;
    PyObject *tmp_class_creation_5__metaclass = NULL;
    PyObject *tmp_class_creation_5__prepared = NULL;
    PyObject *tmp_class_creation_6__bases = NULL;
    PyObject *tmp_class_creation_6__class_decl_dict = NULL;
    PyObject *tmp_class_creation_6__metaclass = NULL;
    PyObject *tmp_class_creation_6__prepared = NULL;
    PyObject *tmp_class_creation_7__bases = NULL;
    PyObject *tmp_class_creation_7__class_decl_dict = NULL;
    PyObject *tmp_class_creation_7__metaclass = NULL;
    PyObject *tmp_class_creation_7__prepared = NULL;
    PyObject *tmp_class_creation_8__bases = NULL;
    PyObject *tmp_class_creation_8__class_decl_dict = NULL;
    PyObject *tmp_class_creation_8__metaclass = NULL;
    PyObject *tmp_class_creation_8__prepared = NULL;
    PyObject *tmp_class_creation_9__bases = NULL;
    PyObject *tmp_class_creation_9__class_decl_dict = NULL;
    PyObject *tmp_class_creation_9__metaclass = NULL;
    PyObject *tmp_class_creation_9__prepared = NULL;
    struct Nuitka_FrameObject *frame_fbcacf0dd7105f7e77a454cdc3975a6d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_dictdel_dict;
    PyObject *tmp_dictdel_key;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_2a661cbeaf4f4cdde5f67a06430e33d1_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_2a661cbeaf4f4cdde5f67a06430e33d1_2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411 = NULL;
    struct Nuitka_FrameObject *frame_443e077e6134ea2158171ecac004feeb_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    static struct Nuitka_FrameObject *cache_frame_443e077e6134ea2158171ecac004feeb_3 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473 = NULL;
    struct Nuitka_FrameObject *frame_a09999ee0b961cf0bc904e3250f3dd24_4;
    NUITKA_MAY_BE_UNUSED char const *type_description_4 = NULL;
    static struct Nuitka_FrameObject *cache_frame_a09999ee0b961cf0bc904e3250f3dd24_4 = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480 = NULL;
    struct Nuitka_FrameObject *frame_5310b13332f11e9c5a2f13a4f54ec265_5;
    NUITKA_MAY_BE_UNUSED char const *type_description_5 = NULL;
    static struct Nuitka_FrameObject *cache_frame_5310b13332f11e9c5a2f13a4f54ec265_5 = NULL;
    PyObject *exception_keeper_type_10;
    PyObject *exception_keeper_value_10;
    PyTracebackObject *exception_keeper_tb_10;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_10;
    PyObject *exception_keeper_type_11;
    PyObject *exception_keeper_value_11;
    PyTracebackObject *exception_keeper_tb_11;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_11;
    PyObject *exception_keeper_type_12;
    PyObject *exception_keeper_value_12;
    PyTracebackObject *exception_keeper_tb_12;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_12;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492 = NULL;
    struct Nuitka_FrameObject *frame_314cddf2026135a2b36d24db96264100_6;
    NUITKA_MAY_BE_UNUSED char const *type_description_6 = NULL;
    static struct Nuitka_FrameObject *cache_frame_314cddf2026135a2b36d24db96264100_6 = NULL;
    PyObject *exception_keeper_type_13;
    PyObject *exception_keeper_value_13;
    PyTracebackObject *exception_keeper_tb_13;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_13;
    PyObject *exception_keeper_type_14;
    PyObject *exception_keeper_value_14;
    PyTracebackObject *exception_keeper_tb_14;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_14;
    PyObject *exception_keeper_type_15;
    PyObject *exception_keeper_value_15;
    PyTracebackObject *exception_keeper_tb_15;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_15;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510 = NULL;
    struct Nuitka_FrameObject *frame_b49158edaeabda446bf086b2eb083353_7;
    NUITKA_MAY_BE_UNUSED char const *type_description_7 = NULL;
    static struct Nuitka_FrameObject *cache_frame_b49158edaeabda446bf086b2eb083353_7 = NULL;
    PyObject *exception_keeper_type_16;
    PyObject *exception_keeper_value_16;
    PyTracebackObject *exception_keeper_tb_16;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_16;
    PyObject *exception_keeper_type_17;
    PyObject *exception_keeper_value_17;
    PyTracebackObject *exception_keeper_tb_17;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_17;
    PyObject *exception_keeper_type_18;
    PyObject *exception_keeper_value_18;
    PyTracebackObject *exception_keeper_tb_18;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_18;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519 = NULL;
    struct Nuitka_FrameObject *frame_30d744ac1c2b5a81f536d4ad013b3e3a_8;
    NUITKA_MAY_BE_UNUSED char const *type_description_8 = NULL;
    static struct Nuitka_FrameObject *cache_frame_30d744ac1c2b5a81f536d4ad013b3e3a_8 = NULL;
    PyObject *exception_keeper_type_19;
    PyObject *exception_keeper_value_19;
    PyTracebackObject *exception_keeper_tb_19;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_19;
    PyObject *exception_keeper_type_20;
    PyObject *exception_keeper_value_20;
    PyTracebackObject *exception_keeper_tb_20;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_20;
    PyObject *exception_keeper_type_21;
    PyObject *exception_keeper_value_21;
    PyTracebackObject *exception_keeper_tb_21;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_21;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557 = NULL;
    struct Nuitka_FrameObject *frame_2562b0e500dd6b012dd5989b37851978_9;
    NUITKA_MAY_BE_UNUSED char const *type_description_9 = NULL;
    static struct Nuitka_FrameObject *cache_frame_2562b0e500dd6b012dd5989b37851978_9 = NULL;
    PyObject *exception_keeper_type_22;
    PyObject *exception_keeper_value_22;
    PyTracebackObject *exception_keeper_tb_22;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_22;
    PyObject *exception_keeper_type_23;
    PyObject *exception_keeper_value_23;
    PyTracebackObject *exception_keeper_tb_23;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_23;
    PyObject *exception_keeper_type_24;
    PyObject *exception_keeper_value_24;
    PyTracebackObject *exception_keeper_tb_24;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_24;
    PyObject *locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806 = NULL;
    struct Nuitka_FrameObject *frame_c1a664c66de179cd92cb9a38d83e5344_10;
    NUITKA_MAY_BE_UNUSED char const *type_description_10 = NULL;
    static struct Nuitka_FrameObject *cache_frame_c1a664c66de179cd92cb9a38d83e5344_10 = NULL;
    PyObject *exception_keeper_type_25;
    PyObject *exception_keeper_value_25;
    PyTracebackObject *exception_keeper_tb_25;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_25;
    PyObject *exception_keeper_type_26;
    PyObject *exception_keeper_value_26;
    PyTracebackObject *exception_keeper_tb_26;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_26;
    PyObject *exception_keeper_type_27;
    PyObject *exception_keeper_value_27;
    PyTracebackObject *exception_keeper_tb_27;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_27;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_str_digest_9bece148b4f208983edca24b57ffdcae;
        UPDATE_STRING_DICT0(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1);
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_str_digest_d454e1ca882012a2883b67d83d0c86c5;
        UPDATE_STRING_DICT0(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2);
    }
    // Frame without reuse.
    frame_fbcacf0dd7105f7e77a454cdc3975a6d = MAKE_MODULE_FRAME(codeobj_fbcacf0dd7105f7e77a454cdc3975a6d, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes);

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack(frame_fbcacf0dd7105f7e77a454cdc3975a6d);
    assert(Py_REFCNT(frame_fbcacf0dd7105f7e77a454cdc3975a6d) == 2);

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_mvar_value_1;
        tmp_assattr_name_1 = const_str_digest_d454e1ca882012a2883b67d83d0c86c5;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___spec__);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__);
        }

        CHECK_OBJECT(tmp_mvar_value_1);
        tmp_assattr_target_1 = tmp_mvar_value_1;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_origin, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        PyObject *tmp_mvar_value_2;
        tmp_assattr_name_2 = Py_True;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___spec__);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__);
        }

        CHECK_OBJECT(tmp_mvar_value_2);
        tmp_assattr_target_2 = tmp_mvar_value_2;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain_has_location, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = Py_None;
        UPDATE_STRING_DICT0(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3);
    }
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        PyObject *tmp_level_name_1;
        tmp_name_name_1 = const_str_digest_c9c35ef4cfa2cd9b28f23fe80d1b5aa7;
        tmp_globals_name_1 = (PyObject *)moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = const_tuple_str_plain_CTypePyObjectPtr_tuple;
        tmp_level_name_1 = const_int_0;
        frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 20;
        tmp_import_name_from_1 = IMPORT_MODULE5(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1);
        if (tmp_import_name_from_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_4 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain_CTypePyObjectPtr);
        Py_DECREF(tmp_import_name_from_1);
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_CTypePyObjectPtr, tmp_assign_source_4);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_import_name_from_2;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        PyObject *tmp_level_name_2;
        tmp_name_name_2 = const_str_digest_6e7dbe51ff007289b31e0fc6eaf5e18e;
        tmp_globals_name_2 = (PyObject *)moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = const_tuple_str_plain_onMissingOperation_tuple;
        tmp_level_name_2 = const_int_0;
        frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 21;
        tmp_import_name_from_2 = IMPORT_MODULE5(tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2);
        if (tmp_import_name_from_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 21;

            goto frame_exception_exit_1;
        }
        tmp_assign_source_5 = IMPORT_NAME(tmp_import_name_from_2, const_str_plain_onMissingOperation);
        Py_DECREF(tmp_import_name_from_2);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 21;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_onMissingOperation, tmp_assign_source_5);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_import_name_from_3;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        PyObject *tmp_level_name_3;
        tmp_name_name_3 = const_str_plain_ControlFlowDescriptions;
        tmp_globals_name_3 = (PyObject *)moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = const_tuple_str_plain_ControlFlowDescriptionFullEscape_tuple;
        tmp_level_name_3 = const_int_pos_1;
        frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 23;
        tmp_import_name_from_3 = IMPORT_MODULE5(tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3);
        if (tmp_import_name_from_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 23;

            goto frame_exception_exit_1;
        }
        if (PyModule_Check(tmp_import_name_from_3)) {
           tmp_assign_source_6 = IMPORT_NAME_OR_MODULE(
                tmp_import_name_from_3,
                (PyObject *)moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes,
                const_str_plain_ControlFlowDescriptionFullEscape,
                const_int_pos_1
            );
        } else {
           tmp_assign_source_6 = IMPORT_NAME(tmp_import_name_from_3, const_str_plain_ControlFlowDescriptionFullEscape);
        }

        Py_DECREF(tmp_import_name_from_3);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 23;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape, tmp_assign_source_6);
    }
    {
        PyObject *tmp_assign_source_7;
        tmp_assign_source_7 = PyDict_New();
        assert(tmp_class_creation_1__class_decl_dict == NULL);
        tmp_class_creation_1__class_decl_dict = tmp_assign_source_7;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_metaclass_name_1;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        PyObject *tmp_bases_name_1;
        tmp_key_name_1 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_dict_name_1 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_1, tmp_key_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_1;
        } else {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_dict_name_2 = tmp_class_creation_1__class_decl_dict;
        tmp_key_name_2 = const_str_plain_metaclass;
        tmp_metaclass_name_1 = DICT_GET_ITEM(tmp_dict_name_2, tmp_key_name_2);
        if (tmp_metaclass_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_1;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        tmp_metaclass_name_1 = LOOKUP_BUILTIN(const_str_plain_type);
        assert(tmp_metaclass_name_1 != NULL);
        Py_INCREF(tmp_metaclass_name_1);
        condexpr_end_1:;
        tmp_bases_name_1 = const_tuple_type_object_tuple;
        tmp_assign_source_8 = SELECT_METACLASS(tmp_metaclass_name_1, tmp_bases_name_1);
        Py_DECREF(tmp_metaclass_name_1);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_1;
        }
        assert(tmp_class_creation_1__metaclass == NULL);
        tmp_class_creation_1__metaclass = tmp_assign_source_8;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        tmp_key_name_3 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_dict_name_3 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_3, tmp_key_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
        branch_yes_1:;
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_1__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_1;
        }
        branch_no_1:;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_source_name_1;
        CHECK_OBJECT(tmp_class_creation_1__metaclass);
        tmp_source_name_1 = tmp_class_creation_1__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_1, const_str_plain___prepare__);
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
        branch_yes_2:;
        {
            PyObject *tmp_assign_source_9;
            PyObject *tmp_called_name_1;
            PyObject *tmp_source_name_2;
            PyObject *tmp_args_name_1;
            PyObject *tmp_kw_name_1;
            CHECK_OBJECT(tmp_class_creation_1__metaclass);
            tmp_source_name_2 = tmp_class_creation_1__metaclass;
            tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_source_name_2, const_str_plain___prepare__);
            if (tmp_called_name_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 26;

                goto try_except_handler_1;
            }
            tmp_args_name_1 = const_tuple_str_plain_ShapeBase_tuple_type_object_tuple_tuple;
            CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
            tmp_kw_name_1 = tmp_class_creation_1__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 26;
            tmp_assign_source_9 = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
            Py_DECREF(tmp_called_name_1);
            if (tmp_assign_source_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 26;

                goto try_except_handler_1;
            }
            assert(tmp_class_creation_1__prepared == NULL);
            tmp_class_creation_1__prepared = tmp_assign_source_9;
        }
        {
            nuitka_bool tmp_condition_result_4;
            PyObject *tmp_operand_name_1;
            PyObject *tmp_source_name_3;
            CHECK_OBJECT(tmp_class_creation_1__prepared);
            tmp_source_name_3 = tmp_class_creation_1__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_3, const_str_plain___getitem__);
            tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 26;

                goto try_except_handler_1;
            }
            tmp_condition_result_4 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
                goto branch_yes_3;
            } else {
                goto branch_no_3;
            }
            branch_yes_3:;
            {
                PyObject *tmp_raise_type_1;
                PyObject *tmp_raise_value_1;
                PyObject *tmp_left_name_1;
                PyObject *tmp_right_name_1;
                PyObject *tmp_tuple_element_1;
                PyObject *tmp_getattr_target_1;
                PyObject *tmp_getattr_attr_1;
                PyObject *tmp_getattr_default_1;
                PyObject *tmp_source_name_4;
                PyObject *tmp_type_arg_1;
                tmp_raise_type_1 = PyExc_TypeError;
                tmp_left_name_1 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_1__metaclass);
                tmp_getattr_target_1 = tmp_class_creation_1__metaclass;
                tmp_getattr_attr_1 = const_str_plain___name__;
                tmp_getattr_default_1 = const_str_angle_metaclass;
                tmp_tuple_element_1 = BUILTIN_GETATTR(tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1);
                if (tmp_tuple_element_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 26;

                    goto try_except_handler_1;
                }
                tmp_right_name_1 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
                CHECK_OBJECT(tmp_class_creation_1__prepared);
                tmp_type_arg_1 = tmp_class_creation_1__prepared;
                tmp_source_name_4 = BUILTIN_TYPE1(tmp_type_arg_1);
                assert(!(tmp_source_name_4 == NULL));
                tmp_tuple_element_1 = LOOKUP_ATTRIBUTE(tmp_source_name_4, const_str_plain___name__);
                Py_DECREF(tmp_source_name_4);
                if (tmp_tuple_element_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_1);

                    exception_lineno = 26;

                    goto try_except_handler_1;
                }
                PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_1);
                tmp_raise_value_1 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
                Py_DECREF(tmp_right_name_1);
                if (tmp_raise_value_1 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 26;

                    goto try_except_handler_1;
                }
                exception_type = tmp_raise_type_1;
                Py_INCREF(tmp_raise_type_1);
                exception_value = tmp_raise_value_1;
                exception_lineno = 26;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_1;
            }
            branch_no_3:;
        }
        goto branch_end_2;
        branch_no_2:;
        {
            PyObject *tmp_assign_source_10;
            tmp_assign_source_10 = PyDict_New();
            assert(tmp_class_creation_1__prepared == NULL);
            tmp_class_creation_1__prepared = tmp_assign_source_10;
        }
        branch_end_2:;
    }
    {
        PyObject *tmp_assign_source_11;
        {
            PyObject *tmp_set_locals_1;
            CHECK_OBJECT(tmp_class_creation_1__prepared);
            tmp_set_locals_1 = tmp_class_creation_1__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26 = tmp_set_locals_1;
            Py_INCREF(tmp_set_locals_1);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_3;
        }
        tmp_dictset_value = const_str_plain_ShapeBase;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 26;

            goto try_except_handler_3;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_2a661cbeaf4f4cdde5f67a06430e33d1_2, codeobj_2a661cbeaf4f4cdde5f67a06430e33d1, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_2a661cbeaf4f4cdde5f67a06430e33d1_2 = cache_frame_2a661cbeaf4f4cdde5f67a06430e33d1_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_2a661cbeaf4f4cdde5f67a06430e33d1_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_2a661cbeaf4f4cdde5f67a06430e33d1_2) == 2); // Frame stack

        // Framed code:
        {
            nuitka_bool tmp_condition_result_5;
            PyObject *tmp_called_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_staticmethod_arg_1;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_5 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_2;
            } else {
                goto condexpr_false_2;
            }
            condexpr_true_2:;
            tmp_called_name_2 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_2 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_1_getTypeName();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 27;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_1);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_2;
            condexpr_false_2:;
            tmp_staticmethod_arg_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_1_getTypeName();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_1);
            Py_DECREF(tmp_staticmethod_arg_1);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_2:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getTypeName, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 27;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = const_str_plain_OBJECT;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_helper_code, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 31;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_called_name_3;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_staticmethod_arg_2;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 33;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_6 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_3;
            } else {
                goto condexpr_false_3;
            }
            condexpr_true_3:;
            tmp_called_name_3 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_3 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 33;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 33;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_2 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 33;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_2);
            Py_DECREF(tmp_called_name_3);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 33;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_3;
            condexpr_false_3:;
            tmp_staticmethod_arg_2 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_2_getCType();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_2);
            Py_DECREF(tmp_staticmethod_arg_2);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 33;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_3:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getCType, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 33;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_called_name_4;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_staticmethod_arg_3;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 37;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_7 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_4;
            } else {
                goto condexpr_false_4;
            }
            condexpr_true_4:;
            tmp_called_name_4 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_4 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 37;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 37;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_3 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 37;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_4, tmp_args_element_name_3);
            Py_DECREF(tmp_called_name_4);
            Py_DECREF(tmp_args_element_name_3);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 37;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_4;
            condexpr_false_4:;
            tmp_staticmethod_arg_3 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_3_getShapeIter();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_3);
            Py_DECREF(tmp_staticmethod_arg_3);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 37;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_4:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getShapeIter, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 37;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_8;
            PyObject *tmp_called_name_5;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_staticmethod_arg_4;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 41;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_8 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_5;
            } else {
                goto condexpr_false_5;
            }
            condexpr_true_5:;
            tmp_called_name_5 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_5 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 41;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_5 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 41;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_4 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_4_hasShapeModule();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 41;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_5, tmp_args_element_name_4);
            Py_DECREF(tmp_called_name_5);
            Py_DECREF(tmp_args_element_name_4);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 41;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_5;
            condexpr_false_5:;
            tmp_staticmethod_arg_4 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_4_hasShapeModule();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_4);
            Py_DECREF(tmp_staticmethod_arg_4);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 41;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_5:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeModule, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 41;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_9;
            PyObject *tmp_called_name_6;
            PyObject *tmp_args_element_name_5;
            PyObject *tmp_staticmethod_arg_5;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 45;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_9 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_9 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_6;
            } else {
                goto condexpr_false_6;
            }
            condexpr_true_6:;
            tmp_called_name_6 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_6 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 45;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 45;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_5 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_5_hasShapeSlotBytes();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 45;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_6, tmp_args_element_name_5);
            Py_DECREF(tmp_called_name_6);
            Py_DECREF(tmp_args_element_name_5);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 45;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_6;
            condexpr_false_6:;
            tmp_staticmethod_arg_5 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_5_hasShapeSlotBytes();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_5);
            Py_DECREF(tmp_staticmethod_arg_5);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 45;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_6:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotBytes, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 45;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_10;
            PyObject *tmp_called_name_7;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_staticmethod_arg_6;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_10 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_10 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_7;
            } else {
                goto condexpr_false_7;
            }
            condexpr_true_7:;
            tmp_called_name_7 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_7 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_7 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_6 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_6_hasShapeSlotComplex();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 49;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_7, tmp_args_element_name_6);
            Py_DECREF(tmp_called_name_7);
            Py_DECREF(tmp_args_element_name_6);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_7;
            condexpr_false_7:;
            tmp_staticmethod_arg_6 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_6_hasShapeSlotComplex();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_6);
            Py_DECREF(tmp_staticmethod_arg_6);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_7:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotComplex, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_11;
            PyObject *tmp_called_name_8;
            PyObject *tmp_args_element_name_7;
            PyObject *tmp_staticmethod_arg_7;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 53;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_11 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_11 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_8;
            } else {
                goto condexpr_false_8;
            }
            condexpr_true_8:;
            tmp_called_name_8 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_8 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 53;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 53;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_7 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_7_hasShapeSlotBool();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 53;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_8, tmp_args_element_name_7);
            Py_DECREF(tmp_called_name_8);
            Py_DECREF(tmp_args_element_name_7);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 53;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_8;
            condexpr_false_8:;
            tmp_staticmethod_arg_7 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_7_hasShapeSlotBool();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_7);
            Py_DECREF(tmp_staticmethod_arg_7);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 53;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_8:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotBool, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 53;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_12;
            PyObject *tmp_called_name_9;
            PyObject *tmp_args_element_name_8;
            PyObject *tmp_staticmethod_arg_8;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 57;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_12 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_12 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_9;
            } else {
                goto condexpr_false_9;
            }
            condexpr_true_9:;
            tmp_called_name_9 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_9 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 57;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_9 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 57;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_8 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_8_hasShapeSlotAbs();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 57;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_9, tmp_args_element_name_8);
            Py_DECREF(tmp_called_name_9);
            Py_DECREF(tmp_args_element_name_8);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 57;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_9;
            condexpr_false_9:;
            tmp_staticmethod_arg_8 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_8_hasShapeSlotAbs();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_8);
            Py_DECREF(tmp_staticmethod_arg_8);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 57;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_9:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotAbs, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 57;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_13;
            PyObject *tmp_called_name_10;
            PyObject *tmp_args_element_name_9;
            PyObject *tmp_staticmethod_arg_9;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 61;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_13 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_13 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_10;
            } else {
                goto condexpr_false_10;
            }
            condexpr_true_10:;
            tmp_called_name_10 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_10 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 61;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_10 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 61;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_9 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_9_hasShapeSlotLen();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 61;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_10, tmp_args_element_name_9);
            Py_DECREF(tmp_called_name_10);
            Py_DECREF(tmp_args_element_name_9);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 61;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_10;
            condexpr_false_10:;
            tmp_staticmethod_arg_9 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_9_hasShapeSlotLen();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_9);
            Py_DECREF(tmp_staticmethod_arg_9);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 61;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_10:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotLen, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 61;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_14;
            PyObject *tmp_called_name_11;
            PyObject *tmp_args_element_name_10;
            PyObject *tmp_staticmethod_arg_10;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 65;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_14 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_14 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_11;
            } else {
                goto condexpr_false_11;
            }
            condexpr_true_11:;
            tmp_called_name_11 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_11 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 65;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_11 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 65;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_10 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_10_hasShapeSlotInt();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 65;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_11, tmp_args_element_name_10);
            Py_DECREF(tmp_called_name_11);
            Py_DECREF(tmp_args_element_name_10);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 65;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_11;
            condexpr_false_11:;
            tmp_staticmethod_arg_10 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_10_hasShapeSlotInt();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_10);
            Py_DECREF(tmp_staticmethod_arg_10);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 65;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_11:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotInt, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 65;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_15;
            PyObject *tmp_called_name_12;
            PyObject *tmp_args_element_name_11;
            PyObject *tmp_staticmethod_arg_11;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 69;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_15 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_15 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_12;
            } else {
                goto condexpr_false_12;
            }
            condexpr_true_12:;
            tmp_called_name_12 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_12 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 69;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 69;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_11 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_11_hasShapeSlotLong();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 69;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_12, tmp_args_element_name_11);
            Py_DECREF(tmp_called_name_12);
            Py_DECREF(tmp_args_element_name_11);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 69;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_12;
            condexpr_false_12:;
            tmp_staticmethod_arg_11 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_11_hasShapeSlotLong();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_11);
            Py_DECREF(tmp_staticmethod_arg_11);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 69;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_12:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotLong, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 69;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_16;
            PyObject *tmp_called_name_13;
            PyObject *tmp_args_element_name_12;
            PyObject *tmp_staticmethod_arg_12;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 73;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_16 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_16 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_13;
            } else {
                goto condexpr_false_13;
            }
            condexpr_true_13:;
            tmp_called_name_13 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_13 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 73;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_13 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 73;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_12 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_12_hasShapeSlotFloat();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 73;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_13, tmp_args_element_name_12);
            Py_DECREF(tmp_called_name_13);
            Py_DECREF(tmp_args_element_name_12);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 73;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_13;
            condexpr_false_13:;
            tmp_staticmethod_arg_12 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_12_hasShapeSlotFloat();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_12);
            Py_DECREF(tmp_staticmethod_arg_12);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 73;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_13:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotFloat, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 73;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_17;
            PyObject *tmp_called_name_14;
            PyObject *tmp_args_element_name_13;
            PyObject *tmp_staticmethod_arg_13;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 77;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_17 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_17 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_14;
            } else {
                goto condexpr_false_14;
            }
            condexpr_true_14:;
            tmp_called_name_14 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_14 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 77;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_14 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 77;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_13 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_13_hasShapeSlotIter();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 77;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_14, tmp_args_element_name_13);
            Py_DECREF(tmp_called_name_14);
            Py_DECREF(tmp_args_element_name_13);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 77;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_14;
            condexpr_false_14:;
            tmp_staticmethod_arg_13 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_13_hasShapeSlotIter();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_13);
            Py_DECREF(tmp_staticmethod_arg_13);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 77;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_14:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotIter, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 77;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_18;
            PyObject *tmp_called_name_15;
            PyObject *tmp_args_element_name_14;
            PyObject *tmp_staticmethod_arg_14;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 81;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_18 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_18 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_15;
            } else {
                goto condexpr_false_15;
            }
            condexpr_true_15:;
            tmp_called_name_15 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_15 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 81;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_15 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 81;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_14 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_14_hasShapeSlotNext();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 81;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_15, tmp_args_element_name_14);
            Py_DECREF(tmp_called_name_15);
            Py_DECREF(tmp_args_element_name_14);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 81;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_15;
            condexpr_false_15:;
            tmp_staticmethod_arg_14 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_14_hasShapeSlotNext();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_14);
            Py_DECREF(tmp_staticmethod_arg_14);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 81;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_15:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotNext, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 81;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_19;
            PyObject *tmp_called_name_16;
            PyObject *tmp_args_element_name_15;
            PyObject *tmp_staticmethod_arg_15;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 85;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_19 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_19 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_16;
            } else {
                goto condexpr_false_16;
            }
            condexpr_true_16:;
            tmp_called_name_16 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_staticmethod);

            if (tmp_called_name_16 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 85;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_16 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 85;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_15 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_15_hasShapeSlotContains();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 85;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_16, tmp_args_element_name_15);
            Py_DECREF(tmp_called_name_16);
            Py_DECREF(tmp_args_element_name_15);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 85;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_16;
            condexpr_false_16:;
            tmp_staticmethod_arg_15 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_15_hasShapeSlotContains();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_15);
            Py_DECREF(tmp_staticmethod_arg_15);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 85;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_16:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_hasShapeSlotContains, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 85;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_add_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 89;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_20;
            PyObject *tmp_called_name_17;
            PyObject *tmp_args_element_name_16;
            PyObject *tmp_classmethod_arg_1;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 91;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_20 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_20 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_17;
            } else {
                goto condexpr_false_17;
            }
            condexpr_true_17:;
            tmp_called_name_17 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_17 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 91;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_17 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 91;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_16 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 91;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_17, tmp_args_element_name_16);
            Py_DECREF(tmp_called_name_17);
            Py_DECREF(tmp_args_element_name_16);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 91;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_17;
            condexpr_false_17:;
            tmp_classmethod_arg_1 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_16_getOperationBinaryAddShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_1);
            Py_DECREF(tmp_classmethod_arg_1);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 91;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_17:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryAddShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 91;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_sub_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 109;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_21;
            PyObject *tmp_called_name_18;
            PyObject *tmp_args_element_name_17;
            PyObject *tmp_classmethod_arg_2;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 111;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_21 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_21 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_18;
            } else {
                goto condexpr_false_18;
            }
            condexpr_true_18:;
            tmp_called_name_18 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_18 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 111;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_18 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 111;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_17 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 111;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_18, tmp_args_element_name_17);
            Py_DECREF(tmp_called_name_18);
            Py_DECREF(tmp_args_element_name_17);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 111;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_18;
            condexpr_false_18:;
            tmp_classmethod_arg_2 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_17_getOperationBinarySubShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_2);
            Py_DECREF(tmp_classmethod_arg_2);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 111;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_18:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinarySubShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 111;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_mul_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 129;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_22;
            PyObject *tmp_called_name_19;
            PyObject *tmp_args_element_name_18;
            PyObject *tmp_classmethod_arg_3;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 131;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_22 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_22 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_19;
            } else {
                goto condexpr_false_19;
            }
            condexpr_true_19:;
            tmp_called_name_19 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_19 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 131;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_19 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 131;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_18 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 131;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_19, tmp_args_element_name_18);
            Py_DECREF(tmp_called_name_19);
            Py_DECREF(tmp_args_element_name_18);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 131;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_19;
            condexpr_false_19:;
            tmp_classmethod_arg_3 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_18_getOperationBinaryMultShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_3);
            Py_DECREF(tmp_classmethod_arg_3);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 131;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_19:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryMultShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 131;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_floordiv_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 149;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_23;
            PyObject *tmp_called_name_20;
            PyObject *tmp_args_element_name_19;
            PyObject *tmp_classmethod_arg_4;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 151;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_23 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_23 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_20;
            } else {
                goto condexpr_false_20;
            }
            condexpr_true_20:;
            tmp_called_name_20 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_20 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 151;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_20 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 151;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_19 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 151;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_20, tmp_args_element_name_19);
            Py_DECREF(tmp_called_name_20);
            Py_DECREF(tmp_args_element_name_19);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 151;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_20;
            condexpr_false_20:;
            tmp_classmethod_arg_4 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_19_getOperationBinaryFloorDivShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_4);
            Py_DECREF(tmp_classmethod_arg_4);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 151;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_20:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryFloorDivShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 151;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_olddiv_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 170;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_24;
            PyObject *tmp_called_name_21;
            PyObject *tmp_args_element_name_20;
            PyObject *tmp_classmethod_arg_5;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 172;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_24 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_24 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_21;
            } else {
                goto condexpr_false_21;
            }
            condexpr_true_21:;
            tmp_called_name_21 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_21 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 172;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_21 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 172;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_20 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 172;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_21, tmp_args_element_name_20);
            Py_DECREF(tmp_called_name_21);
            Py_DECREF(tmp_args_element_name_20);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 172;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_21;
            condexpr_false_21:;
            tmp_classmethod_arg_5 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_20_getOperationBinaryOldDivShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_5);
            Py_DECREF(tmp_classmethod_arg_5);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 172;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_21:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryOldDivShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 172;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_truediv_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 191;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_25;
            PyObject *tmp_called_name_22;
            PyObject *tmp_args_element_name_21;
            PyObject *tmp_classmethod_arg_6;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 193;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_25 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_25 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_22;
            } else {
                goto condexpr_false_22;
            }
            condexpr_true_22:;
            tmp_called_name_22 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_22 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 193;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_22 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 193;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_21 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 193;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_22, tmp_args_element_name_21);
            Py_DECREF(tmp_called_name_22);
            Py_DECREF(tmp_args_element_name_21);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 193;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_22;
            condexpr_false_22:;
            tmp_classmethod_arg_6 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_21_getOperationBinaryTrueDivShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_6);
            Py_DECREF(tmp_classmethod_arg_6);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 193;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_22:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryTrueDivShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 193;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_mod_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 212;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_26;
            PyObject *tmp_called_name_23;
            PyObject *tmp_args_element_name_22;
            PyObject *tmp_classmethod_arg_7;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 214;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_26 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_26 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_23;
            } else {
                goto condexpr_false_23;
            }
            condexpr_true_23:;
            tmp_called_name_23 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_23 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 214;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_23 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 214;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_22 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 214;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_23, tmp_args_element_name_22);
            Py_DECREF(tmp_called_name_23);
            Py_DECREF(tmp_args_element_name_22);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 214;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_23;
            condexpr_false_23:;
            tmp_classmethod_arg_7 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_22_getOperationBinaryModShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_7);
            Py_DECREF(tmp_classmethod_arg_7);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 214;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_23:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryModShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 214;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_pow_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 233;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_27;
            PyObject *tmp_called_name_24;
            PyObject *tmp_args_element_name_23;
            PyObject *tmp_classmethod_arg_8;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 235;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_27 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_27 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_24;
            } else {
                goto condexpr_false_24;
            }
            condexpr_true_24:;
            tmp_called_name_24 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_24 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 235;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_24 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 235;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_23 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 235;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_24, tmp_args_element_name_23);
            Py_DECREF(tmp_called_name_24);
            Py_DECREF(tmp_args_element_name_23);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 235;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_24;
            condexpr_false_24:;
            tmp_classmethod_arg_8 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_23_getOperationBinaryPowShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_8);
            Py_DECREF(tmp_classmethod_arg_8);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 235;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_24:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryPowShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 235;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_lshift_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 254;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_28;
            PyObject *tmp_called_name_25;
            PyObject *tmp_args_element_name_24;
            PyObject *tmp_classmethod_arg_9;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 256;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_28 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_28 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_25;
            } else {
                goto condexpr_false_25;
            }
            condexpr_true_25:;
            tmp_called_name_25 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_25 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 256;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_25 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 256;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_24 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 256;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_25, tmp_args_element_name_24);
            Py_DECREF(tmp_called_name_25);
            Py_DECREF(tmp_args_element_name_24);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 256;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_25;
            condexpr_false_25:;
            tmp_classmethod_arg_9 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_24_getOperationBinaryLShiftShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_9);
            Py_DECREF(tmp_classmethod_arg_9);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 256;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_25:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryLShiftShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 256;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_rshift_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 275;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_29;
            PyObject *tmp_called_name_26;
            PyObject *tmp_args_element_name_25;
            PyObject *tmp_classmethod_arg_10;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 277;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_29 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_29 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_26;
            } else {
                goto condexpr_false_26;
            }
            condexpr_true_26:;
            tmp_called_name_26 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_26 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 277;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_26 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 277;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_25 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 277;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_26, tmp_args_element_name_25);
            Py_DECREF(tmp_called_name_26);
            Py_DECREF(tmp_args_element_name_25);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 277;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_26;
            condexpr_false_26:;
            tmp_classmethod_arg_10 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_25_getOperationBinaryRShiftShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_10);
            Py_DECREF(tmp_classmethod_arg_10);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 277;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_26:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryRShiftShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 277;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_bitor_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 296;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_30;
            PyObject *tmp_called_name_27;
            PyObject *tmp_args_element_name_26;
            PyObject *tmp_classmethod_arg_11;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 298;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_30 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_30 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_27;
            } else {
                goto condexpr_false_27;
            }
            condexpr_true_27:;
            tmp_called_name_27 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_27 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 298;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_27 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 298;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_26 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 298;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_27, tmp_args_element_name_26);
            Py_DECREF(tmp_called_name_27);
            Py_DECREF(tmp_args_element_name_26);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 298;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_27;
            condexpr_false_27:;
            tmp_classmethod_arg_11 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_26_getOperationBinaryBitOrShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_11);
            Py_DECREF(tmp_classmethod_arg_11);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 298;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_27:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryBitOrShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 298;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_bitand_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 317;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_31;
            PyObject *tmp_called_name_28;
            PyObject *tmp_args_element_name_27;
            PyObject *tmp_classmethod_arg_12;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 319;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_31 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_31 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_28;
            } else {
                goto condexpr_false_28;
            }
            condexpr_true_28:;
            tmp_called_name_28 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_28 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 319;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_28 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 319;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_27 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 319;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_28, tmp_args_element_name_27);
            Py_DECREF(tmp_called_name_28);
            Py_DECREF(tmp_args_element_name_27);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 319;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_28;
            condexpr_false_28:;
            tmp_classmethod_arg_12 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_27_getOperationBinaryBitAndShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_12);
            Py_DECREF(tmp_classmethod_arg_12);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 319;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_28:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryBitAndShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 319;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_bitxor_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 338;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_32;
            PyObject *tmp_called_name_29;
            PyObject *tmp_args_element_name_28;
            PyObject *tmp_classmethod_arg_13;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 340;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_32 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_32 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_29;
            } else {
                goto condexpr_false_29;
            }
            condexpr_true_29:;
            tmp_called_name_29 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_29 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 340;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_29 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 340;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_28 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 340;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_29, tmp_args_element_name_28);
            Py_DECREF(tmp_called_name_29);
            Py_DECREF(tmp_args_element_name_28);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 340;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_29;
            condexpr_false_29:;
            tmp_classmethod_arg_13 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_28_getOperationBinaryBitXorShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_13);
            Py_DECREF(tmp_classmethod_arg_13);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 340;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_29:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryBitXorShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 340;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = PyDict_New();
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_matmult_shapes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 359;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_33;
            PyObject *tmp_called_name_30;
            PyObject *tmp_args_element_name_29;
            PyObject *tmp_classmethod_arg_14;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 361;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_33 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_33 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_30;
            } else {
                goto condexpr_false_30;
            }
            condexpr_true_30:;
            tmp_called_name_30 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_30 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 361;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_30 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 361;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_29 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 361;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_30, tmp_args_element_name_29);
            Py_DECREF(tmp_called_name_30);
            Py_DECREF(tmp_args_element_name_29);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 361;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_30;
            condexpr_false_30:;
            tmp_classmethod_arg_14 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_29_getOperationBinaryMatMultShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_14);
            Py_DECREF(tmp_classmethod_arg_14);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 361;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_30:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getOperationBinaryMatMultShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 361;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_34;
            PyObject *tmp_called_name_31;
            PyObject *tmp_args_element_name_30;
            PyObject *tmp_classmethod_arg_15;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_34 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_34 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_31;
            } else {
                goto condexpr_false_31;
            }
            condexpr_true_31:;
            tmp_called_name_31 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_31 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_31 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_30 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 380;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_31, tmp_args_element_name_30);
            Py_DECREF(tmp_called_name_31);
            Py_DECREF(tmp_args_element_name_30);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_31;
            condexpr_false_31:;
            tmp_classmethod_arg_15 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_30_getComparisonLtShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_15);
            Py_DECREF(tmp_classmethod_arg_15);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_31:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getComparisonLtShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 380;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_35;
            PyObject *tmp_called_name_32;
            PyObject *tmp_args_element_name_31;
            PyObject *tmp_classmethod_arg_16;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 386;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_35 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_35 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_32;
            } else {
                goto condexpr_false_32;
            }
            condexpr_true_32:;
            tmp_called_name_32 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_32 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 386;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_32 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 386;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_31 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 386;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_32, tmp_args_element_name_31);
            Py_DECREF(tmp_called_name_32);
            Py_DECREF(tmp_args_element_name_31);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 386;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_32;
            condexpr_false_32:;
            tmp_classmethod_arg_16 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_31_getComparisonLteShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_16);
            Py_DECREF(tmp_classmethod_arg_16);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 386;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_32:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getComparisonLteShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 386;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_36;
            PyObject *tmp_called_name_33;
            PyObject *tmp_args_element_name_32;
            PyObject *tmp_classmethod_arg_17;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 390;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_36 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_36 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_33;
            } else {
                goto condexpr_false_33;
            }
            condexpr_true_33:;
            tmp_called_name_33 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_33 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 390;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_33 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 390;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_32 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 390;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_33, tmp_args_element_name_32);
            Py_DECREF(tmp_called_name_33);
            Py_DECREF(tmp_args_element_name_32);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 390;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_33;
            condexpr_false_33:;
            tmp_classmethod_arg_17 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_32_getComparisonGtShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_17);
            Py_DECREF(tmp_classmethod_arg_17);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 390;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_33:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getComparisonGtShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 390;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_37;
            PyObject *tmp_called_name_34;
            PyObject *tmp_args_element_name_33;
            PyObject *tmp_classmethod_arg_18;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 394;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_37 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_37 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_34;
            } else {
                goto condexpr_false_34;
            }
            condexpr_true_34:;
            tmp_called_name_34 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_34 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 394;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_34 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 394;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_33 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 394;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_34, tmp_args_element_name_33);
            Py_DECREF(tmp_called_name_34);
            Py_DECREF(tmp_args_element_name_33);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 394;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_34;
            condexpr_false_34:;
            tmp_classmethod_arg_18 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_33_getComparisonGteShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_18);
            Py_DECREF(tmp_classmethod_arg_18);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 394;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_34:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getComparisonGteShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 394;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_38;
            PyObject *tmp_called_name_35;
            PyObject *tmp_args_element_name_34;
            PyObject *tmp_classmethod_arg_19;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 398;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_38 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_38 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_35;
            } else {
                goto condexpr_false_35;
            }
            condexpr_true_35:;
            tmp_called_name_35 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_35 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 398;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_35 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 398;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_34 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 398;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_35, tmp_args_element_name_34);
            Py_DECREF(tmp_called_name_35);
            Py_DECREF(tmp_args_element_name_34);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 398;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_35;
            condexpr_false_35:;
            tmp_classmethod_arg_19 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_34_getComparisonEqShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_19);
            Py_DECREF(tmp_classmethod_arg_19);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 398;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_35:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getComparisonEqShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 398;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_39;
            PyObject *tmp_called_name_36;
            PyObject *tmp_args_element_name_35;
            PyObject *tmp_classmethod_arg_20;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 402;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_39 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_39 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_36;
            } else {
                goto condexpr_false_36;
            }
            condexpr_true_36:;
            tmp_called_name_36 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_36 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 402;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_36 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 402;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_35 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 402;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_36, tmp_args_element_name_35);
            Py_DECREF(tmp_called_name_36);
            Py_DECREF(tmp_args_element_name_35);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 402;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_36;
            condexpr_false_36:;
            tmp_classmethod_arg_20 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_35_getComparisonNeqShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_20);
            Py_DECREF(tmp_classmethod_arg_20);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 402;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_36:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_getComparisonNeqShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 402;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            nuitka_bool tmp_condition_result_40;
            PyObject *tmp_called_name_37;
            PyObject *tmp_args_element_name_36;
            PyObject *tmp_classmethod_arg_21;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 406;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_40 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_40 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_37;
            } else {
                goto condexpr_false_37;
            }
            condexpr_true_37:;
            tmp_called_name_37 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_classmethod);

            if (tmp_called_name_37 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 406;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_37 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 406;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_36 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives();



            frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame.f_lineno = 406;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_37, tmp_args_element_name_36);
            Py_DECREF(tmp_called_name_37);
            Py_DECREF(tmp_args_element_name_36);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 406;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_37;
            condexpr_false_37:;
            tmp_classmethod_arg_21 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_36_emitAlternatives();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_21);
            Py_DECREF(tmp_classmethod_arg_21);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 406;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_37:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26, const_str_plain_emitAlternatives, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 406;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2a661cbeaf4f4cdde5f67a06430e33d1_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2a661cbeaf4f4cdde5f67a06430e33d1_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_2a661cbeaf4f4cdde5f67a06430e33d1_2, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_2a661cbeaf4f4cdde5f67a06430e33d1_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_2a661cbeaf4f4cdde5f67a06430e33d1_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_2a661cbeaf4f4cdde5f67a06430e33d1_2,
            type_description_2,
            outline_0_var___class__
        );


        // Release cached frame.
        if (frame_2a661cbeaf4f4cdde5f67a06430e33d1_2 == cache_frame_2a661cbeaf4f4cdde5f67a06430e33d1_2) {
            Py_DECREF(frame_2a661cbeaf4f4cdde5f67a06430e33d1_2);
        }
        cache_frame_2a661cbeaf4f4cdde5f67a06430e33d1_2 = NULL;

        assertFrameObject(frame_2a661cbeaf4f4cdde5f67a06430e33d1_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_3;
        skip_nested_handling_1:;
        {
            PyObject *tmp_assign_source_12;
            PyObject *tmp_called_name_38;
            PyObject *tmp_args_name_2;
            PyObject *tmp_tuple_element_2;
            PyObject *tmp_kw_name_2;
            CHECK_OBJECT(tmp_class_creation_1__metaclass);
            tmp_called_name_38 = tmp_class_creation_1__metaclass;
            tmp_tuple_element_2 = const_str_plain_ShapeBase;
            tmp_args_name_2 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_2);
            PyTuple_SET_ITEM(tmp_args_name_2, 0, tmp_tuple_element_2);
            tmp_tuple_element_2 = const_tuple_type_object_tuple;
            Py_INCREF(tmp_tuple_element_2);
            PyTuple_SET_ITEM(tmp_args_name_2, 1, tmp_tuple_element_2);
            tmp_tuple_element_2 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26;
            Py_INCREF(tmp_tuple_element_2);
            PyTuple_SET_ITEM(tmp_args_name_2, 2, tmp_tuple_element_2);
            CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
            tmp_kw_name_2 = tmp_class_creation_1__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 26;
            tmp_assign_source_12 = CALL_FUNCTION(tmp_called_name_38, tmp_args_name_2, tmp_kw_name_2);
            Py_DECREF(tmp_args_name_2);
            if (tmp_assign_source_12 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 26;

                goto try_except_handler_3;
            }
            assert(outline_0_var___class__ == NULL);
            outline_0_var___class__ = tmp_assign_source_12;
        }
        CHECK_OBJECT(outline_0_var___class__);
        tmp_assign_source_11 = outline_0_var___class__;
        Py_INCREF(tmp_assign_source_11);
        goto try_return_handler_3;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26 = NULL;
        goto try_return_handler_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_26 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT((PyObject *)outline_0_var___class__);
        Py_DECREF(outline_0_var___class__);
        outline_0_var___class__ = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_1:;
        exception_lineno = 26;
        goto try_except_handler_1;
        outline_result_1:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeBase, tmp_assign_source_11);
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class_decl_dict);
    Py_DECREF(tmp_class_creation_1__class_decl_dict);
    tmp_class_creation_1__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_1__prepared);
    tmp_class_creation_1__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_1__class_decl_dict);
    Py_DECREF(tmp_class_creation_1__class_decl_dict);
    tmp_class_creation_1__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__metaclass);
    Py_DECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_1__prepared);
    Py_DECREF(tmp_class_creation_1__prepared);
    tmp_class_creation_1__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeBase);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeBase);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 79774 ], 31, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 411;

            goto try_except_handler_4;
        }

        tmp_tuple_element_3 = tmp_mvar_value_3;
        tmp_assign_source_13 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_3);
        PyTuple_SET_ITEM(tmp_assign_source_13, 0, tmp_tuple_element_3);
        assert(tmp_class_creation_2__bases == NULL);
        tmp_class_creation_2__bases = tmp_assign_source_13;
    }
    {
        PyObject *tmp_assign_source_14;
        tmp_assign_source_14 = PyDict_New();
        assert(tmp_class_creation_2__class_decl_dict == NULL);
        tmp_class_creation_2__class_decl_dict = tmp_assign_source_14;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_metaclass_name_2;
        nuitka_bool tmp_condition_result_41;
        PyObject *tmp_key_name_4;
        PyObject *tmp_dict_name_4;
        PyObject *tmp_dict_name_5;
        PyObject *tmp_key_name_5;
        PyObject *tmp_type_arg_2;
        PyObject *tmp_subscribed_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_bases_name_2;
        tmp_key_name_4 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_2__class_decl_dict);
        tmp_dict_name_4 = tmp_class_creation_2__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_4, tmp_key_name_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_4;
        }
        tmp_condition_result_41 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_41 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_38;
        } else {
            goto condexpr_false_38;
        }
        condexpr_true_38:;
        CHECK_OBJECT(tmp_class_creation_2__class_decl_dict);
        tmp_dict_name_5 = tmp_class_creation_2__class_decl_dict;
        tmp_key_name_5 = const_str_plain_metaclass;
        tmp_metaclass_name_2 = DICT_GET_ITEM(tmp_dict_name_5, tmp_key_name_5);
        if (tmp_metaclass_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_4;
        }
        goto condexpr_end_38;
        condexpr_false_38:;
        CHECK_OBJECT(tmp_class_creation_2__bases);
        tmp_subscribed_name_1 = tmp_class_creation_2__bases;
        tmp_subscript_name_1 = const_int_0;
        tmp_type_arg_2 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_1, tmp_subscript_name_1, 0);
        if (tmp_type_arg_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_4;
        }
        tmp_metaclass_name_2 = BUILTIN_TYPE1(tmp_type_arg_2);
        Py_DECREF(tmp_type_arg_2);
        if (tmp_metaclass_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_4;
        }
        condexpr_end_38:;
        CHECK_OBJECT(tmp_class_creation_2__bases);
        tmp_bases_name_2 = tmp_class_creation_2__bases;
        tmp_assign_source_15 = SELECT_METACLASS(tmp_metaclass_name_2, tmp_bases_name_2);
        Py_DECREF(tmp_metaclass_name_2);
        if (tmp_assign_source_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_4;
        }
        assert(tmp_class_creation_2__metaclass == NULL);
        tmp_class_creation_2__metaclass = tmp_assign_source_15;
    }
    {
        nuitka_bool tmp_condition_result_42;
        PyObject *tmp_key_name_6;
        PyObject *tmp_dict_name_6;
        tmp_key_name_6 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_2__class_decl_dict);
        tmp_dict_name_6 = tmp_class_creation_2__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_6, tmp_key_name_6);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_4;
        }
        tmp_condition_result_42 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_42 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
        branch_yes_4:;
        CHECK_OBJECT(tmp_class_creation_2__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_2__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_4;
        }
        branch_no_4:;
    }
    {
        nuitka_bool tmp_condition_result_43;
        PyObject *tmp_source_name_5;
        CHECK_OBJECT(tmp_class_creation_2__metaclass);
        tmp_source_name_5 = tmp_class_creation_2__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_5, const_str_plain___prepare__);
        tmp_condition_result_43 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_43 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
        branch_yes_5:;
        {
            PyObject *tmp_assign_source_16;
            PyObject *tmp_called_name_39;
            PyObject *tmp_source_name_6;
            PyObject *tmp_args_name_3;
            PyObject *tmp_tuple_element_4;
            PyObject *tmp_kw_name_3;
            CHECK_OBJECT(tmp_class_creation_2__metaclass);
            tmp_source_name_6 = tmp_class_creation_2__metaclass;
            tmp_called_name_39 = LOOKUP_ATTRIBUTE(tmp_source_name_6, const_str_plain___prepare__);
            if (tmp_called_name_39 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 411;

                goto try_except_handler_4;
            }
            tmp_tuple_element_4 = const_str_plain_ShapeUnknown;
            tmp_args_name_3 = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_4);
            PyTuple_SET_ITEM(tmp_args_name_3, 0, tmp_tuple_element_4);
            CHECK_OBJECT(tmp_class_creation_2__bases);
            tmp_tuple_element_4 = tmp_class_creation_2__bases;
            Py_INCREF(tmp_tuple_element_4);
            PyTuple_SET_ITEM(tmp_args_name_3, 1, tmp_tuple_element_4);
            CHECK_OBJECT(tmp_class_creation_2__class_decl_dict);
            tmp_kw_name_3 = tmp_class_creation_2__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 411;
            tmp_assign_source_16 = CALL_FUNCTION(tmp_called_name_39, tmp_args_name_3, tmp_kw_name_3);
            Py_DECREF(tmp_called_name_39);
            Py_DECREF(tmp_args_name_3);
            if (tmp_assign_source_16 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 411;

                goto try_except_handler_4;
            }
            assert(tmp_class_creation_2__prepared == NULL);
            tmp_class_creation_2__prepared = tmp_assign_source_16;
        }
        {
            nuitka_bool tmp_condition_result_44;
            PyObject *tmp_operand_name_2;
            PyObject *tmp_source_name_7;
            CHECK_OBJECT(tmp_class_creation_2__prepared);
            tmp_source_name_7 = tmp_class_creation_2__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_7, const_str_plain___getitem__);
            tmp_operand_name_2 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 411;

                goto try_except_handler_4;
            }
            tmp_condition_result_44 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_44 == NUITKA_BOOL_TRUE) {
                goto branch_yes_6;
            } else {
                goto branch_no_6;
            }
            branch_yes_6:;
            {
                PyObject *tmp_raise_type_2;
                PyObject *tmp_raise_value_2;
                PyObject *tmp_left_name_2;
                PyObject *tmp_right_name_2;
                PyObject *tmp_tuple_element_5;
                PyObject *tmp_getattr_target_2;
                PyObject *tmp_getattr_attr_2;
                PyObject *tmp_getattr_default_2;
                PyObject *tmp_source_name_8;
                PyObject *tmp_type_arg_3;
                tmp_raise_type_2 = PyExc_TypeError;
                tmp_left_name_2 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_2__metaclass);
                tmp_getattr_target_2 = tmp_class_creation_2__metaclass;
                tmp_getattr_attr_2 = const_str_plain___name__;
                tmp_getattr_default_2 = const_str_angle_metaclass;
                tmp_tuple_element_5 = BUILTIN_GETATTR(tmp_getattr_target_2, tmp_getattr_attr_2, tmp_getattr_default_2);
                if (tmp_tuple_element_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 411;

                    goto try_except_handler_4;
                }
                tmp_right_name_2 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_2, 0, tmp_tuple_element_5);
                CHECK_OBJECT(tmp_class_creation_2__prepared);
                tmp_type_arg_3 = tmp_class_creation_2__prepared;
                tmp_source_name_8 = BUILTIN_TYPE1(tmp_type_arg_3);
                assert(!(tmp_source_name_8 == NULL));
                tmp_tuple_element_5 = LOOKUP_ATTRIBUTE(tmp_source_name_8, const_str_plain___name__);
                Py_DECREF(tmp_source_name_8);
                if (tmp_tuple_element_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_2);

                    exception_lineno = 411;

                    goto try_except_handler_4;
                }
                PyTuple_SET_ITEM(tmp_right_name_2, 1, tmp_tuple_element_5);
                tmp_raise_value_2 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_2, tmp_right_name_2);
                Py_DECREF(tmp_right_name_2);
                if (tmp_raise_value_2 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 411;

                    goto try_except_handler_4;
                }
                exception_type = tmp_raise_type_2;
                Py_INCREF(tmp_raise_type_2);
                exception_value = tmp_raise_value_2;
                exception_lineno = 411;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_4;
            }
            branch_no_6:;
        }
        goto branch_end_5;
        branch_no_5:;
        {
            PyObject *tmp_assign_source_17;
            tmp_assign_source_17 = PyDict_New();
            assert(tmp_class_creation_2__prepared == NULL);
            tmp_class_creation_2__prepared = tmp_assign_source_17;
        }
        branch_end_5:;
    }
    {
        PyObject *tmp_assign_source_18;
        {
            PyObject *tmp_set_locals_2;
            CHECK_OBJECT(tmp_class_creation_2__prepared);
            tmp_set_locals_2 = tmp_class_creation_2__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411 = tmp_set_locals_2;
            Py_INCREF(tmp_set_locals_2);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_6;
        }
        tmp_dictset_value = const_str_plain_ShapeUnknown;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;

            goto try_except_handler_6;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_443e077e6134ea2158171ecac004feeb_3, codeobj_443e077e6134ea2158171ecac004feeb, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_443e077e6134ea2158171ecac004feeb_3 = cache_frame_443e077e6134ea2158171ecac004feeb_3;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_443e077e6134ea2158171ecac004feeb_3);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_443e077e6134ea2158171ecac004feeb_3) == 2); // Frame stack

        // Framed code:
        {
            nuitka_bool tmp_condition_result_45;
            PyObject *tmp_called_name_40;
            PyObject *tmp_args_element_name_37;
            PyObject *tmp_classmethod_arg_22;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 412;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_45 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_45 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_39;
            } else {
                goto condexpr_false_39;
            }
            condexpr_true_39:;
            tmp_called_name_40 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_40 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 412;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_40 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 412;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_37 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 412;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_40, tmp_args_element_name_37);
            Py_DECREF(tmp_called_name_40);
            Py_DECREF(tmp_args_element_name_37);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 412;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_39;
            condexpr_false_39:;
            tmp_classmethod_arg_22 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_37_getOperationBinaryAddShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_22);
            Py_DECREF(tmp_classmethod_arg_22);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 412;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_39:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryAddShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 412;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_46;
            PyObject *tmp_called_name_41;
            PyObject *tmp_args_element_name_38;
            PyObject *tmp_classmethod_arg_23;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_46 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_46 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_40;
            } else {
                goto condexpr_false_40;
            }
            condexpr_true_40:;
            tmp_called_name_41 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_41 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 416;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_41 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_38 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 416;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_41, tmp_args_element_name_38);
            Py_DECREF(tmp_called_name_41);
            Py_DECREF(tmp_args_element_name_38);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_40;
            condexpr_false_40:;
            tmp_classmethod_arg_23 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_38_getOperationBinarySubShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_23);
            Py_DECREF(tmp_classmethod_arg_23);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_40:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinarySubShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 416;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_47;
            PyObject *tmp_called_name_42;
            PyObject *tmp_args_element_name_39;
            PyObject *tmp_classmethod_arg_24;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 420;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_47 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_47 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_41;
            } else {
                goto condexpr_false_41;
            }
            condexpr_true_41:;
            tmp_called_name_42 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_42 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 420;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_42 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 420;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_39 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 420;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_42, tmp_args_element_name_39);
            Py_DECREF(tmp_called_name_42);
            Py_DECREF(tmp_args_element_name_39);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 420;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_41;
            condexpr_false_41:;
            tmp_classmethod_arg_24 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_39_getOperationBinaryMultShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_24);
            Py_DECREF(tmp_classmethod_arg_24);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 420;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_41:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryMultShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 420;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_48;
            PyObject *tmp_called_name_43;
            PyObject *tmp_args_element_name_40;
            PyObject *tmp_classmethod_arg_25;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 424;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_48 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_48 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_42;
            } else {
                goto condexpr_false_42;
            }
            condexpr_true_42:;
            tmp_called_name_43 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_43 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 424;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_43 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 424;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_40 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 424;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_43, tmp_args_element_name_40);
            Py_DECREF(tmp_called_name_43);
            Py_DECREF(tmp_args_element_name_40);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 424;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_42;
            condexpr_false_42:;
            tmp_classmethod_arg_25 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_40_getOperationBinaryFloorDivShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_25);
            Py_DECREF(tmp_classmethod_arg_25);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 424;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_42:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryFloorDivShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 424;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_49;
            PyObject *tmp_called_name_44;
            PyObject *tmp_args_element_name_41;
            PyObject *tmp_classmethod_arg_26;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 428;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_49 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_49 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_43;
            } else {
                goto condexpr_false_43;
            }
            condexpr_true_43:;
            tmp_called_name_44 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_44 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 428;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_44 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 428;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_41 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 428;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_44, tmp_args_element_name_41);
            Py_DECREF(tmp_called_name_44);
            Py_DECREF(tmp_args_element_name_41);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 428;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_43;
            condexpr_false_43:;
            tmp_classmethod_arg_26 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_41_getOperationBinaryOldDivShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_26);
            Py_DECREF(tmp_classmethod_arg_26);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 428;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_43:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryOldDivShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 428;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_50;
            PyObject *tmp_called_name_45;
            PyObject *tmp_args_element_name_42;
            PyObject *tmp_classmethod_arg_27;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 432;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_50 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_50 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_44;
            } else {
                goto condexpr_false_44;
            }
            condexpr_true_44:;
            tmp_called_name_45 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_45 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 432;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_45 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 432;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_42 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 432;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_45, tmp_args_element_name_42);
            Py_DECREF(tmp_called_name_45);
            Py_DECREF(tmp_args_element_name_42);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 432;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_44;
            condexpr_false_44:;
            tmp_classmethod_arg_27 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_42_getOperationBinaryTrueDivShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_27);
            Py_DECREF(tmp_classmethod_arg_27);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 432;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_44:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryTrueDivShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 432;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_51;
            PyObject *tmp_called_name_46;
            PyObject *tmp_args_element_name_43;
            PyObject *tmp_classmethod_arg_28;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 436;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_51 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_51 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_45;
            } else {
                goto condexpr_false_45;
            }
            condexpr_true_45:;
            tmp_called_name_46 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_46 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 436;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_46 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 436;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_43 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 436;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_46, tmp_args_element_name_43);
            Py_DECREF(tmp_called_name_46);
            Py_DECREF(tmp_args_element_name_43);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 436;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_45;
            condexpr_false_45:;
            tmp_classmethod_arg_28 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_43_getOperationBinaryModShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_28);
            Py_DECREF(tmp_classmethod_arg_28);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 436;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_45:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryModShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 436;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_52;
            PyObject *tmp_called_name_47;
            PyObject *tmp_args_element_name_44;
            PyObject *tmp_classmethod_arg_29;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 440;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_52 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_52 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_46;
            } else {
                goto condexpr_false_46;
            }
            condexpr_true_46:;
            tmp_called_name_47 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_47 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 440;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_47 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 440;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_44 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 440;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_47, tmp_args_element_name_44);
            Py_DECREF(tmp_called_name_47);
            Py_DECREF(tmp_args_element_name_44);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 440;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_46;
            condexpr_false_46:;
            tmp_classmethod_arg_29 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_44_getOperationBinaryPowShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_29);
            Py_DECREF(tmp_classmethod_arg_29);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 440;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_46:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryPowShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 440;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_53;
            PyObject *tmp_called_name_48;
            PyObject *tmp_args_element_name_45;
            PyObject *tmp_classmethod_arg_30;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 444;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_53 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_53 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_47;
            } else {
                goto condexpr_false_47;
            }
            condexpr_true_47:;
            tmp_called_name_48 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_48 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 444;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_48 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 444;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_45 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 444;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_48, tmp_args_element_name_45);
            Py_DECREF(tmp_called_name_48);
            Py_DECREF(tmp_args_element_name_45);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 444;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_47;
            condexpr_false_47:;
            tmp_classmethod_arg_30 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_45_getOperationBinaryLShiftShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_30);
            Py_DECREF(tmp_classmethod_arg_30);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 444;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_47:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryLShiftShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 444;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_54;
            PyObject *tmp_called_name_49;
            PyObject *tmp_args_element_name_46;
            PyObject *tmp_classmethod_arg_31;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 448;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_54 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_54 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_48;
            } else {
                goto condexpr_false_48;
            }
            condexpr_true_48:;
            tmp_called_name_49 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_49 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 448;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_49 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 448;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_46 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 448;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_49, tmp_args_element_name_46);
            Py_DECREF(tmp_called_name_49);
            Py_DECREF(tmp_args_element_name_46);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 448;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_48;
            condexpr_false_48:;
            tmp_classmethod_arg_31 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_46_getOperationBinaryRShiftShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_31);
            Py_DECREF(tmp_classmethod_arg_31);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 448;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_48:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryRShiftShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 448;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_55;
            PyObject *tmp_called_name_50;
            PyObject *tmp_args_element_name_47;
            PyObject *tmp_classmethod_arg_32;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 452;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_55 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_55 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_49;
            } else {
                goto condexpr_false_49;
            }
            condexpr_true_49:;
            tmp_called_name_50 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_50 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 452;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_50 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 452;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_47 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 452;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_50, tmp_args_element_name_47);
            Py_DECREF(tmp_called_name_50);
            Py_DECREF(tmp_args_element_name_47);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 452;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_49;
            condexpr_false_49:;
            tmp_classmethod_arg_32 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_47_getOperationBinaryBitOrShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_32);
            Py_DECREF(tmp_classmethod_arg_32);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 452;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_49:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryBitOrShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 452;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_56;
            PyObject *tmp_called_name_51;
            PyObject *tmp_args_element_name_48;
            PyObject *tmp_classmethod_arg_33;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 456;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_56 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_56 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_50;
            } else {
                goto condexpr_false_50;
            }
            condexpr_true_50:;
            tmp_called_name_51 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_51 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 456;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_51 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 456;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_48 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 456;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_51, tmp_args_element_name_48);
            Py_DECREF(tmp_called_name_51);
            Py_DECREF(tmp_args_element_name_48);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 456;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_50;
            condexpr_false_50:;
            tmp_classmethod_arg_33 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_48_getOperationBinaryBitAndShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_33);
            Py_DECREF(tmp_classmethod_arg_33);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 456;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_50:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryBitAndShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 456;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_57;
            PyObject *tmp_called_name_52;
            PyObject *tmp_args_element_name_49;
            PyObject *tmp_classmethod_arg_34;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 460;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_57 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_57 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_51;
            } else {
                goto condexpr_false_51;
            }
            condexpr_true_51:;
            tmp_called_name_52 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_52 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 460;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_52 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 460;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_49 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 460;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_52, tmp_args_element_name_49);
            Py_DECREF(tmp_called_name_52);
            Py_DECREF(tmp_args_element_name_49);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 460;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_51;
            condexpr_false_51:;
            tmp_classmethod_arg_34 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_49_getOperationBinaryBitXorShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_34);
            Py_DECREF(tmp_classmethod_arg_34);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 460;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_51:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryBitXorShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 460;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_58;
            PyObject *tmp_called_name_53;
            PyObject *tmp_args_element_name_50;
            PyObject *tmp_classmethod_arg_35;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 464;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_58 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_58 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_52;
            } else {
                goto condexpr_false_52;
            }
            condexpr_true_52:;
            tmp_called_name_53 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_53 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 464;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_53 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 464;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_50 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 464;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_53, tmp_args_element_name_50);
            Py_DECREF(tmp_called_name_53);
            Py_DECREF(tmp_args_element_name_50);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 464;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_52;
            condexpr_false_52:;
            tmp_classmethod_arg_35 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_50_getOperationBinaryMatMultShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_35);
            Py_DECREF(tmp_classmethod_arg_35);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 464;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_52:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getOperationBinaryMatMultShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 464;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }
        {
            nuitka_bool tmp_condition_result_59;
            PyObject *tmp_called_name_54;
            PyObject *tmp_args_element_name_51;
            PyObject *tmp_classmethod_arg_36;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 468;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_condition_result_59 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_59 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_53;
            } else {
                goto condexpr_false_53;
            }
            condexpr_true_53:;
            tmp_called_name_54 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_classmethod);

            if (tmp_called_name_54 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6480 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 468;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }

            if (tmp_called_name_54 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 468;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            tmp_args_element_name_51 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape();



            frame_443e077e6134ea2158171ecac004feeb_3->m_frame.f_lineno = 468;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_54, tmp_args_element_name_51);
            Py_DECREF(tmp_called_name_54);
            Py_DECREF(tmp_args_element_name_51);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 468;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            goto condexpr_end_53;
            condexpr_false_53:;
            tmp_classmethod_arg_36 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_51_getComparisonLtShape();



            tmp_dictset_value = BUILTIN_CLASSMETHOD(tmp_classmethod_arg_36);
            Py_DECREF(tmp_classmethod_arg_36);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 468;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
            condexpr_end_53:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411, const_str_plain_getComparisonLtShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 468;
                type_description_2 = "o";
                goto frame_exception_exit_3;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_443e077e6134ea2158171ecac004feeb_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_443e077e6134ea2158171ecac004feeb_3);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_443e077e6134ea2158171ecac004feeb_3, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_443e077e6134ea2158171ecac004feeb_3->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_443e077e6134ea2158171ecac004feeb_3, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_443e077e6134ea2158171ecac004feeb_3,
            type_description_2,
            outline_1_var___class__
        );


        // Release cached frame.
        if (frame_443e077e6134ea2158171ecac004feeb_3 == cache_frame_443e077e6134ea2158171ecac004feeb_3) {
            Py_DECREF(frame_443e077e6134ea2158171ecac004feeb_3);
        }
        cache_frame_443e077e6134ea2158171ecac004feeb_3 = NULL;

        assertFrameObject(frame_443e077e6134ea2158171ecac004feeb_3);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;

        goto try_except_handler_6;
        skip_nested_handling_2:;
        {
            PyObject *tmp_assign_source_19;
            PyObject *tmp_called_name_55;
            PyObject *tmp_args_name_4;
            PyObject *tmp_tuple_element_6;
            PyObject *tmp_kw_name_4;
            CHECK_OBJECT(tmp_class_creation_2__metaclass);
            tmp_called_name_55 = tmp_class_creation_2__metaclass;
            tmp_tuple_element_6 = const_str_plain_ShapeUnknown;
            tmp_args_name_4 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_6);
            PyTuple_SET_ITEM(tmp_args_name_4, 0, tmp_tuple_element_6);
            CHECK_OBJECT(tmp_class_creation_2__bases);
            tmp_tuple_element_6 = tmp_class_creation_2__bases;
            Py_INCREF(tmp_tuple_element_6);
            PyTuple_SET_ITEM(tmp_args_name_4, 1, tmp_tuple_element_6);
            tmp_tuple_element_6 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411;
            Py_INCREF(tmp_tuple_element_6);
            PyTuple_SET_ITEM(tmp_args_name_4, 2, tmp_tuple_element_6);
            CHECK_OBJECT(tmp_class_creation_2__class_decl_dict);
            tmp_kw_name_4 = tmp_class_creation_2__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 411;
            tmp_assign_source_19 = CALL_FUNCTION(tmp_called_name_55, tmp_args_name_4, tmp_kw_name_4);
            Py_DECREF(tmp_args_name_4);
            if (tmp_assign_source_19 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 411;

                goto try_except_handler_6;
            }
            assert(outline_1_var___class__ == NULL);
            outline_1_var___class__ = tmp_assign_source_19;
        }
        CHECK_OBJECT(outline_1_var___class__);
        tmp_assign_source_18 = outline_1_var___class__;
        Py_INCREF(tmp_assign_source_18);
        goto try_return_handler_6;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_6:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411 = NULL;
        goto try_return_handler_5;
        // Exception handler code:
        try_except_handler_6:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_411 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto try_except_handler_5;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_5:;
        CHECK_OBJECT((PyObject *)outline_1_var___class__);
        Py_DECREF(outline_1_var___class__);
        outline_1_var___class__ = NULL;

        goto outline_result_2;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_5 = exception_type;
        exception_keeper_value_5 = exception_value;
        exception_keeper_tb_5 = exception_tb;
        exception_keeper_lineno_5 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_5;
        exception_value = exception_keeper_value_5;
        exception_tb = exception_keeper_tb_5;
        exception_lineno = exception_keeper_lineno_5;

        goto outline_exception_2;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_2:;
        exception_lineno = 411;
        goto try_except_handler_4;
        outline_result_2:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown, tmp_assign_source_18);
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_2__bases);
    tmp_class_creation_2__bases = NULL;

    Py_XDECREF(tmp_class_creation_2__class_decl_dict);
    tmp_class_creation_2__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_2__prepared);
    tmp_class_creation_2__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_2__bases);
    Py_DECREF(tmp_class_creation_2__bases);
    tmp_class_creation_2__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__class_decl_dict);
    Py_DECREF(tmp_class_creation_2__class_decl_dict);
    tmp_class_creation_2__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__metaclass);
    Py_DECREF(tmp_class_creation_2__metaclass);
    tmp_class_creation_2__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_2__prepared);
    Py_DECREF(tmp_class_creation_2__prepared);
    tmp_class_creation_2__prepared = NULL;

    {
        PyObject *tmp_assign_source_20;
        tmp_assign_source_20 = PyDict_New();
        assert(tmp_class_creation_3__class_decl_dict == NULL);
        tmp_class_creation_3__class_decl_dict = tmp_assign_source_20;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_21;
        PyObject *tmp_metaclass_name_3;
        nuitka_bool tmp_condition_result_60;
        PyObject *tmp_key_name_7;
        PyObject *tmp_dict_name_7;
        PyObject *tmp_dict_name_8;
        PyObject *tmp_key_name_8;
        PyObject *tmp_bases_name_3;
        tmp_key_name_7 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_3__class_decl_dict);
        tmp_dict_name_7 = tmp_class_creation_3__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_7, tmp_key_name_7);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;

            goto try_except_handler_7;
        }
        tmp_condition_result_60 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_60 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_54;
        } else {
            goto condexpr_false_54;
        }
        condexpr_true_54:;
        CHECK_OBJECT(tmp_class_creation_3__class_decl_dict);
        tmp_dict_name_8 = tmp_class_creation_3__class_decl_dict;
        tmp_key_name_8 = const_str_plain_metaclass;
        tmp_metaclass_name_3 = DICT_GET_ITEM(tmp_dict_name_8, tmp_key_name_8);
        if (tmp_metaclass_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;

            goto try_except_handler_7;
        }
        goto condexpr_end_54;
        condexpr_false_54:;
        tmp_metaclass_name_3 = LOOKUP_BUILTIN(const_str_plain_type);
        assert(tmp_metaclass_name_3 != NULL);
        Py_INCREF(tmp_metaclass_name_3);
        condexpr_end_54:;
        tmp_bases_name_3 = const_tuple_type_object_tuple;
        tmp_assign_source_21 = SELECT_METACLASS(tmp_metaclass_name_3, tmp_bases_name_3);
        Py_DECREF(tmp_metaclass_name_3);
        if (tmp_assign_source_21 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;

            goto try_except_handler_7;
        }
        assert(tmp_class_creation_3__metaclass == NULL);
        tmp_class_creation_3__metaclass = tmp_assign_source_21;
    }
    {
        nuitka_bool tmp_condition_result_61;
        PyObject *tmp_key_name_9;
        PyObject *tmp_dict_name_9;
        tmp_key_name_9 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_3__class_decl_dict);
        tmp_dict_name_9 = tmp_class_creation_3__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_9, tmp_key_name_9);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;

            goto try_except_handler_7;
        }
        tmp_condition_result_61 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_61 == NUITKA_BOOL_TRUE) {
            goto branch_yes_7;
        } else {
            goto branch_no_7;
        }
        branch_yes_7:;
        CHECK_OBJECT(tmp_class_creation_3__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_3__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;

            goto try_except_handler_7;
        }
        branch_no_7:;
    }
    {
        nuitka_bool tmp_condition_result_62;
        PyObject *tmp_source_name_9;
        CHECK_OBJECT(tmp_class_creation_3__metaclass);
        tmp_source_name_9 = tmp_class_creation_3__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_9, const_str_plain___prepare__);
        tmp_condition_result_62 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_62 == NUITKA_BOOL_TRUE) {
            goto branch_yes_8;
        } else {
            goto branch_no_8;
        }
        branch_yes_8:;
        {
            PyObject *tmp_assign_source_22;
            PyObject *tmp_called_name_56;
            PyObject *tmp_source_name_10;
            PyObject *tmp_args_name_5;
            PyObject *tmp_kw_name_5;
            CHECK_OBJECT(tmp_class_creation_3__metaclass);
            tmp_source_name_10 = tmp_class_creation_3__metaclass;
            tmp_called_name_56 = LOOKUP_ATTRIBUTE(tmp_source_name_10, const_str_plain___prepare__);
            if (tmp_called_name_56 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 473;

                goto try_except_handler_7;
            }
            tmp_args_name_5 = const_tuple_str_plain_ValueShapeBase_tuple_type_object_tuple_tuple;
            CHECK_OBJECT(tmp_class_creation_3__class_decl_dict);
            tmp_kw_name_5 = tmp_class_creation_3__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 473;
            tmp_assign_source_22 = CALL_FUNCTION(tmp_called_name_56, tmp_args_name_5, tmp_kw_name_5);
            Py_DECREF(tmp_called_name_56);
            if (tmp_assign_source_22 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 473;

                goto try_except_handler_7;
            }
            assert(tmp_class_creation_3__prepared == NULL);
            tmp_class_creation_3__prepared = tmp_assign_source_22;
        }
        {
            nuitka_bool tmp_condition_result_63;
            PyObject *tmp_operand_name_3;
            PyObject *tmp_source_name_11;
            CHECK_OBJECT(tmp_class_creation_3__prepared);
            tmp_source_name_11 = tmp_class_creation_3__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_11, const_str_plain___getitem__);
            tmp_operand_name_3 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_3);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 473;

                goto try_except_handler_7;
            }
            tmp_condition_result_63 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_63 == NUITKA_BOOL_TRUE) {
                goto branch_yes_9;
            } else {
                goto branch_no_9;
            }
            branch_yes_9:;
            {
                PyObject *tmp_raise_type_3;
                PyObject *tmp_raise_value_3;
                PyObject *tmp_left_name_3;
                PyObject *tmp_right_name_3;
                PyObject *tmp_tuple_element_7;
                PyObject *tmp_getattr_target_3;
                PyObject *tmp_getattr_attr_3;
                PyObject *tmp_getattr_default_3;
                PyObject *tmp_source_name_12;
                PyObject *tmp_type_arg_4;
                tmp_raise_type_3 = PyExc_TypeError;
                tmp_left_name_3 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_3__metaclass);
                tmp_getattr_target_3 = tmp_class_creation_3__metaclass;
                tmp_getattr_attr_3 = const_str_plain___name__;
                tmp_getattr_default_3 = const_str_angle_metaclass;
                tmp_tuple_element_7 = BUILTIN_GETATTR(tmp_getattr_target_3, tmp_getattr_attr_3, tmp_getattr_default_3);
                if (tmp_tuple_element_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 473;

                    goto try_except_handler_7;
                }
                tmp_right_name_3 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_3, 0, tmp_tuple_element_7);
                CHECK_OBJECT(tmp_class_creation_3__prepared);
                tmp_type_arg_4 = tmp_class_creation_3__prepared;
                tmp_source_name_12 = BUILTIN_TYPE1(tmp_type_arg_4);
                assert(!(tmp_source_name_12 == NULL));
                tmp_tuple_element_7 = LOOKUP_ATTRIBUTE(tmp_source_name_12, const_str_plain___name__);
                Py_DECREF(tmp_source_name_12);
                if (tmp_tuple_element_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_3);

                    exception_lineno = 473;

                    goto try_except_handler_7;
                }
                PyTuple_SET_ITEM(tmp_right_name_3, 1, tmp_tuple_element_7);
                tmp_raise_value_3 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_3, tmp_right_name_3);
                Py_DECREF(tmp_right_name_3);
                if (tmp_raise_value_3 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 473;

                    goto try_except_handler_7;
                }
                exception_type = tmp_raise_type_3;
                Py_INCREF(tmp_raise_type_3);
                exception_value = tmp_raise_value_3;
                exception_lineno = 473;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_7;
            }
            branch_no_9:;
        }
        goto branch_end_8;
        branch_no_8:;
        {
            PyObject *tmp_assign_source_23;
            tmp_assign_source_23 = PyDict_New();
            assert(tmp_class_creation_3__prepared == NULL);
            tmp_class_creation_3__prepared = tmp_assign_source_23;
        }
        branch_end_8:;
    }
    {
        PyObject *tmp_assign_source_24;
        {
            PyObject *tmp_set_locals_3;
            CHECK_OBJECT(tmp_class_creation_3__prepared);
            tmp_set_locals_3 = tmp_class_creation_3__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473 = tmp_set_locals_3;
            Py_INCREF(tmp_set_locals_3);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;

            goto try_except_handler_9;
        }
        tmp_dictset_value = const_str_plain_ValueShapeBase;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 473;

            goto try_except_handler_9;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_a09999ee0b961cf0bc904e3250f3dd24_4, codeobj_a09999ee0b961cf0bc904e3250f3dd24, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_a09999ee0b961cf0bc904e3250f3dd24_4 = cache_frame_a09999ee0b961cf0bc904e3250f3dd24_4;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_a09999ee0b961cf0bc904e3250f3dd24_4);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_a09999ee0b961cf0bc904e3250f3dd24_4) == 2); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_empty;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473, const_str_plain___slots__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 474;
            type_description_2 = "o";
            goto frame_exception_exit_4;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_52_hasShapeSlotLen();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473, const_str_plain_hasShapeSlotLen, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 476;
            type_description_2 = "o";
            goto frame_exception_exit_4;
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_a09999ee0b961cf0bc904e3250f3dd24_4);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_3;

        frame_exception_exit_4:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_a09999ee0b961cf0bc904e3250f3dd24_4);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_a09999ee0b961cf0bc904e3250f3dd24_4, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_a09999ee0b961cf0bc904e3250f3dd24_4->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_a09999ee0b961cf0bc904e3250f3dd24_4, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_a09999ee0b961cf0bc904e3250f3dd24_4,
            type_description_2,
            outline_2_var___class__
        );


        // Release cached frame.
        if (frame_a09999ee0b961cf0bc904e3250f3dd24_4 == cache_frame_a09999ee0b961cf0bc904e3250f3dd24_4) {
            Py_DECREF(frame_a09999ee0b961cf0bc904e3250f3dd24_4);
        }
        cache_frame_a09999ee0b961cf0bc904e3250f3dd24_4 = NULL;

        assertFrameObject(frame_a09999ee0b961cf0bc904e3250f3dd24_4);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_3;

        frame_no_exception_3:;
        goto skip_nested_handling_3;
        nested_frame_exit_3:;

        goto try_except_handler_9;
        skip_nested_handling_3:;
        {
            PyObject *tmp_assign_source_25;
            PyObject *tmp_called_name_57;
            PyObject *tmp_args_name_6;
            PyObject *tmp_tuple_element_8;
            PyObject *tmp_kw_name_6;
            CHECK_OBJECT(tmp_class_creation_3__metaclass);
            tmp_called_name_57 = tmp_class_creation_3__metaclass;
            tmp_tuple_element_8 = const_str_plain_ValueShapeBase;
            tmp_args_name_6 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_8);
            PyTuple_SET_ITEM(tmp_args_name_6, 0, tmp_tuple_element_8);
            tmp_tuple_element_8 = const_tuple_type_object_tuple;
            Py_INCREF(tmp_tuple_element_8);
            PyTuple_SET_ITEM(tmp_args_name_6, 1, tmp_tuple_element_8);
            tmp_tuple_element_8 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473;
            Py_INCREF(tmp_tuple_element_8);
            PyTuple_SET_ITEM(tmp_args_name_6, 2, tmp_tuple_element_8);
            CHECK_OBJECT(tmp_class_creation_3__class_decl_dict);
            tmp_kw_name_6 = tmp_class_creation_3__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 473;
            tmp_assign_source_25 = CALL_FUNCTION(tmp_called_name_57, tmp_args_name_6, tmp_kw_name_6);
            Py_DECREF(tmp_args_name_6);
            if (tmp_assign_source_25 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 473;

                goto try_except_handler_9;
            }
            assert(outline_2_var___class__ == NULL);
            outline_2_var___class__ = tmp_assign_source_25;
        }
        CHECK_OBJECT(outline_2_var___class__);
        tmp_assign_source_24 = outline_2_var___class__;
        Py_INCREF(tmp_assign_source_24);
        goto try_return_handler_9;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_9:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473 = NULL;
        goto try_return_handler_8;
        // Exception handler code:
        try_except_handler_9:;
        exception_keeper_type_7 = exception_type;
        exception_keeper_value_7 = exception_value;
        exception_keeper_tb_7 = exception_tb;
        exception_keeper_lineno_7 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_473 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_7;
        exception_value = exception_keeper_value_7;
        exception_tb = exception_keeper_tb_7;
        exception_lineno = exception_keeper_lineno_7;

        goto try_except_handler_8;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_8:;
        CHECK_OBJECT((PyObject *)outline_2_var___class__);
        Py_DECREF(outline_2_var___class__);
        outline_2_var___class__ = NULL;

        goto outline_result_3;
        // Exception handler code:
        try_except_handler_8:;
        exception_keeper_type_8 = exception_type;
        exception_keeper_value_8 = exception_value;
        exception_keeper_tb_8 = exception_tb;
        exception_keeper_lineno_8 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_8;
        exception_value = exception_keeper_value_8;
        exception_tb = exception_keeper_tb_8;
        exception_lineno = exception_keeper_lineno_8;

        goto outline_exception_3;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_3:;
        exception_lineno = 473;
        goto try_except_handler_7;
        outline_result_3:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ValueShapeBase, tmp_assign_source_24);
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class_decl_dict);
    Py_DECREF(tmp_class_creation_3__class_decl_dict);
    tmp_class_creation_3__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_3__prepared);
    tmp_class_creation_3__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_3__class_decl_dict);
    Py_DECREF(tmp_class_creation_3__class_decl_dict);
    tmp_class_creation_3__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__metaclass);
    Py_DECREF(tmp_class_creation_3__metaclass);
    tmp_class_creation_3__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_3__prepared);
    Py_DECREF(tmp_class_creation_3__prepared);
    tmp_class_creation_3__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_26;
        PyObject *tmp_tuple_element_9;
        PyObject *tmp_mvar_value_4;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ValueShapeBase);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ValueShapeBase);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 86208 ], 36, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 480;

            goto try_except_handler_10;
        }

        tmp_tuple_element_9 = tmp_mvar_value_4;
        tmp_assign_source_26 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_9);
        PyTuple_SET_ITEM(tmp_assign_source_26, 0, tmp_tuple_element_9);
        assert(tmp_class_creation_4__bases == NULL);
        tmp_class_creation_4__bases = tmp_assign_source_26;
    }
    {
        PyObject *tmp_assign_source_27;
        tmp_assign_source_27 = PyDict_New();
        assert(tmp_class_creation_4__class_decl_dict == NULL);
        tmp_class_creation_4__class_decl_dict = tmp_assign_source_27;
    }
    {
        PyObject *tmp_assign_source_28;
        PyObject *tmp_metaclass_name_4;
        nuitka_bool tmp_condition_result_64;
        PyObject *tmp_key_name_10;
        PyObject *tmp_dict_name_10;
        PyObject *tmp_dict_name_11;
        PyObject *tmp_key_name_11;
        PyObject *tmp_type_arg_5;
        PyObject *tmp_subscribed_name_2;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_bases_name_4;
        tmp_key_name_10 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_4__class_decl_dict);
        tmp_dict_name_10 = tmp_class_creation_4__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_10, tmp_key_name_10);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_10;
        }
        tmp_condition_result_64 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_64 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_55;
        } else {
            goto condexpr_false_55;
        }
        condexpr_true_55:;
        CHECK_OBJECT(tmp_class_creation_4__class_decl_dict);
        tmp_dict_name_11 = tmp_class_creation_4__class_decl_dict;
        tmp_key_name_11 = const_str_plain_metaclass;
        tmp_metaclass_name_4 = DICT_GET_ITEM(tmp_dict_name_11, tmp_key_name_11);
        if (tmp_metaclass_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_10;
        }
        goto condexpr_end_55;
        condexpr_false_55:;
        CHECK_OBJECT(tmp_class_creation_4__bases);
        tmp_subscribed_name_2 = tmp_class_creation_4__bases;
        tmp_subscript_name_2 = const_int_0;
        tmp_type_arg_5 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_2, tmp_subscript_name_2, 0);
        if (tmp_type_arg_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_10;
        }
        tmp_metaclass_name_4 = BUILTIN_TYPE1(tmp_type_arg_5);
        Py_DECREF(tmp_type_arg_5);
        if (tmp_metaclass_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_10;
        }
        condexpr_end_55:;
        CHECK_OBJECT(tmp_class_creation_4__bases);
        tmp_bases_name_4 = tmp_class_creation_4__bases;
        tmp_assign_source_28 = SELECT_METACLASS(tmp_metaclass_name_4, tmp_bases_name_4);
        Py_DECREF(tmp_metaclass_name_4);
        if (tmp_assign_source_28 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_10;
        }
        assert(tmp_class_creation_4__metaclass == NULL);
        tmp_class_creation_4__metaclass = tmp_assign_source_28;
    }
    {
        nuitka_bool tmp_condition_result_65;
        PyObject *tmp_key_name_12;
        PyObject *tmp_dict_name_12;
        tmp_key_name_12 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_4__class_decl_dict);
        tmp_dict_name_12 = tmp_class_creation_4__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_12, tmp_key_name_12);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_10;
        }
        tmp_condition_result_65 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_65 == NUITKA_BOOL_TRUE) {
            goto branch_yes_10;
        } else {
            goto branch_no_10;
        }
        branch_yes_10:;
        CHECK_OBJECT(tmp_class_creation_4__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_4__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_10;
        }
        branch_no_10:;
    }
    {
        nuitka_bool tmp_condition_result_66;
        PyObject *tmp_source_name_13;
        CHECK_OBJECT(tmp_class_creation_4__metaclass);
        tmp_source_name_13 = tmp_class_creation_4__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_13, const_str_plain___prepare__);
        tmp_condition_result_66 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_66 == NUITKA_BOOL_TRUE) {
            goto branch_yes_11;
        } else {
            goto branch_no_11;
        }
        branch_yes_11:;
        {
            PyObject *tmp_assign_source_29;
            PyObject *tmp_called_name_58;
            PyObject *tmp_source_name_14;
            PyObject *tmp_args_name_7;
            PyObject *tmp_tuple_element_10;
            PyObject *tmp_kw_name_7;
            CHECK_OBJECT(tmp_class_creation_4__metaclass);
            tmp_source_name_14 = tmp_class_creation_4__metaclass;
            tmp_called_name_58 = LOOKUP_ATTRIBUTE(tmp_source_name_14, const_str_plain___prepare__);
            if (tmp_called_name_58 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 480;

                goto try_except_handler_10;
            }
            tmp_tuple_element_10 = const_str_plain_ValueShapeUnknown;
            tmp_args_name_7 = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_10);
            PyTuple_SET_ITEM(tmp_args_name_7, 0, tmp_tuple_element_10);
            CHECK_OBJECT(tmp_class_creation_4__bases);
            tmp_tuple_element_10 = tmp_class_creation_4__bases;
            Py_INCREF(tmp_tuple_element_10);
            PyTuple_SET_ITEM(tmp_args_name_7, 1, tmp_tuple_element_10);
            CHECK_OBJECT(tmp_class_creation_4__class_decl_dict);
            tmp_kw_name_7 = tmp_class_creation_4__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 480;
            tmp_assign_source_29 = CALL_FUNCTION(tmp_called_name_58, tmp_args_name_7, tmp_kw_name_7);
            Py_DECREF(tmp_called_name_58);
            Py_DECREF(tmp_args_name_7);
            if (tmp_assign_source_29 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 480;

                goto try_except_handler_10;
            }
            assert(tmp_class_creation_4__prepared == NULL);
            tmp_class_creation_4__prepared = tmp_assign_source_29;
        }
        {
            nuitka_bool tmp_condition_result_67;
            PyObject *tmp_operand_name_4;
            PyObject *tmp_source_name_15;
            CHECK_OBJECT(tmp_class_creation_4__prepared);
            tmp_source_name_15 = tmp_class_creation_4__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_15, const_str_plain___getitem__);
            tmp_operand_name_4 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_4);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 480;

                goto try_except_handler_10;
            }
            tmp_condition_result_67 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_67 == NUITKA_BOOL_TRUE) {
                goto branch_yes_12;
            } else {
                goto branch_no_12;
            }
            branch_yes_12:;
            {
                PyObject *tmp_raise_type_4;
                PyObject *tmp_raise_value_4;
                PyObject *tmp_left_name_4;
                PyObject *tmp_right_name_4;
                PyObject *tmp_tuple_element_11;
                PyObject *tmp_getattr_target_4;
                PyObject *tmp_getattr_attr_4;
                PyObject *tmp_getattr_default_4;
                PyObject *tmp_source_name_16;
                PyObject *tmp_type_arg_6;
                tmp_raise_type_4 = PyExc_TypeError;
                tmp_left_name_4 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_4__metaclass);
                tmp_getattr_target_4 = tmp_class_creation_4__metaclass;
                tmp_getattr_attr_4 = const_str_plain___name__;
                tmp_getattr_default_4 = const_str_angle_metaclass;
                tmp_tuple_element_11 = BUILTIN_GETATTR(tmp_getattr_target_4, tmp_getattr_attr_4, tmp_getattr_default_4);
                if (tmp_tuple_element_11 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 480;

                    goto try_except_handler_10;
                }
                tmp_right_name_4 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_4, 0, tmp_tuple_element_11);
                CHECK_OBJECT(tmp_class_creation_4__prepared);
                tmp_type_arg_6 = tmp_class_creation_4__prepared;
                tmp_source_name_16 = BUILTIN_TYPE1(tmp_type_arg_6);
                assert(!(tmp_source_name_16 == NULL));
                tmp_tuple_element_11 = LOOKUP_ATTRIBUTE(tmp_source_name_16, const_str_plain___name__);
                Py_DECREF(tmp_source_name_16);
                if (tmp_tuple_element_11 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_4);

                    exception_lineno = 480;

                    goto try_except_handler_10;
                }
                PyTuple_SET_ITEM(tmp_right_name_4, 1, tmp_tuple_element_11);
                tmp_raise_value_4 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_4, tmp_right_name_4);
                Py_DECREF(tmp_right_name_4);
                if (tmp_raise_value_4 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 480;

                    goto try_except_handler_10;
                }
                exception_type = tmp_raise_type_4;
                Py_INCREF(tmp_raise_type_4);
                exception_value = tmp_raise_value_4;
                exception_lineno = 480;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_10;
            }
            branch_no_12:;
        }
        goto branch_end_11;
        branch_no_11:;
        {
            PyObject *tmp_assign_source_30;
            tmp_assign_source_30 = PyDict_New();
            assert(tmp_class_creation_4__prepared == NULL);
            tmp_class_creation_4__prepared = tmp_assign_source_30;
        }
        branch_end_11:;
    }
    {
        PyObject *tmp_assign_source_31;
        {
            PyObject *tmp_set_locals_4;
            CHECK_OBJECT(tmp_class_creation_4__prepared);
            tmp_set_locals_4 = tmp_class_creation_4__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480 = tmp_set_locals_4;
            Py_INCREF(tmp_set_locals_4);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_12;
        }
        tmp_dictset_value = const_str_plain_ValueShapeUnknown;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 480;

            goto try_except_handler_12;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_5310b13332f11e9c5a2f13a4f54ec265_5, codeobj_5310b13332f11e9c5a2f13a4f54ec265, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_5310b13332f11e9c5a2f13a4f54ec265_5 = cache_frame_5310b13332f11e9c5a2f13a4f54ec265_5;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_5310b13332f11e9c5a2f13a4f54ec265_5);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_5310b13332f11e9c5a2f13a4f54ec265_5) == 2); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_empty;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480, const_str_plain___slots__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 481;
            type_description_2 = "o";
            goto frame_exception_exit_5;
        }
        {
            nuitka_bool tmp_condition_result_68;
            PyObject *tmp_called_name_59;
            PyObject *tmp_args_element_name_52;
            PyObject *tmp_staticmethod_arg_16;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 483;
                type_description_2 = "o";
                goto frame_exception_exit_5;
            }
            tmp_condition_result_68 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_68 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_56;
            } else {
                goto condexpr_false_56;
            }
            condexpr_true_56:;
            tmp_called_name_59 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480, const_str_plain_staticmethod);

            if (tmp_called_name_59 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 483;
                type_description_2 = "o";
                goto frame_exception_exit_5;
            }

            if (tmp_called_name_59 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 483;
                type_description_2 = "o";
                goto frame_exception_exit_5;
            }
            tmp_args_element_name_52 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape();



            frame_5310b13332f11e9c5a2f13a4f54ec265_5->m_frame.f_lineno = 483;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_59, tmp_args_element_name_52);
            Py_DECREF(tmp_called_name_59);
            Py_DECREF(tmp_args_element_name_52);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 483;
                type_description_2 = "o";
                goto frame_exception_exit_5;
            }
            goto condexpr_end_56;
            condexpr_false_56:;
            tmp_staticmethod_arg_16 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_53_getTypeShape();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_16);
            Py_DECREF(tmp_staticmethod_arg_16);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 483;
                type_description_2 = "o";
                goto frame_exception_exit_5;
            }
            condexpr_end_56:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480, const_str_plain_getTypeShape, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 483;
                type_description_2 = "o";
                goto frame_exception_exit_5;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_5310b13332f11e9c5a2f13a4f54ec265_5);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_4;

        frame_exception_exit_5:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_5310b13332f11e9c5a2f13a4f54ec265_5);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_5310b13332f11e9c5a2f13a4f54ec265_5, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_5310b13332f11e9c5a2f13a4f54ec265_5->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_5310b13332f11e9c5a2f13a4f54ec265_5, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_5310b13332f11e9c5a2f13a4f54ec265_5,
            type_description_2,
            outline_3_var___class__
        );


        // Release cached frame.
        if (frame_5310b13332f11e9c5a2f13a4f54ec265_5 == cache_frame_5310b13332f11e9c5a2f13a4f54ec265_5) {
            Py_DECREF(frame_5310b13332f11e9c5a2f13a4f54ec265_5);
        }
        cache_frame_5310b13332f11e9c5a2f13a4f54ec265_5 = NULL;

        assertFrameObject(frame_5310b13332f11e9c5a2f13a4f54ec265_5);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_4;

        frame_no_exception_4:;
        goto skip_nested_handling_4;
        nested_frame_exit_4:;

        goto try_except_handler_12;
        skip_nested_handling_4:;
        {
            PyObject *tmp_assign_source_32;
            PyObject *tmp_called_name_60;
            PyObject *tmp_args_name_8;
            PyObject *tmp_tuple_element_12;
            PyObject *tmp_kw_name_8;
            CHECK_OBJECT(tmp_class_creation_4__metaclass);
            tmp_called_name_60 = tmp_class_creation_4__metaclass;
            tmp_tuple_element_12 = const_str_plain_ValueShapeUnknown;
            tmp_args_name_8 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_12);
            PyTuple_SET_ITEM(tmp_args_name_8, 0, tmp_tuple_element_12);
            CHECK_OBJECT(tmp_class_creation_4__bases);
            tmp_tuple_element_12 = tmp_class_creation_4__bases;
            Py_INCREF(tmp_tuple_element_12);
            PyTuple_SET_ITEM(tmp_args_name_8, 1, tmp_tuple_element_12);
            tmp_tuple_element_12 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480;
            Py_INCREF(tmp_tuple_element_12);
            PyTuple_SET_ITEM(tmp_args_name_8, 2, tmp_tuple_element_12);
            CHECK_OBJECT(tmp_class_creation_4__class_decl_dict);
            tmp_kw_name_8 = tmp_class_creation_4__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 480;
            tmp_assign_source_32 = CALL_FUNCTION(tmp_called_name_60, tmp_args_name_8, tmp_kw_name_8);
            Py_DECREF(tmp_args_name_8);
            if (tmp_assign_source_32 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 480;

                goto try_except_handler_12;
            }
            assert(outline_3_var___class__ == NULL);
            outline_3_var___class__ = tmp_assign_source_32;
        }
        CHECK_OBJECT(outline_3_var___class__);
        tmp_assign_source_31 = outline_3_var___class__;
        Py_INCREF(tmp_assign_source_31);
        goto try_return_handler_12;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_12:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480 = NULL;
        goto try_return_handler_11;
        // Exception handler code:
        try_except_handler_12:;
        exception_keeper_type_10 = exception_type;
        exception_keeper_value_10 = exception_value;
        exception_keeper_tb_10 = exception_tb;
        exception_keeper_lineno_10 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_480 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_10;
        exception_value = exception_keeper_value_10;
        exception_tb = exception_keeper_tb_10;
        exception_lineno = exception_keeper_lineno_10;

        goto try_except_handler_11;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_11:;
        CHECK_OBJECT((PyObject *)outline_3_var___class__);
        Py_DECREF(outline_3_var___class__);
        outline_3_var___class__ = NULL;

        goto outline_result_4;
        // Exception handler code:
        try_except_handler_11:;
        exception_keeper_type_11 = exception_type;
        exception_keeper_value_11 = exception_value;
        exception_keeper_tb_11 = exception_tb;
        exception_keeper_lineno_11 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_11;
        exception_value = exception_keeper_value_11;
        exception_tb = exception_keeper_tb_11;
        exception_lineno = exception_keeper_lineno_11;

        goto outline_exception_4;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_4:;
        exception_lineno = 480;
        goto try_except_handler_10;
        outline_result_4:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ValueShapeUnknown, tmp_assign_source_31);
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_10:;
    exception_keeper_type_12 = exception_type;
    exception_keeper_value_12 = exception_value;
    exception_keeper_tb_12 = exception_tb;
    exception_keeper_lineno_12 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_4__bases);
    tmp_class_creation_4__bases = NULL;

    Py_XDECREF(tmp_class_creation_4__class_decl_dict);
    tmp_class_creation_4__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_4__prepared);
    tmp_class_creation_4__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_12;
    exception_value = exception_keeper_value_12;
    exception_tb = exception_keeper_tb_12;
    exception_lineno = exception_keeper_lineno_12;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_4__bases);
    Py_DECREF(tmp_class_creation_4__bases);
    tmp_class_creation_4__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__class_decl_dict);
    Py_DECREF(tmp_class_creation_4__class_decl_dict);
    tmp_class_creation_4__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__metaclass);
    Py_DECREF(tmp_class_creation_4__metaclass);
    tmp_class_creation_4__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_4__prepared);
    Py_DECREF(tmp_class_creation_4__prepared);
    tmp_class_creation_4__prepared = NULL;

    {
        PyObject *tmp_assign_source_33;
        PyObject *tmp_called_name_61;
        PyObject *tmp_mvar_value_5;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ValueShapeUnknown);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ValueShapeUnknown);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 86244 ], 39, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 489;

            goto frame_exception_exit_1;
        }

        tmp_called_name_61 = tmp_mvar_value_5;
        frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 489;
        tmp_assign_source_33 = CALL_FUNCTION_NO_ARGS(tmp_called_name_61);
        if (tmp_assign_source_33 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 489;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_vshape_unknown, tmp_assign_source_33);
    }
    {
        PyObject *tmp_assign_source_34;
        tmp_assign_source_34 = PyDict_New();
        assert(tmp_class_creation_5__class_decl_dict == NULL);
        tmp_class_creation_5__class_decl_dict = tmp_assign_source_34;
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_35;
        PyObject *tmp_metaclass_name_5;
        nuitka_bool tmp_condition_result_69;
        PyObject *tmp_key_name_13;
        PyObject *tmp_dict_name_13;
        PyObject *tmp_dict_name_14;
        PyObject *tmp_key_name_14;
        PyObject *tmp_bases_name_5;
        tmp_key_name_13 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_5__class_decl_dict);
        tmp_dict_name_13 = tmp_class_creation_5__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_13, tmp_key_name_13);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 492;

            goto try_except_handler_13;
        }
        tmp_condition_result_69 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_69 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_57;
        } else {
            goto condexpr_false_57;
        }
        condexpr_true_57:;
        CHECK_OBJECT(tmp_class_creation_5__class_decl_dict);
        tmp_dict_name_14 = tmp_class_creation_5__class_decl_dict;
        tmp_key_name_14 = const_str_plain_metaclass;
        tmp_metaclass_name_5 = DICT_GET_ITEM(tmp_dict_name_14, tmp_key_name_14);
        if (tmp_metaclass_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 492;

            goto try_except_handler_13;
        }
        goto condexpr_end_57;
        condexpr_false_57:;
        tmp_metaclass_name_5 = LOOKUP_BUILTIN(const_str_plain_type);
        assert(tmp_metaclass_name_5 != NULL);
        Py_INCREF(tmp_metaclass_name_5);
        condexpr_end_57:;
        tmp_bases_name_5 = const_tuple_type_object_tuple;
        tmp_assign_source_35 = SELECT_METACLASS(tmp_metaclass_name_5, tmp_bases_name_5);
        Py_DECREF(tmp_metaclass_name_5);
        if (tmp_assign_source_35 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 492;

            goto try_except_handler_13;
        }
        assert(tmp_class_creation_5__metaclass == NULL);
        tmp_class_creation_5__metaclass = tmp_assign_source_35;
    }
    {
        nuitka_bool tmp_condition_result_70;
        PyObject *tmp_key_name_15;
        PyObject *tmp_dict_name_15;
        tmp_key_name_15 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_5__class_decl_dict);
        tmp_dict_name_15 = tmp_class_creation_5__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_15, tmp_key_name_15);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 492;

            goto try_except_handler_13;
        }
        tmp_condition_result_70 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_70 == NUITKA_BOOL_TRUE) {
            goto branch_yes_13;
        } else {
            goto branch_no_13;
        }
        branch_yes_13:;
        CHECK_OBJECT(tmp_class_creation_5__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_5__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 492;

            goto try_except_handler_13;
        }
        branch_no_13:;
    }
    {
        nuitka_bool tmp_condition_result_71;
        PyObject *tmp_source_name_17;
        CHECK_OBJECT(tmp_class_creation_5__metaclass);
        tmp_source_name_17 = tmp_class_creation_5__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_17, const_str_plain___prepare__);
        tmp_condition_result_71 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_71 == NUITKA_BOOL_TRUE) {
            goto branch_yes_14;
        } else {
            goto branch_no_14;
        }
        branch_yes_14:;
        {
            PyObject *tmp_assign_source_36;
            PyObject *tmp_called_name_62;
            PyObject *tmp_source_name_18;
            PyObject *tmp_args_name_9;
            PyObject *tmp_kw_name_9;
            CHECK_OBJECT(tmp_class_creation_5__metaclass);
            tmp_source_name_18 = tmp_class_creation_5__metaclass;
            tmp_called_name_62 = LOOKUP_ATTRIBUTE(tmp_source_name_18, const_str_plain___prepare__);
            if (tmp_called_name_62 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 492;

                goto try_except_handler_13;
            }
            tmp_args_name_9 = const_tuple_str_plain_ShapeLargeConstantValue_tuple_type_object_tuple_tuple;
            CHECK_OBJECT(tmp_class_creation_5__class_decl_dict);
            tmp_kw_name_9 = tmp_class_creation_5__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 492;
            tmp_assign_source_36 = CALL_FUNCTION(tmp_called_name_62, tmp_args_name_9, tmp_kw_name_9);
            Py_DECREF(tmp_called_name_62);
            if (tmp_assign_source_36 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 492;

                goto try_except_handler_13;
            }
            assert(tmp_class_creation_5__prepared == NULL);
            tmp_class_creation_5__prepared = tmp_assign_source_36;
        }
        {
            nuitka_bool tmp_condition_result_72;
            PyObject *tmp_operand_name_5;
            PyObject *tmp_source_name_19;
            CHECK_OBJECT(tmp_class_creation_5__prepared);
            tmp_source_name_19 = tmp_class_creation_5__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_19, const_str_plain___getitem__);
            tmp_operand_name_5 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_5);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 492;

                goto try_except_handler_13;
            }
            tmp_condition_result_72 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_72 == NUITKA_BOOL_TRUE) {
                goto branch_yes_15;
            } else {
                goto branch_no_15;
            }
            branch_yes_15:;
            {
                PyObject *tmp_raise_type_5;
                PyObject *tmp_raise_value_5;
                PyObject *tmp_left_name_5;
                PyObject *tmp_right_name_5;
                PyObject *tmp_tuple_element_13;
                PyObject *tmp_getattr_target_5;
                PyObject *tmp_getattr_attr_5;
                PyObject *tmp_getattr_default_5;
                PyObject *tmp_source_name_20;
                PyObject *tmp_type_arg_7;
                tmp_raise_type_5 = PyExc_TypeError;
                tmp_left_name_5 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_5__metaclass);
                tmp_getattr_target_5 = tmp_class_creation_5__metaclass;
                tmp_getattr_attr_5 = const_str_plain___name__;
                tmp_getattr_default_5 = const_str_angle_metaclass;
                tmp_tuple_element_13 = BUILTIN_GETATTR(tmp_getattr_target_5, tmp_getattr_attr_5, tmp_getattr_default_5);
                if (tmp_tuple_element_13 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 492;

                    goto try_except_handler_13;
                }
                tmp_right_name_5 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_5, 0, tmp_tuple_element_13);
                CHECK_OBJECT(tmp_class_creation_5__prepared);
                tmp_type_arg_7 = tmp_class_creation_5__prepared;
                tmp_source_name_20 = BUILTIN_TYPE1(tmp_type_arg_7);
                assert(!(tmp_source_name_20 == NULL));
                tmp_tuple_element_13 = LOOKUP_ATTRIBUTE(tmp_source_name_20, const_str_plain___name__);
                Py_DECREF(tmp_source_name_20);
                if (tmp_tuple_element_13 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_5);

                    exception_lineno = 492;

                    goto try_except_handler_13;
                }
                PyTuple_SET_ITEM(tmp_right_name_5, 1, tmp_tuple_element_13);
                tmp_raise_value_5 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_5, tmp_right_name_5);
                Py_DECREF(tmp_right_name_5);
                if (tmp_raise_value_5 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 492;

                    goto try_except_handler_13;
                }
                exception_type = tmp_raise_type_5;
                Py_INCREF(tmp_raise_type_5);
                exception_value = tmp_raise_value_5;
                exception_lineno = 492;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_13;
            }
            branch_no_15:;
        }
        goto branch_end_14;
        branch_no_14:;
        {
            PyObject *tmp_assign_source_37;
            tmp_assign_source_37 = PyDict_New();
            assert(tmp_class_creation_5__prepared == NULL);
            tmp_class_creation_5__prepared = tmp_assign_source_37;
        }
        branch_end_14:;
    }
    {
        PyObject *tmp_assign_source_38;
        {
            PyObject *tmp_set_locals_5;
            CHECK_OBJECT(tmp_class_creation_5__prepared);
            tmp_set_locals_5 = tmp_class_creation_5__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492 = tmp_set_locals_5;
            Py_INCREF(tmp_set_locals_5);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 492;

            goto try_except_handler_15;
        }
        tmp_dictset_value = const_str_plain_ShapeLargeConstantValue;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 492;

            goto try_except_handler_15;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_314cddf2026135a2b36d24db96264100_6, codeobj_314cddf2026135a2b36d24db96264100, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_314cddf2026135a2b36d24db96264100_6 = cache_frame_314cddf2026135a2b36d24db96264100_6;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_314cddf2026135a2b36d24db96264100_6);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_314cddf2026135a2b36d24db96264100_6) == 2); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_str_plain_shape_str_plain_size_tuple;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain___slots__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 493;
            type_description_2 = "o";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_54___init__();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 495;
            type_description_2 = "o";
            goto frame_exception_exit_6;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_55_getTypeShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain_getTypeShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 499;
            type_description_2 = "o";
            goto frame_exception_exit_6;
        }
        {
            nuitka_bool tmp_condition_result_73;
            PyObject *tmp_called_name_63;
            PyObject *tmp_args_element_name_53;
            PyObject *tmp_staticmethod_arg_17;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 502;
                type_description_2 = "o";
                goto frame_exception_exit_6;
            }
            tmp_condition_result_73 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_73 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_58;
            } else {
                goto condexpr_false_58;
            }
            condexpr_true_58:;
            tmp_called_name_63 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain_staticmethod);

            if (tmp_called_name_63 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 502;
                type_description_2 = "o";
                goto frame_exception_exit_6;
            }

            if (tmp_called_name_63 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 502;
                type_description_2 = "o";
                goto frame_exception_exit_6;
            }
            tmp_args_element_name_53 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant();



            frame_314cddf2026135a2b36d24db96264100_6->m_frame.f_lineno = 502;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_63, tmp_args_element_name_53);
            Py_DECREF(tmp_called_name_63);
            Py_DECREF(tmp_args_element_name_53);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 502;
                type_description_2 = "o";
                goto frame_exception_exit_6;
            }
            goto condexpr_end_58;
            condexpr_false_58:;
            tmp_staticmethod_arg_17 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_56_isConstant();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_17);
            Py_DECREF(tmp_staticmethod_arg_17);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 502;
                type_description_2 = "o";
                goto frame_exception_exit_6;
            }
            condexpr_end_58:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain_isConstant, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 502;
                type_description_2 = "o";
                goto frame_exception_exit_6;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_57_hasShapeSlotLen();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492, const_str_plain_hasShapeSlotLen, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 506;
            type_description_2 = "o";
            goto frame_exception_exit_6;
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_314cddf2026135a2b36d24db96264100_6);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_5;

        frame_exception_exit_6:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_314cddf2026135a2b36d24db96264100_6);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_314cddf2026135a2b36d24db96264100_6, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_314cddf2026135a2b36d24db96264100_6->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_314cddf2026135a2b36d24db96264100_6, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_314cddf2026135a2b36d24db96264100_6,
            type_description_2,
            outline_4_var___class__
        );


        // Release cached frame.
        if (frame_314cddf2026135a2b36d24db96264100_6 == cache_frame_314cddf2026135a2b36d24db96264100_6) {
            Py_DECREF(frame_314cddf2026135a2b36d24db96264100_6);
        }
        cache_frame_314cddf2026135a2b36d24db96264100_6 = NULL;

        assertFrameObject(frame_314cddf2026135a2b36d24db96264100_6);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_5;

        frame_no_exception_5:;
        goto skip_nested_handling_5;
        nested_frame_exit_5:;

        goto try_except_handler_15;
        skip_nested_handling_5:;
        {
            PyObject *tmp_assign_source_39;
            PyObject *tmp_called_name_64;
            PyObject *tmp_args_name_10;
            PyObject *tmp_tuple_element_14;
            PyObject *tmp_kw_name_10;
            CHECK_OBJECT(tmp_class_creation_5__metaclass);
            tmp_called_name_64 = tmp_class_creation_5__metaclass;
            tmp_tuple_element_14 = const_str_plain_ShapeLargeConstantValue;
            tmp_args_name_10 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_14);
            PyTuple_SET_ITEM(tmp_args_name_10, 0, tmp_tuple_element_14);
            tmp_tuple_element_14 = const_tuple_type_object_tuple;
            Py_INCREF(tmp_tuple_element_14);
            PyTuple_SET_ITEM(tmp_args_name_10, 1, tmp_tuple_element_14);
            tmp_tuple_element_14 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492;
            Py_INCREF(tmp_tuple_element_14);
            PyTuple_SET_ITEM(tmp_args_name_10, 2, tmp_tuple_element_14);
            CHECK_OBJECT(tmp_class_creation_5__class_decl_dict);
            tmp_kw_name_10 = tmp_class_creation_5__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 492;
            tmp_assign_source_39 = CALL_FUNCTION(tmp_called_name_64, tmp_args_name_10, tmp_kw_name_10);
            Py_DECREF(tmp_args_name_10);
            if (tmp_assign_source_39 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 492;

                goto try_except_handler_15;
            }
            assert(outline_4_var___class__ == NULL);
            outline_4_var___class__ = tmp_assign_source_39;
        }
        CHECK_OBJECT(outline_4_var___class__);
        tmp_assign_source_38 = outline_4_var___class__;
        Py_INCREF(tmp_assign_source_38);
        goto try_return_handler_15;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_15:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492 = NULL;
        goto try_return_handler_14;
        // Exception handler code:
        try_except_handler_15:;
        exception_keeper_type_13 = exception_type;
        exception_keeper_value_13 = exception_value;
        exception_keeper_tb_13 = exception_tb;
        exception_keeper_lineno_13 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_492 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_13;
        exception_value = exception_keeper_value_13;
        exception_tb = exception_keeper_tb_13;
        exception_lineno = exception_keeper_lineno_13;

        goto try_except_handler_14;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_14:;
        CHECK_OBJECT((PyObject *)outline_4_var___class__);
        Py_DECREF(outline_4_var___class__);
        outline_4_var___class__ = NULL;

        goto outline_result_5;
        // Exception handler code:
        try_except_handler_14:;
        exception_keeper_type_14 = exception_type;
        exception_keeper_value_14 = exception_value;
        exception_keeper_tb_14 = exception_tb;
        exception_keeper_lineno_14 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_14;
        exception_value = exception_keeper_value_14;
        exception_tb = exception_keeper_tb_14;
        exception_lineno = exception_keeper_lineno_14;

        goto outline_exception_5;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_5:;
        exception_lineno = 492;
        goto try_except_handler_13;
        outline_result_5:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLargeConstantValue, tmp_assign_source_38);
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_13:;
    exception_keeper_type_15 = exception_type;
    exception_keeper_value_15 = exception_value;
    exception_keeper_tb_15 = exception_tb;
    exception_keeper_lineno_15 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class_decl_dict);
    Py_DECREF(tmp_class_creation_5__class_decl_dict);
    tmp_class_creation_5__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_5__prepared);
    tmp_class_creation_5__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_15;
    exception_value = exception_keeper_value_15;
    exception_tb = exception_keeper_tb_15;
    exception_lineno = exception_keeper_lineno_15;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_5__class_decl_dict);
    Py_DECREF(tmp_class_creation_5__class_decl_dict);
    tmp_class_creation_5__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__metaclass);
    Py_DECREF(tmp_class_creation_5__metaclass);
    tmp_class_creation_5__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_5__prepared);
    Py_DECREF(tmp_class_creation_5__prepared);
    tmp_class_creation_5__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_40;
        PyObject *tmp_tuple_element_15;
        PyObject *tmp_mvar_value_6;
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLargeConstantValue);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeLargeConstantValue);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 76415 ], 45, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 510;

            goto try_except_handler_16;
        }

        tmp_tuple_element_15 = tmp_mvar_value_6;
        tmp_assign_source_40 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_15);
        PyTuple_SET_ITEM(tmp_assign_source_40, 0, tmp_tuple_element_15);
        assert(tmp_class_creation_6__bases == NULL);
        tmp_class_creation_6__bases = tmp_assign_source_40;
    }
    {
        PyObject *tmp_assign_source_41;
        tmp_assign_source_41 = PyDict_New();
        assert(tmp_class_creation_6__class_decl_dict == NULL);
        tmp_class_creation_6__class_decl_dict = tmp_assign_source_41;
    }
    {
        PyObject *tmp_assign_source_42;
        PyObject *tmp_metaclass_name_6;
        nuitka_bool tmp_condition_result_74;
        PyObject *tmp_key_name_16;
        PyObject *tmp_dict_name_16;
        PyObject *tmp_dict_name_17;
        PyObject *tmp_key_name_17;
        PyObject *tmp_type_arg_8;
        PyObject *tmp_subscribed_name_3;
        PyObject *tmp_subscript_name_3;
        PyObject *tmp_bases_name_6;
        tmp_key_name_16 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_6__class_decl_dict);
        tmp_dict_name_16 = tmp_class_creation_6__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_16, tmp_key_name_16);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_16;
        }
        tmp_condition_result_74 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_74 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_59;
        } else {
            goto condexpr_false_59;
        }
        condexpr_true_59:;
        CHECK_OBJECT(tmp_class_creation_6__class_decl_dict);
        tmp_dict_name_17 = tmp_class_creation_6__class_decl_dict;
        tmp_key_name_17 = const_str_plain_metaclass;
        tmp_metaclass_name_6 = DICT_GET_ITEM(tmp_dict_name_17, tmp_key_name_17);
        if (tmp_metaclass_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_16;
        }
        goto condexpr_end_59;
        condexpr_false_59:;
        CHECK_OBJECT(tmp_class_creation_6__bases);
        tmp_subscribed_name_3 = tmp_class_creation_6__bases;
        tmp_subscript_name_3 = const_int_0;
        tmp_type_arg_8 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_3, tmp_subscript_name_3, 0);
        if (tmp_type_arg_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_16;
        }
        tmp_metaclass_name_6 = BUILTIN_TYPE1(tmp_type_arg_8);
        Py_DECREF(tmp_type_arg_8);
        if (tmp_metaclass_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_16;
        }
        condexpr_end_59:;
        CHECK_OBJECT(tmp_class_creation_6__bases);
        tmp_bases_name_6 = tmp_class_creation_6__bases;
        tmp_assign_source_42 = SELECT_METACLASS(tmp_metaclass_name_6, tmp_bases_name_6);
        Py_DECREF(tmp_metaclass_name_6);
        if (tmp_assign_source_42 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_16;
        }
        assert(tmp_class_creation_6__metaclass == NULL);
        tmp_class_creation_6__metaclass = tmp_assign_source_42;
    }
    {
        nuitka_bool tmp_condition_result_75;
        PyObject *tmp_key_name_18;
        PyObject *tmp_dict_name_18;
        tmp_key_name_18 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_6__class_decl_dict);
        tmp_dict_name_18 = tmp_class_creation_6__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_18, tmp_key_name_18);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_16;
        }
        tmp_condition_result_75 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_75 == NUITKA_BOOL_TRUE) {
            goto branch_yes_16;
        } else {
            goto branch_no_16;
        }
        branch_yes_16:;
        CHECK_OBJECT(tmp_class_creation_6__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_6__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_16;
        }
        branch_no_16:;
    }
    {
        nuitka_bool tmp_condition_result_76;
        PyObject *tmp_source_name_21;
        CHECK_OBJECT(tmp_class_creation_6__metaclass);
        tmp_source_name_21 = tmp_class_creation_6__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_21, const_str_plain___prepare__);
        tmp_condition_result_76 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_76 == NUITKA_BOOL_TRUE) {
            goto branch_yes_17;
        } else {
            goto branch_no_17;
        }
        branch_yes_17:;
        {
            PyObject *tmp_assign_source_43;
            PyObject *tmp_called_name_65;
            PyObject *tmp_source_name_22;
            PyObject *tmp_args_name_11;
            PyObject *tmp_tuple_element_16;
            PyObject *tmp_kw_name_11;
            CHECK_OBJECT(tmp_class_creation_6__metaclass);
            tmp_source_name_22 = tmp_class_creation_6__metaclass;
            tmp_called_name_65 = LOOKUP_ATTRIBUTE(tmp_source_name_22, const_str_plain___prepare__);
            if (tmp_called_name_65 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 510;

                goto try_except_handler_16;
            }
            tmp_tuple_element_16 = const_str_plain_ShapeLargeConstantValuePredictable;
            tmp_args_name_11 = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_16);
            PyTuple_SET_ITEM(tmp_args_name_11, 0, tmp_tuple_element_16);
            CHECK_OBJECT(tmp_class_creation_6__bases);
            tmp_tuple_element_16 = tmp_class_creation_6__bases;
            Py_INCREF(tmp_tuple_element_16);
            PyTuple_SET_ITEM(tmp_args_name_11, 1, tmp_tuple_element_16);
            CHECK_OBJECT(tmp_class_creation_6__class_decl_dict);
            tmp_kw_name_11 = tmp_class_creation_6__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 510;
            tmp_assign_source_43 = CALL_FUNCTION(tmp_called_name_65, tmp_args_name_11, tmp_kw_name_11);
            Py_DECREF(tmp_called_name_65);
            Py_DECREF(tmp_args_name_11);
            if (tmp_assign_source_43 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 510;

                goto try_except_handler_16;
            }
            assert(tmp_class_creation_6__prepared == NULL);
            tmp_class_creation_6__prepared = tmp_assign_source_43;
        }
        {
            nuitka_bool tmp_condition_result_77;
            PyObject *tmp_operand_name_6;
            PyObject *tmp_source_name_23;
            CHECK_OBJECT(tmp_class_creation_6__prepared);
            tmp_source_name_23 = tmp_class_creation_6__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_23, const_str_plain___getitem__);
            tmp_operand_name_6 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_6);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 510;

                goto try_except_handler_16;
            }
            tmp_condition_result_77 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_77 == NUITKA_BOOL_TRUE) {
                goto branch_yes_18;
            } else {
                goto branch_no_18;
            }
            branch_yes_18:;
            {
                PyObject *tmp_raise_type_6;
                PyObject *tmp_raise_value_6;
                PyObject *tmp_left_name_6;
                PyObject *tmp_right_name_6;
                PyObject *tmp_tuple_element_17;
                PyObject *tmp_getattr_target_6;
                PyObject *tmp_getattr_attr_6;
                PyObject *tmp_getattr_default_6;
                PyObject *tmp_source_name_24;
                PyObject *tmp_type_arg_9;
                tmp_raise_type_6 = PyExc_TypeError;
                tmp_left_name_6 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_6__metaclass);
                tmp_getattr_target_6 = tmp_class_creation_6__metaclass;
                tmp_getattr_attr_6 = const_str_plain___name__;
                tmp_getattr_default_6 = const_str_angle_metaclass;
                tmp_tuple_element_17 = BUILTIN_GETATTR(tmp_getattr_target_6, tmp_getattr_attr_6, tmp_getattr_default_6);
                if (tmp_tuple_element_17 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 510;

                    goto try_except_handler_16;
                }
                tmp_right_name_6 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_6, 0, tmp_tuple_element_17);
                CHECK_OBJECT(tmp_class_creation_6__prepared);
                tmp_type_arg_9 = tmp_class_creation_6__prepared;
                tmp_source_name_24 = BUILTIN_TYPE1(tmp_type_arg_9);
                assert(!(tmp_source_name_24 == NULL));
                tmp_tuple_element_17 = LOOKUP_ATTRIBUTE(tmp_source_name_24, const_str_plain___name__);
                Py_DECREF(tmp_source_name_24);
                if (tmp_tuple_element_17 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_6);

                    exception_lineno = 510;

                    goto try_except_handler_16;
                }
                PyTuple_SET_ITEM(tmp_right_name_6, 1, tmp_tuple_element_17);
                tmp_raise_value_6 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_6, tmp_right_name_6);
                Py_DECREF(tmp_right_name_6);
                if (tmp_raise_value_6 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 510;

                    goto try_except_handler_16;
                }
                exception_type = tmp_raise_type_6;
                Py_INCREF(tmp_raise_type_6);
                exception_value = tmp_raise_value_6;
                exception_lineno = 510;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_16;
            }
            branch_no_18:;
        }
        goto branch_end_17;
        branch_no_17:;
        {
            PyObject *tmp_assign_source_44;
            tmp_assign_source_44 = PyDict_New();
            assert(tmp_class_creation_6__prepared == NULL);
            tmp_class_creation_6__prepared = tmp_assign_source_44;
        }
        branch_end_17:;
    }
    {
        PyObject *tmp_assign_source_45;
        {
            PyObject *tmp_set_locals_6;
            CHECK_OBJECT(tmp_class_creation_6__prepared);
            tmp_set_locals_6 = tmp_class_creation_6__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510 = tmp_set_locals_6;
            Py_INCREF(tmp_set_locals_6);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_18;
        }
        tmp_dictset_value = const_str_plain_ShapeLargeConstantValuePredictable;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 510;

            goto try_except_handler_18;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_b49158edaeabda446bf086b2eb083353_7, codeobj_b49158edaeabda446bf086b2eb083353, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_b49158edaeabda446bf086b2eb083353_7 = cache_frame_b49158edaeabda446bf086b2eb083353_7;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_b49158edaeabda446bf086b2eb083353_7);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_b49158edaeabda446bf086b2eb083353_7) == 2); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_str_plain_predictor_tuple;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510, const_str_plain___slots__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 511;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_58___init__();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 513;
            type_description_2 = "o";
            goto frame_exception_exit_7;
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b49158edaeabda446bf086b2eb083353_7);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_6;

        frame_exception_exit_7:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b49158edaeabda446bf086b2eb083353_7);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_b49158edaeabda446bf086b2eb083353_7, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_b49158edaeabda446bf086b2eb083353_7->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_b49158edaeabda446bf086b2eb083353_7, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_b49158edaeabda446bf086b2eb083353_7,
            type_description_2,
            outline_5_var___class__
        );


        // Release cached frame.
        if (frame_b49158edaeabda446bf086b2eb083353_7 == cache_frame_b49158edaeabda446bf086b2eb083353_7) {
            Py_DECREF(frame_b49158edaeabda446bf086b2eb083353_7);
        }
        cache_frame_b49158edaeabda446bf086b2eb083353_7 = NULL;

        assertFrameObject(frame_b49158edaeabda446bf086b2eb083353_7);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_6;

        frame_no_exception_6:;
        goto skip_nested_handling_6;
        nested_frame_exit_6:;

        goto try_except_handler_18;
        skip_nested_handling_6:;
        {
            PyObject *tmp_assign_source_46;
            PyObject *tmp_called_name_66;
            PyObject *tmp_args_name_12;
            PyObject *tmp_tuple_element_18;
            PyObject *tmp_kw_name_12;
            CHECK_OBJECT(tmp_class_creation_6__metaclass);
            tmp_called_name_66 = tmp_class_creation_6__metaclass;
            tmp_tuple_element_18 = const_str_plain_ShapeLargeConstantValuePredictable;
            tmp_args_name_12 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_18);
            PyTuple_SET_ITEM(tmp_args_name_12, 0, tmp_tuple_element_18);
            CHECK_OBJECT(tmp_class_creation_6__bases);
            tmp_tuple_element_18 = tmp_class_creation_6__bases;
            Py_INCREF(tmp_tuple_element_18);
            PyTuple_SET_ITEM(tmp_args_name_12, 1, tmp_tuple_element_18);
            tmp_tuple_element_18 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510;
            Py_INCREF(tmp_tuple_element_18);
            PyTuple_SET_ITEM(tmp_args_name_12, 2, tmp_tuple_element_18);
            CHECK_OBJECT(tmp_class_creation_6__class_decl_dict);
            tmp_kw_name_12 = tmp_class_creation_6__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 510;
            tmp_assign_source_46 = CALL_FUNCTION(tmp_called_name_66, tmp_args_name_12, tmp_kw_name_12);
            Py_DECREF(tmp_args_name_12);
            if (tmp_assign_source_46 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 510;

                goto try_except_handler_18;
            }
            assert(outline_5_var___class__ == NULL);
            outline_5_var___class__ = tmp_assign_source_46;
        }
        CHECK_OBJECT(outline_5_var___class__);
        tmp_assign_source_45 = outline_5_var___class__;
        Py_INCREF(tmp_assign_source_45);
        goto try_return_handler_18;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_18:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510 = NULL;
        goto try_return_handler_17;
        // Exception handler code:
        try_except_handler_18:;
        exception_keeper_type_16 = exception_type;
        exception_keeper_value_16 = exception_value;
        exception_keeper_tb_16 = exception_tb;
        exception_keeper_lineno_16 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_510 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_16;
        exception_value = exception_keeper_value_16;
        exception_tb = exception_keeper_tb_16;
        exception_lineno = exception_keeper_lineno_16;

        goto try_except_handler_17;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_17:;
        CHECK_OBJECT((PyObject *)outline_5_var___class__);
        Py_DECREF(outline_5_var___class__);
        outline_5_var___class__ = NULL;

        goto outline_result_6;
        // Exception handler code:
        try_except_handler_17:;
        exception_keeper_type_17 = exception_type;
        exception_keeper_value_17 = exception_value;
        exception_keeper_tb_17 = exception_tb;
        exception_keeper_lineno_17 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_17;
        exception_value = exception_keeper_value_17;
        exception_tb = exception_keeper_tb_17;
        exception_lineno = exception_keeper_lineno_17;

        goto outline_exception_6;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_6:;
        exception_lineno = 510;
        goto try_except_handler_16;
        outline_result_6:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLargeConstantValuePredictable, tmp_assign_source_45);
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_16:;
    exception_keeper_type_18 = exception_type;
    exception_keeper_value_18 = exception_value;
    exception_keeper_tb_18 = exception_tb;
    exception_keeper_lineno_18 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_6__bases);
    tmp_class_creation_6__bases = NULL;

    Py_XDECREF(tmp_class_creation_6__class_decl_dict);
    tmp_class_creation_6__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_6__prepared);
    tmp_class_creation_6__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_18;
    exception_value = exception_keeper_value_18;
    exception_tb = exception_keeper_tb_18;
    exception_lineno = exception_keeper_lineno_18;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_6__bases);
    Py_DECREF(tmp_class_creation_6__bases);
    tmp_class_creation_6__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__class_decl_dict);
    Py_DECREF(tmp_class_creation_6__class_decl_dict);
    tmp_class_creation_6__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__metaclass);
    Py_DECREF(tmp_class_creation_6__metaclass);
    tmp_class_creation_6__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_6__prepared);
    Py_DECREF(tmp_class_creation_6__prepared);
    tmp_class_creation_6__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_47;
        PyObject *tmp_tuple_element_19;
        PyObject *tmp_mvar_value_7;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeBase);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeBase);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 79774 ], 31, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 519;

            goto try_except_handler_19;
        }

        tmp_tuple_element_19 = tmp_mvar_value_7;
        tmp_assign_source_47 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_19);
        PyTuple_SET_ITEM(tmp_assign_source_47, 0, tmp_tuple_element_19);
        assert(tmp_class_creation_7__bases == NULL);
        tmp_class_creation_7__bases = tmp_assign_source_47;
    }
    {
        PyObject *tmp_assign_source_48;
        tmp_assign_source_48 = PyDict_New();
        assert(tmp_class_creation_7__class_decl_dict == NULL);
        tmp_class_creation_7__class_decl_dict = tmp_assign_source_48;
    }
    {
        PyObject *tmp_assign_source_49;
        PyObject *tmp_metaclass_name_7;
        nuitka_bool tmp_condition_result_78;
        PyObject *tmp_key_name_19;
        PyObject *tmp_dict_name_19;
        PyObject *tmp_dict_name_20;
        PyObject *tmp_key_name_20;
        PyObject *tmp_type_arg_10;
        PyObject *tmp_subscribed_name_4;
        PyObject *tmp_subscript_name_4;
        PyObject *tmp_bases_name_7;
        tmp_key_name_19 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_7__class_decl_dict);
        tmp_dict_name_19 = tmp_class_creation_7__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_19, tmp_key_name_19);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_19;
        }
        tmp_condition_result_78 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_78 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_60;
        } else {
            goto condexpr_false_60;
        }
        condexpr_true_60:;
        CHECK_OBJECT(tmp_class_creation_7__class_decl_dict);
        tmp_dict_name_20 = tmp_class_creation_7__class_decl_dict;
        tmp_key_name_20 = const_str_plain_metaclass;
        tmp_metaclass_name_7 = DICT_GET_ITEM(tmp_dict_name_20, tmp_key_name_20);
        if (tmp_metaclass_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_19;
        }
        goto condexpr_end_60;
        condexpr_false_60:;
        CHECK_OBJECT(tmp_class_creation_7__bases);
        tmp_subscribed_name_4 = tmp_class_creation_7__bases;
        tmp_subscript_name_4 = const_int_0;
        tmp_type_arg_10 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_4, tmp_subscript_name_4, 0);
        if (tmp_type_arg_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_19;
        }
        tmp_metaclass_name_7 = BUILTIN_TYPE1(tmp_type_arg_10);
        Py_DECREF(tmp_type_arg_10);
        if (tmp_metaclass_name_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_19;
        }
        condexpr_end_60:;
        CHECK_OBJECT(tmp_class_creation_7__bases);
        tmp_bases_name_7 = tmp_class_creation_7__bases;
        tmp_assign_source_49 = SELECT_METACLASS(tmp_metaclass_name_7, tmp_bases_name_7);
        Py_DECREF(tmp_metaclass_name_7);
        if (tmp_assign_source_49 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_19;
        }
        assert(tmp_class_creation_7__metaclass == NULL);
        tmp_class_creation_7__metaclass = tmp_assign_source_49;
    }
    {
        nuitka_bool tmp_condition_result_79;
        PyObject *tmp_key_name_21;
        PyObject *tmp_dict_name_21;
        tmp_key_name_21 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_7__class_decl_dict);
        tmp_dict_name_21 = tmp_class_creation_7__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_21, tmp_key_name_21);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_19;
        }
        tmp_condition_result_79 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_79 == NUITKA_BOOL_TRUE) {
            goto branch_yes_19;
        } else {
            goto branch_no_19;
        }
        branch_yes_19:;
        CHECK_OBJECT(tmp_class_creation_7__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_7__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_19;
        }
        branch_no_19:;
    }
    {
        nuitka_bool tmp_condition_result_80;
        PyObject *tmp_source_name_25;
        CHECK_OBJECT(tmp_class_creation_7__metaclass);
        tmp_source_name_25 = tmp_class_creation_7__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_25, const_str_plain___prepare__);
        tmp_condition_result_80 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_80 == NUITKA_BOOL_TRUE) {
            goto branch_yes_20;
        } else {
            goto branch_no_20;
        }
        branch_yes_20:;
        {
            PyObject *tmp_assign_source_50;
            PyObject *tmp_called_name_67;
            PyObject *tmp_source_name_26;
            PyObject *tmp_args_name_13;
            PyObject *tmp_tuple_element_20;
            PyObject *tmp_kw_name_13;
            CHECK_OBJECT(tmp_class_creation_7__metaclass);
            tmp_source_name_26 = tmp_class_creation_7__metaclass;
            tmp_called_name_67 = LOOKUP_ATTRIBUTE(tmp_source_name_26, const_str_plain___prepare__);
            if (tmp_called_name_67 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 519;

                goto try_except_handler_19;
            }
            tmp_tuple_element_20 = const_str_plain_ShapeIterator;
            tmp_args_name_13 = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_20);
            PyTuple_SET_ITEM(tmp_args_name_13, 0, tmp_tuple_element_20);
            CHECK_OBJECT(tmp_class_creation_7__bases);
            tmp_tuple_element_20 = tmp_class_creation_7__bases;
            Py_INCREF(tmp_tuple_element_20);
            PyTuple_SET_ITEM(tmp_args_name_13, 1, tmp_tuple_element_20);
            CHECK_OBJECT(tmp_class_creation_7__class_decl_dict);
            tmp_kw_name_13 = tmp_class_creation_7__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 519;
            tmp_assign_source_50 = CALL_FUNCTION(tmp_called_name_67, tmp_args_name_13, tmp_kw_name_13);
            Py_DECREF(tmp_called_name_67);
            Py_DECREF(tmp_args_name_13);
            if (tmp_assign_source_50 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 519;

                goto try_except_handler_19;
            }
            assert(tmp_class_creation_7__prepared == NULL);
            tmp_class_creation_7__prepared = tmp_assign_source_50;
        }
        {
            nuitka_bool tmp_condition_result_81;
            PyObject *tmp_operand_name_7;
            PyObject *tmp_source_name_27;
            CHECK_OBJECT(tmp_class_creation_7__prepared);
            tmp_source_name_27 = tmp_class_creation_7__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_27, const_str_plain___getitem__);
            tmp_operand_name_7 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_7);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 519;

                goto try_except_handler_19;
            }
            tmp_condition_result_81 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_81 == NUITKA_BOOL_TRUE) {
                goto branch_yes_21;
            } else {
                goto branch_no_21;
            }
            branch_yes_21:;
            {
                PyObject *tmp_raise_type_7;
                PyObject *tmp_raise_value_7;
                PyObject *tmp_left_name_7;
                PyObject *tmp_right_name_7;
                PyObject *tmp_tuple_element_21;
                PyObject *tmp_getattr_target_7;
                PyObject *tmp_getattr_attr_7;
                PyObject *tmp_getattr_default_7;
                PyObject *tmp_source_name_28;
                PyObject *tmp_type_arg_11;
                tmp_raise_type_7 = PyExc_TypeError;
                tmp_left_name_7 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_7__metaclass);
                tmp_getattr_target_7 = tmp_class_creation_7__metaclass;
                tmp_getattr_attr_7 = const_str_plain___name__;
                tmp_getattr_default_7 = const_str_angle_metaclass;
                tmp_tuple_element_21 = BUILTIN_GETATTR(tmp_getattr_target_7, tmp_getattr_attr_7, tmp_getattr_default_7);
                if (tmp_tuple_element_21 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 519;

                    goto try_except_handler_19;
                }
                tmp_right_name_7 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_7, 0, tmp_tuple_element_21);
                CHECK_OBJECT(tmp_class_creation_7__prepared);
                tmp_type_arg_11 = tmp_class_creation_7__prepared;
                tmp_source_name_28 = BUILTIN_TYPE1(tmp_type_arg_11);
                assert(!(tmp_source_name_28 == NULL));
                tmp_tuple_element_21 = LOOKUP_ATTRIBUTE(tmp_source_name_28, const_str_plain___name__);
                Py_DECREF(tmp_source_name_28);
                if (tmp_tuple_element_21 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_7);

                    exception_lineno = 519;

                    goto try_except_handler_19;
                }
                PyTuple_SET_ITEM(tmp_right_name_7, 1, tmp_tuple_element_21);
                tmp_raise_value_7 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_7, tmp_right_name_7);
                Py_DECREF(tmp_right_name_7);
                if (tmp_raise_value_7 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 519;

                    goto try_except_handler_19;
                }
                exception_type = tmp_raise_type_7;
                Py_INCREF(tmp_raise_type_7);
                exception_value = tmp_raise_value_7;
                exception_lineno = 519;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_19;
            }
            branch_no_21:;
        }
        goto branch_end_20;
        branch_no_20:;
        {
            PyObject *tmp_assign_source_51;
            tmp_assign_source_51 = PyDict_New();
            assert(tmp_class_creation_7__prepared == NULL);
            tmp_class_creation_7__prepared = tmp_assign_source_51;
        }
        branch_end_20:;
    }
    {
        PyObject *tmp_assign_source_52;
        {
            PyObject *tmp_set_locals_7;
            CHECK_OBJECT(tmp_class_creation_7__prepared);
            tmp_set_locals_7 = tmp_class_creation_7__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519 = tmp_set_locals_7;
            Py_INCREF(tmp_set_locals_7);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_21;
        }
        tmp_dictset_value = const_str_plain_ShapeIterator;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 519;

            goto try_except_handler_21;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_30d744ac1c2b5a81f536d4ad013b3e3a_8, codeobj_30d744ac1c2b5a81f536d4ad013b3e3a, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_30d744ac1c2b5a81f536d4ad013b3e3a_8 = cache_frame_30d744ac1c2b5a81f536d4ad013b3e3a_8;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_30d744ac1c2b5a81f536d4ad013b3e3a_8);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_30d744ac1c2b5a81f536d4ad013b3e3a_8) == 2); // Frame stack

        // Framed code:
        {
            nuitka_bool tmp_condition_result_82;
            PyObject *tmp_called_name_68;
            PyObject *tmp_args_element_name_54;
            PyObject *tmp_staticmethod_arg_18;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 520;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_82 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_82 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_61;
            } else {
                goto condexpr_false_61;
            }
            condexpr_true_61:;
            tmp_called_name_68 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_68 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 520;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_68 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 520;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_54 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_59_hasShapeSlotBool();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 520;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_68, tmp_args_element_name_54);
            Py_DECREF(tmp_called_name_68);
            Py_DECREF(tmp_args_element_name_54);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 520;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_61;
            condexpr_false_61:;
            tmp_staticmethod_arg_18 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_59_hasShapeSlotBool();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_18);
            Py_DECREF(tmp_staticmethod_arg_18);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 520;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_61:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotBool, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 520;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_83;
            PyObject *tmp_called_name_69;
            PyObject *tmp_args_element_name_55;
            PyObject *tmp_staticmethod_arg_19;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 524;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_83 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_83 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_62;
            } else {
                goto condexpr_false_62;
            }
            condexpr_true_62:;
            tmp_called_name_69 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_69 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 524;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_69 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 524;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_55 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_60_hasShapeSlotLen();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 524;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_69, tmp_args_element_name_55);
            Py_DECREF(tmp_called_name_69);
            Py_DECREF(tmp_args_element_name_55);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 524;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_62;
            condexpr_false_62:;
            tmp_staticmethod_arg_19 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_60_hasShapeSlotLen();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_19);
            Py_DECREF(tmp_staticmethod_arg_19);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 524;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_62:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotLen, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 524;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_84;
            PyObject *tmp_called_name_70;
            PyObject *tmp_args_element_name_56;
            PyObject *tmp_staticmethod_arg_20;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 528;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_84 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_84 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_63;
            } else {
                goto condexpr_false_63;
            }
            condexpr_true_63:;
            tmp_called_name_70 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_70 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 528;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_70 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 528;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_56 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_61_hasShapeSlotInt();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 528;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_70, tmp_args_element_name_56);
            Py_DECREF(tmp_called_name_70);
            Py_DECREF(tmp_args_element_name_56);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 528;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_63;
            condexpr_false_63:;
            tmp_staticmethod_arg_20 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_61_hasShapeSlotInt();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_20);
            Py_DECREF(tmp_staticmethod_arg_20);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 528;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_63:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotInt, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 528;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_85;
            PyObject *tmp_called_name_71;
            PyObject *tmp_args_element_name_57;
            PyObject *tmp_staticmethod_arg_21;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 532;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_85 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_85 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_64;
            } else {
                goto condexpr_false_64;
            }
            condexpr_true_64:;
            tmp_called_name_71 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_71 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 532;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_71 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 532;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_57 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_62_hasShapeSlotLong();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 532;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_71, tmp_args_element_name_57);
            Py_DECREF(tmp_called_name_71);
            Py_DECREF(tmp_args_element_name_57);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 532;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_64;
            condexpr_false_64:;
            tmp_staticmethod_arg_21 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_62_hasShapeSlotLong();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_21);
            Py_DECREF(tmp_staticmethod_arg_21);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 532;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_64:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotLong, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 532;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_86;
            PyObject *tmp_called_name_72;
            PyObject *tmp_args_element_name_58;
            PyObject *tmp_staticmethod_arg_22;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_86 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_86 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_65;
            } else {
                goto condexpr_false_65;
            }
            condexpr_true_65:;
            tmp_called_name_72 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_72 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_72 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_58 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_63_hasShapeSlotFloat();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 536;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_72, tmp_args_element_name_58);
            Py_DECREF(tmp_called_name_72);
            Py_DECREF(tmp_args_element_name_58);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_65;
            condexpr_false_65:;
            tmp_staticmethod_arg_22 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_63_hasShapeSlotFloat();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_22);
            Py_DECREF(tmp_staticmethod_arg_22);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_65:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotFloat, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 536;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_87;
            PyObject *tmp_called_name_73;
            PyObject *tmp_args_element_name_59;
            PyObject *tmp_staticmethod_arg_23;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 540;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_87 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_87 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_66;
            } else {
                goto condexpr_false_66;
            }
            condexpr_true_66:;
            tmp_called_name_73 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_73 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 540;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_73 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 540;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_59 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 540;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_73, tmp_args_element_name_59);
            Py_DECREF(tmp_called_name_73);
            Py_DECREF(tmp_args_element_name_59);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 540;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_66;
            condexpr_false_66:;
            tmp_staticmethod_arg_23 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_64_hasShapeSlotIter();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_23);
            Py_DECREF(tmp_staticmethod_arg_23);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 540;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_66:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotIter, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 540;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_88;
            PyObject *tmp_called_name_74;
            PyObject *tmp_args_element_name_60;
            PyObject *tmp_staticmethod_arg_24;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 544;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_88 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_88 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_67;
            } else {
                goto condexpr_false_67;
            }
            condexpr_true_67:;
            tmp_called_name_74 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_74 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 544;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_74 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 544;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_60 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 544;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_74, tmp_args_element_name_60);
            Py_DECREF(tmp_called_name_74);
            Py_DECREF(tmp_args_element_name_60);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 544;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_67;
            condexpr_false_67:;
            tmp_staticmethod_arg_24 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_65_hasShapeSlotNext();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_24);
            Py_DECREF(tmp_staticmethod_arg_24);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 544;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_67:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotNext, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 544;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_89;
            PyObject *tmp_called_name_75;
            PyObject *tmp_args_element_name_61;
            PyObject *tmp_staticmethod_arg_25;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 548;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_89 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_89 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_68;
            } else {
                goto condexpr_false_68;
            }
            condexpr_true_68:;
            tmp_called_name_75 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_75 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 548;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_75 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 548;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_61 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 548;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_75, tmp_args_element_name_61);
            Py_DECREF(tmp_called_name_75);
            Py_DECREF(tmp_args_element_name_61);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 548;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_68;
            condexpr_false_68:;
            tmp_staticmethod_arg_25 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_66_getShapeIter();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_25);
            Py_DECREF(tmp_staticmethod_arg_25);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 548;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_68:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_getShapeIter, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 548;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }
        {
            nuitka_bool tmp_condition_result_90;
            PyObject *tmp_called_name_76;
            PyObject *tmp_args_element_name_62;
            PyObject *tmp_staticmethod_arg_26;
            tmp_res = MAPPING_HAS_ITEM(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 552;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_condition_result_90 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_90 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_69;
            } else {
                goto condexpr_false_69;
            }
            condexpr_true_69:;
            tmp_called_name_76 = PyObject_GetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_staticmethod);

            if (tmp_called_name_76 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 6557 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 552;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }

            if (tmp_called_name_76 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 552;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            tmp_args_element_name_62 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains();



            frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame.f_lineno = 552;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_76, tmp_args_element_name_62);
            Py_DECREF(tmp_called_name_76);
            Py_DECREF(tmp_args_element_name_62);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 552;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            goto condexpr_end_69;
            condexpr_false_69:;
            tmp_staticmethod_arg_26 = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_67_hasShapeSlotContains();



            tmp_dictset_value = BUILTIN_STATICMETHOD(tmp_staticmethod_arg_26);
            Py_DECREF(tmp_staticmethod_arg_26);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 552;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
            condexpr_end_69:;
            tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519, const_str_plain_hasShapeSlotContains, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 552;
                type_description_2 = "o";
                goto frame_exception_exit_8;
            }
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_30d744ac1c2b5a81f536d4ad013b3e3a_8);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_7;

        frame_exception_exit_8:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_30d744ac1c2b5a81f536d4ad013b3e3a_8);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_30d744ac1c2b5a81f536d4ad013b3e3a_8, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_30d744ac1c2b5a81f536d4ad013b3e3a_8->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_30d744ac1c2b5a81f536d4ad013b3e3a_8, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_30d744ac1c2b5a81f536d4ad013b3e3a_8,
            type_description_2,
            outline_6_var___class__
        );


        // Release cached frame.
        if (frame_30d744ac1c2b5a81f536d4ad013b3e3a_8 == cache_frame_30d744ac1c2b5a81f536d4ad013b3e3a_8) {
            Py_DECREF(frame_30d744ac1c2b5a81f536d4ad013b3e3a_8);
        }
        cache_frame_30d744ac1c2b5a81f536d4ad013b3e3a_8 = NULL;

        assertFrameObject(frame_30d744ac1c2b5a81f536d4ad013b3e3a_8);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_7;

        frame_no_exception_7:;
        goto skip_nested_handling_7;
        nested_frame_exit_7:;

        goto try_except_handler_21;
        skip_nested_handling_7:;
        {
            PyObject *tmp_assign_source_53;
            PyObject *tmp_called_name_77;
            PyObject *tmp_args_name_14;
            PyObject *tmp_tuple_element_22;
            PyObject *tmp_kw_name_14;
            CHECK_OBJECT(tmp_class_creation_7__metaclass);
            tmp_called_name_77 = tmp_class_creation_7__metaclass;
            tmp_tuple_element_22 = const_str_plain_ShapeIterator;
            tmp_args_name_14 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_22);
            PyTuple_SET_ITEM(tmp_args_name_14, 0, tmp_tuple_element_22);
            CHECK_OBJECT(tmp_class_creation_7__bases);
            tmp_tuple_element_22 = tmp_class_creation_7__bases;
            Py_INCREF(tmp_tuple_element_22);
            PyTuple_SET_ITEM(tmp_args_name_14, 1, tmp_tuple_element_22);
            tmp_tuple_element_22 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519;
            Py_INCREF(tmp_tuple_element_22);
            PyTuple_SET_ITEM(tmp_args_name_14, 2, tmp_tuple_element_22);
            CHECK_OBJECT(tmp_class_creation_7__class_decl_dict);
            tmp_kw_name_14 = tmp_class_creation_7__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 519;
            tmp_assign_source_53 = CALL_FUNCTION(tmp_called_name_77, tmp_args_name_14, tmp_kw_name_14);
            Py_DECREF(tmp_args_name_14);
            if (tmp_assign_source_53 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 519;

                goto try_except_handler_21;
            }
            assert(outline_6_var___class__ == NULL);
            outline_6_var___class__ = tmp_assign_source_53;
        }
        CHECK_OBJECT(outline_6_var___class__);
        tmp_assign_source_52 = outline_6_var___class__;
        Py_INCREF(tmp_assign_source_52);
        goto try_return_handler_21;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_21:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519 = NULL;
        goto try_return_handler_20;
        // Exception handler code:
        try_except_handler_21:;
        exception_keeper_type_19 = exception_type;
        exception_keeper_value_19 = exception_value;
        exception_keeper_tb_19 = exception_tb;
        exception_keeper_lineno_19 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_519 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_19;
        exception_value = exception_keeper_value_19;
        exception_tb = exception_keeper_tb_19;
        exception_lineno = exception_keeper_lineno_19;

        goto try_except_handler_20;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_20:;
        CHECK_OBJECT((PyObject *)outline_6_var___class__);
        Py_DECREF(outline_6_var___class__);
        outline_6_var___class__ = NULL;

        goto outline_result_7;
        // Exception handler code:
        try_except_handler_20:;
        exception_keeper_type_20 = exception_type;
        exception_keeper_value_20 = exception_value;
        exception_keeper_tb_20 = exception_tb;
        exception_keeper_lineno_20 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_20;
        exception_value = exception_keeper_value_20;
        exception_tb = exception_keeper_tb_20;
        exception_lineno = exception_keeper_lineno_20;

        goto outline_exception_7;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_7:;
        exception_lineno = 519;
        goto try_except_handler_19;
        outline_result_7:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeIterator, tmp_assign_source_52);
    }
    goto try_end_7;
    // Exception handler code:
    try_except_handler_19:;
    exception_keeper_type_21 = exception_type;
    exception_keeper_value_21 = exception_value;
    exception_keeper_tb_21 = exception_tb;
    exception_keeper_lineno_21 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_7__bases);
    tmp_class_creation_7__bases = NULL;

    Py_XDECREF(tmp_class_creation_7__class_decl_dict);
    tmp_class_creation_7__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_7__prepared);
    tmp_class_creation_7__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_21;
    exception_value = exception_keeper_value_21;
    exception_tb = exception_keeper_tb_21;
    exception_lineno = exception_keeper_lineno_21;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_7__bases);
    Py_DECREF(tmp_class_creation_7__bases);
    tmp_class_creation_7__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__class_decl_dict);
    Py_DECREF(tmp_class_creation_7__class_decl_dict);
    tmp_class_creation_7__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__metaclass);
    Py_DECREF(tmp_class_creation_7__metaclass);
    tmp_class_creation_7__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_7__prepared);
    Py_DECREF(tmp_class_creation_7__prepared);
    tmp_class_creation_7__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_54;
        PyObject *tmp_tuple_element_23;
        PyObject *tmp_mvar_value_8;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeBase);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeBase);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 79774 ], 31, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 557;

            goto try_except_handler_22;
        }

        tmp_tuple_element_23 = tmp_mvar_value_8;
        tmp_assign_source_54 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_23);
        PyTuple_SET_ITEM(tmp_assign_source_54, 0, tmp_tuple_element_23);
        assert(tmp_class_creation_8__bases == NULL);
        tmp_class_creation_8__bases = tmp_assign_source_54;
    }
    {
        PyObject *tmp_assign_source_55;
        tmp_assign_source_55 = PyDict_New();
        assert(tmp_class_creation_8__class_decl_dict == NULL);
        tmp_class_creation_8__class_decl_dict = tmp_assign_source_55;
    }
    {
        PyObject *tmp_assign_source_56;
        PyObject *tmp_metaclass_name_8;
        nuitka_bool tmp_condition_result_91;
        PyObject *tmp_key_name_22;
        PyObject *tmp_dict_name_22;
        PyObject *tmp_dict_name_23;
        PyObject *tmp_key_name_23;
        PyObject *tmp_type_arg_12;
        PyObject *tmp_subscribed_name_5;
        PyObject *tmp_subscript_name_5;
        PyObject *tmp_bases_name_8;
        tmp_key_name_22 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_8__class_decl_dict);
        tmp_dict_name_22 = tmp_class_creation_8__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_22, tmp_key_name_22);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_22;
        }
        tmp_condition_result_91 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_91 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_70;
        } else {
            goto condexpr_false_70;
        }
        condexpr_true_70:;
        CHECK_OBJECT(tmp_class_creation_8__class_decl_dict);
        tmp_dict_name_23 = tmp_class_creation_8__class_decl_dict;
        tmp_key_name_23 = const_str_plain_metaclass;
        tmp_metaclass_name_8 = DICT_GET_ITEM(tmp_dict_name_23, tmp_key_name_23);
        if (tmp_metaclass_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_22;
        }
        goto condexpr_end_70;
        condexpr_false_70:;
        CHECK_OBJECT(tmp_class_creation_8__bases);
        tmp_subscribed_name_5 = tmp_class_creation_8__bases;
        tmp_subscript_name_5 = const_int_0;
        tmp_type_arg_12 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_5, tmp_subscript_name_5, 0);
        if (tmp_type_arg_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_22;
        }
        tmp_metaclass_name_8 = BUILTIN_TYPE1(tmp_type_arg_12);
        Py_DECREF(tmp_type_arg_12);
        if (tmp_metaclass_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_22;
        }
        condexpr_end_70:;
        CHECK_OBJECT(tmp_class_creation_8__bases);
        tmp_bases_name_8 = tmp_class_creation_8__bases;
        tmp_assign_source_56 = SELECT_METACLASS(tmp_metaclass_name_8, tmp_bases_name_8);
        Py_DECREF(tmp_metaclass_name_8);
        if (tmp_assign_source_56 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_22;
        }
        assert(tmp_class_creation_8__metaclass == NULL);
        tmp_class_creation_8__metaclass = tmp_assign_source_56;
    }
    {
        nuitka_bool tmp_condition_result_92;
        PyObject *tmp_key_name_24;
        PyObject *tmp_dict_name_24;
        tmp_key_name_24 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_8__class_decl_dict);
        tmp_dict_name_24 = tmp_class_creation_8__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_24, tmp_key_name_24);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_22;
        }
        tmp_condition_result_92 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_92 == NUITKA_BOOL_TRUE) {
            goto branch_yes_22;
        } else {
            goto branch_no_22;
        }
        branch_yes_22:;
        CHECK_OBJECT(tmp_class_creation_8__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_8__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_22;
        }
        branch_no_22:;
    }
    {
        nuitka_bool tmp_condition_result_93;
        PyObject *tmp_source_name_29;
        CHECK_OBJECT(tmp_class_creation_8__metaclass);
        tmp_source_name_29 = tmp_class_creation_8__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_29, const_str_plain___prepare__);
        tmp_condition_result_93 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_93 == NUITKA_BOOL_TRUE) {
            goto branch_yes_23;
        } else {
            goto branch_no_23;
        }
        branch_yes_23:;
        {
            PyObject *tmp_assign_source_57;
            PyObject *tmp_called_name_78;
            PyObject *tmp_source_name_30;
            PyObject *tmp_args_name_15;
            PyObject *tmp_tuple_element_24;
            PyObject *tmp_kw_name_15;
            CHECK_OBJECT(tmp_class_creation_8__metaclass);
            tmp_source_name_30 = tmp_class_creation_8__metaclass;
            tmp_called_name_78 = LOOKUP_ATTRIBUTE(tmp_source_name_30, const_str_plain___prepare__);
            if (tmp_called_name_78 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 557;

                goto try_except_handler_22;
            }
            tmp_tuple_element_24 = const_str_plain_ShapeLoopInitialAlternative;
            tmp_args_name_15 = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_24);
            PyTuple_SET_ITEM(tmp_args_name_15, 0, tmp_tuple_element_24);
            CHECK_OBJECT(tmp_class_creation_8__bases);
            tmp_tuple_element_24 = tmp_class_creation_8__bases;
            Py_INCREF(tmp_tuple_element_24);
            PyTuple_SET_ITEM(tmp_args_name_15, 1, tmp_tuple_element_24);
            CHECK_OBJECT(tmp_class_creation_8__class_decl_dict);
            tmp_kw_name_15 = tmp_class_creation_8__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 557;
            tmp_assign_source_57 = CALL_FUNCTION(tmp_called_name_78, tmp_args_name_15, tmp_kw_name_15);
            Py_DECREF(tmp_called_name_78);
            Py_DECREF(tmp_args_name_15);
            if (tmp_assign_source_57 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 557;

                goto try_except_handler_22;
            }
            assert(tmp_class_creation_8__prepared == NULL);
            tmp_class_creation_8__prepared = tmp_assign_source_57;
        }
        {
            nuitka_bool tmp_condition_result_94;
            PyObject *tmp_operand_name_8;
            PyObject *tmp_source_name_31;
            CHECK_OBJECT(tmp_class_creation_8__prepared);
            tmp_source_name_31 = tmp_class_creation_8__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_31, const_str_plain___getitem__);
            tmp_operand_name_8 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_8);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 557;

                goto try_except_handler_22;
            }
            tmp_condition_result_94 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_94 == NUITKA_BOOL_TRUE) {
                goto branch_yes_24;
            } else {
                goto branch_no_24;
            }
            branch_yes_24:;
            {
                PyObject *tmp_raise_type_8;
                PyObject *tmp_raise_value_8;
                PyObject *tmp_left_name_8;
                PyObject *tmp_right_name_8;
                PyObject *tmp_tuple_element_25;
                PyObject *tmp_getattr_target_8;
                PyObject *tmp_getattr_attr_8;
                PyObject *tmp_getattr_default_8;
                PyObject *tmp_source_name_32;
                PyObject *tmp_type_arg_13;
                tmp_raise_type_8 = PyExc_TypeError;
                tmp_left_name_8 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_8__metaclass);
                tmp_getattr_target_8 = tmp_class_creation_8__metaclass;
                tmp_getattr_attr_8 = const_str_plain___name__;
                tmp_getattr_default_8 = const_str_angle_metaclass;
                tmp_tuple_element_25 = BUILTIN_GETATTR(tmp_getattr_target_8, tmp_getattr_attr_8, tmp_getattr_default_8);
                if (tmp_tuple_element_25 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 557;

                    goto try_except_handler_22;
                }
                tmp_right_name_8 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_8, 0, tmp_tuple_element_25);
                CHECK_OBJECT(tmp_class_creation_8__prepared);
                tmp_type_arg_13 = tmp_class_creation_8__prepared;
                tmp_source_name_32 = BUILTIN_TYPE1(tmp_type_arg_13);
                assert(!(tmp_source_name_32 == NULL));
                tmp_tuple_element_25 = LOOKUP_ATTRIBUTE(tmp_source_name_32, const_str_plain___name__);
                Py_DECREF(tmp_source_name_32);
                if (tmp_tuple_element_25 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_8);

                    exception_lineno = 557;

                    goto try_except_handler_22;
                }
                PyTuple_SET_ITEM(tmp_right_name_8, 1, tmp_tuple_element_25);
                tmp_raise_value_8 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_8, tmp_right_name_8);
                Py_DECREF(tmp_right_name_8);
                if (tmp_raise_value_8 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 557;

                    goto try_except_handler_22;
                }
                exception_type = tmp_raise_type_8;
                Py_INCREF(tmp_raise_type_8);
                exception_value = tmp_raise_value_8;
                exception_lineno = 557;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_22;
            }
            branch_no_24:;
        }
        goto branch_end_23;
        branch_no_23:;
        {
            PyObject *tmp_assign_source_58;
            tmp_assign_source_58 = PyDict_New();
            assert(tmp_class_creation_8__prepared == NULL);
            tmp_class_creation_8__prepared = tmp_assign_source_58;
        }
        branch_end_23:;
    }
    {
        PyObject *tmp_assign_source_59;
        {
            PyObject *tmp_set_locals_8;
            CHECK_OBJECT(tmp_class_creation_8__prepared);
            tmp_set_locals_8 = tmp_class_creation_8__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557 = tmp_set_locals_8;
            Py_INCREF(tmp_set_locals_8);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_24;
        }
        tmp_dictset_value = const_str_digest_dc9c40641d6a52244eab03534e9b8d47;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain___doc__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_24;
        }
        tmp_dictset_value = const_str_plain_ShapeLoopInitialAlternative;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 557;

            goto try_except_handler_24;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_2562b0e500dd6b012dd5989b37851978_9, codeobj_2562b0e500dd6b012dd5989b37851978, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_2562b0e500dd6b012dd5989b37851978_9 = cache_frame_2562b0e500dd6b012dd5989b37851978_9;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_2562b0e500dd6b012dd5989b37851978_9);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_2562b0e500dd6b012dd5989b37851978_9) == 2); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_str_plain_type_shapes_tuple;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain___slots__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 568;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_68___init__();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 570;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_69_emitAlternatives();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_emitAlternatives, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 575;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_70__collectInitialShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain__collectInitialShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 579;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_71_getOperationBinaryAddShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryAddShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 595;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_72_getOperationBinarySubShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinarySubShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 608;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_73_getOperationBinaryMultShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryMultShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 621;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_74_getOperationBinaryFloorDivShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryFloorDivShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 634;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_75_getOperationBinaryOldDivShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryOldDivShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 647;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_76_getOperationBinaryTrueDivShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryTrueDivShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 660;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_77_getOperationBinaryModShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryModShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 673;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_78_getOperationBinaryPowShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryPowShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 686;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_79_getOperationBinaryLShiftShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryLShiftShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 699;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_80_getOperationBinaryRShiftShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryRShiftShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 712;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_81_getOperationBinaryBitOrShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryBitOrShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 725;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_82_getOperationBinaryBitAndShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryBitAndShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 738;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_83_getOperationBinaryBitXorShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryBitXorShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 751;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_84_getOperationBinaryMatMultShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getOperationBinaryMatMultShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 764;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_85_getComparisonLtShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getComparisonLtShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 777;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_86_getComparisonLteShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getComparisonLteShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 790;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_87_getComparisonGtShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getComparisonGtShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 793;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_88_getComparisonGteShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getComparisonGteShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 796;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_89_getComparisonEqShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getComparisonEqShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 799;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_90_getComparisonNeqShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557, const_str_plain_getComparisonNeqShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 802;
            type_description_2 = "o";
            goto frame_exception_exit_9;
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2562b0e500dd6b012dd5989b37851978_9);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_8;

        frame_exception_exit_9:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2562b0e500dd6b012dd5989b37851978_9);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_2562b0e500dd6b012dd5989b37851978_9, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_2562b0e500dd6b012dd5989b37851978_9->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_2562b0e500dd6b012dd5989b37851978_9, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_2562b0e500dd6b012dd5989b37851978_9,
            type_description_2,
            outline_7_var___class__
        );


        // Release cached frame.
        if (frame_2562b0e500dd6b012dd5989b37851978_9 == cache_frame_2562b0e500dd6b012dd5989b37851978_9) {
            Py_DECREF(frame_2562b0e500dd6b012dd5989b37851978_9);
        }
        cache_frame_2562b0e500dd6b012dd5989b37851978_9 = NULL;

        assertFrameObject(frame_2562b0e500dd6b012dd5989b37851978_9);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_8;

        frame_no_exception_8:;
        goto skip_nested_handling_8;
        nested_frame_exit_8:;

        goto try_except_handler_24;
        skip_nested_handling_8:;
        {
            PyObject *tmp_assign_source_60;
            PyObject *tmp_called_name_79;
            PyObject *tmp_args_name_16;
            PyObject *tmp_tuple_element_26;
            PyObject *tmp_kw_name_16;
            CHECK_OBJECT(tmp_class_creation_8__metaclass);
            tmp_called_name_79 = tmp_class_creation_8__metaclass;
            tmp_tuple_element_26 = const_str_plain_ShapeLoopInitialAlternative;
            tmp_args_name_16 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_26);
            PyTuple_SET_ITEM(tmp_args_name_16, 0, tmp_tuple_element_26);
            CHECK_OBJECT(tmp_class_creation_8__bases);
            tmp_tuple_element_26 = tmp_class_creation_8__bases;
            Py_INCREF(tmp_tuple_element_26);
            PyTuple_SET_ITEM(tmp_args_name_16, 1, tmp_tuple_element_26);
            tmp_tuple_element_26 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557;
            Py_INCREF(tmp_tuple_element_26);
            PyTuple_SET_ITEM(tmp_args_name_16, 2, tmp_tuple_element_26);
            CHECK_OBJECT(tmp_class_creation_8__class_decl_dict);
            tmp_kw_name_16 = tmp_class_creation_8__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 557;
            tmp_assign_source_60 = CALL_FUNCTION(tmp_called_name_79, tmp_args_name_16, tmp_kw_name_16);
            Py_DECREF(tmp_args_name_16);
            if (tmp_assign_source_60 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 557;

                goto try_except_handler_24;
            }
            assert(outline_7_var___class__ == NULL);
            outline_7_var___class__ = tmp_assign_source_60;
        }
        CHECK_OBJECT(outline_7_var___class__);
        tmp_assign_source_59 = outline_7_var___class__;
        Py_INCREF(tmp_assign_source_59);
        goto try_return_handler_24;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_24:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557 = NULL;
        goto try_return_handler_23;
        // Exception handler code:
        try_except_handler_24:;
        exception_keeper_type_22 = exception_type;
        exception_keeper_value_22 = exception_value;
        exception_keeper_tb_22 = exception_tb;
        exception_keeper_lineno_22 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_557 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_22;
        exception_value = exception_keeper_value_22;
        exception_tb = exception_keeper_tb_22;
        exception_lineno = exception_keeper_lineno_22;

        goto try_except_handler_23;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_23:;
        CHECK_OBJECT((PyObject *)outline_7_var___class__);
        Py_DECREF(outline_7_var___class__);
        outline_7_var___class__ = NULL;

        goto outline_result_8;
        // Exception handler code:
        try_except_handler_23:;
        exception_keeper_type_23 = exception_type;
        exception_keeper_value_23 = exception_value;
        exception_keeper_tb_23 = exception_tb;
        exception_keeper_lineno_23 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_23;
        exception_value = exception_keeper_value_23;
        exception_tb = exception_keeper_tb_23;
        exception_lineno = exception_keeper_lineno_23;

        goto outline_exception_8;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_8:;
        exception_lineno = 557;
        goto try_except_handler_22;
        outline_result_8:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopInitialAlternative, tmp_assign_source_59);
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_22:;
    exception_keeper_type_24 = exception_type;
    exception_keeper_value_24 = exception_value;
    exception_keeper_tb_24 = exception_tb;
    exception_keeper_lineno_24 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_8__bases);
    tmp_class_creation_8__bases = NULL;

    Py_XDECREF(tmp_class_creation_8__class_decl_dict);
    tmp_class_creation_8__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_8__prepared);
    tmp_class_creation_8__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_24;
    exception_value = exception_keeper_value_24;
    exception_tb = exception_keeper_tb_24;
    exception_lineno = exception_keeper_lineno_24;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_8__bases);
    Py_DECREF(tmp_class_creation_8__bases);
    tmp_class_creation_8__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__class_decl_dict);
    Py_DECREF(tmp_class_creation_8__class_decl_dict);
    tmp_class_creation_8__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__metaclass);
    Py_DECREF(tmp_class_creation_8__metaclass);
    tmp_class_creation_8__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_8__prepared);
    Py_DECREF(tmp_class_creation_8__prepared);
    tmp_class_creation_8__prepared = NULL;

    // Tried code:
    {
        PyObject *tmp_assign_source_61;
        PyObject *tmp_tuple_element_27;
        PyObject *tmp_mvar_value_9;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeBase);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeBase);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 79774 ], 31, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 806;

            goto try_except_handler_25;
        }

        tmp_tuple_element_27 = tmp_mvar_value_9;
        tmp_assign_source_61 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_27);
        PyTuple_SET_ITEM(tmp_assign_source_61, 0, tmp_tuple_element_27);
        assert(tmp_class_creation_9__bases == NULL);
        tmp_class_creation_9__bases = tmp_assign_source_61;
    }
    {
        PyObject *tmp_assign_source_62;
        tmp_assign_source_62 = PyDict_New();
        assert(tmp_class_creation_9__class_decl_dict == NULL);
        tmp_class_creation_9__class_decl_dict = tmp_assign_source_62;
    }
    {
        PyObject *tmp_assign_source_63;
        PyObject *tmp_metaclass_name_9;
        nuitka_bool tmp_condition_result_95;
        PyObject *tmp_key_name_25;
        PyObject *tmp_dict_name_25;
        PyObject *tmp_dict_name_26;
        PyObject *tmp_key_name_26;
        PyObject *tmp_type_arg_14;
        PyObject *tmp_subscribed_name_6;
        PyObject *tmp_subscript_name_6;
        PyObject *tmp_bases_name_9;
        tmp_key_name_25 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_9__class_decl_dict);
        tmp_dict_name_25 = tmp_class_creation_9__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_25, tmp_key_name_25);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_25;
        }
        tmp_condition_result_95 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_95 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_71;
        } else {
            goto condexpr_false_71;
        }
        condexpr_true_71:;
        CHECK_OBJECT(tmp_class_creation_9__class_decl_dict);
        tmp_dict_name_26 = tmp_class_creation_9__class_decl_dict;
        tmp_key_name_26 = const_str_plain_metaclass;
        tmp_metaclass_name_9 = DICT_GET_ITEM(tmp_dict_name_26, tmp_key_name_26);
        if (tmp_metaclass_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_25;
        }
        goto condexpr_end_71;
        condexpr_false_71:;
        CHECK_OBJECT(tmp_class_creation_9__bases);
        tmp_subscribed_name_6 = tmp_class_creation_9__bases;
        tmp_subscript_name_6 = const_int_0;
        tmp_type_arg_14 = LOOKUP_SUBSCRIPT_CONST(tmp_subscribed_name_6, tmp_subscript_name_6, 0);
        if (tmp_type_arg_14 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_25;
        }
        tmp_metaclass_name_9 = BUILTIN_TYPE1(tmp_type_arg_14);
        Py_DECREF(tmp_type_arg_14);
        if (tmp_metaclass_name_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_25;
        }
        condexpr_end_71:;
        CHECK_OBJECT(tmp_class_creation_9__bases);
        tmp_bases_name_9 = tmp_class_creation_9__bases;
        tmp_assign_source_63 = SELECT_METACLASS(tmp_metaclass_name_9, tmp_bases_name_9);
        Py_DECREF(tmp_metaclass_name_9);
        if (tmp_assign_source_63 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_25;
        }
        assert(tmp_class_creation_9__metaclass == NULL);
        tmp_class_creation_9__metaclass = tmp_assign_source_63;
    }
    {
        nuitka_bool tmp_condition_result_96;
        PyObject *tmp_key_name_27;
        PyObject *tmp_dict_name_27;
        tmp_key_name_27 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_9__class_decl_dict);
        tmp_dict_name_27 = tmp_class_creation_9__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_27, tmp_key_name_27);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_25;
        }
        tmp_condition_result_96 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_96 == NUITKA_BOOL_TRUE) {
            goto branch_yes_25;
        } else {
            goto branch_no_25;
        }
        branch_yes_25:;
        CHECK_OBJECT(tmp_class_creation_9__class_decl_dict);
        tmp_dictdel_dict = tmp_class_creation_9__class_decl_dict;
        tmp_dictdel_key = const_str_plain_metaclass;
        tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_25;
        }
        branch_no_25:;
    }
    {
        nuitka_bool tmp_condition_result_97;
        PyObject *tmp_source_name_33;
        CHECK_OBJECT(tmp_class_creation_9__metaclass);
        tmp_source_name_33 = tmp_class_creation_9__metaclass;
        tmp_res = PyObject_HasAttr(tmp_source_name_33, const_str_plain___prepare__);
        tmp_condition_result_97 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_97 == NUITKA_BOOL_TRUE) {
            goto branch_yes_26;
        } else {
            goto branch_no_26;
        }
        branch_yes_26:;
        {
            PyObject *tmp_assign_source_64;
            PyObject *tmp_called_name_80;
            PyObject *tmp_source_name_34;
            PyObject *tmp_args_name_17;
            PyObject *tmp_tuple_element_28;
            PyObject *tmp_kw_name_17;
            CHECK_OBJECT(tmp_class_creation_9__metaclass);
            tmp_source_name_34 = tmp_class_creation_9__metaclass;
            tmp_called_name_80 = LOOKUP_ATTRIBUTE(tmp_source_name_34, const_str_plain___prepare__);
            if (tmp_called_name_80 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 806;

                goto try_except_handler_25;
            }
            tmp_tuple_element_28 = const_str_plain_ShapeLoopCompleteAlternative;
            tmp_args_name_17 = PyTuple_New(2);
            Py_INCREF(tmp_tuple_element_28);
            PyTuple_SET_ITEM(tmp_args_name_17, 0, tmp_tuple_element_28);
            CHECK_OBJECT(tmp_class_creation_9__bases);
            tmp_tuple_element_28 = tmp_class_creation_9__bases;
            Py_INCREF(tmp_tuple_element_28);
            PyTuple_SET_ITEM(tmp_args_name_17, 1, tmp_tuple_element_28);
            CHECK_OBJECT(tmp_class_creation_9__class_decl_dict);
            tmp_kw_name_17 = tmp_class_creation_9__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 806;
            tmp_assign_source_64 = CALL_FUNCTION(tmp_called_name_80, tmp_args_name_17, tmp_kw_name_17);
            Py_DECREF(tmp_called_name_80);
            Py_DECREF(tmp_args_name_17);
            if (tmp_assign_source_64 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 806;

                goto try_except_handler_25;
            }
            assert(tmp_class_creation_9__prepared == NULL);
            tmp_class_creation_9__prepared = tmp_assign_source_64;
        }
        {
            nuitka_bool tmp_condition_result_98;
            PyObject *tmp_operand_name_9;
            PyObject *tmp_source_name_35;
            CHECK_OBJECT(tmp_class_creation_9__prepared);
            tmp_source_name_35 = tmp_class_creation_9__prepared;
            tmp_res = PyObject_HasAttr(tmp_source_name_35, const_str_plain___getitem__);
            tmp_operand_name_9 = (tmp_res != 0) ? Py_True : Py_False;
            tmp_res = CHECK_IF_TRUE(tmp_operand_name_9);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 806;

                goto try_except_handler_25;
            }
            tmp_condition_result_98 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_98 == NUITKA_BOOL_TRUE) {
                goto branch_yes_27;
            } else {
                goto branch_no_27;
            }
            branch_yes_27:;
            {
                PyObject *tmp_raise_type_9;
                PyObject *tmp_raise_value_9;
                PyObject *tmp_left_name_9;
                PyObject *tmp_right_name_9;
                PyObject *tmp_tuple_element_29;
                PyObject *tmp_getattr_target_9;
                PyObject *tmp_getattr_attr_9;
                PyObject *tmp_getattr_default_9;
                PyObject *tmp_source_name_36;
                PyObject *tmp_type_arg_15;
                tmp_raise_type_9 = PyExc_TypeError;
                tmp_left_name_9 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
                CHECK_OBJECT(tmp_class_creation_9__metaclass);
                tmp_getattr_target_9 = tmp_class_creation_9__metaclass;
                tmp_getattr_attr_9 = const_str_plain___name__;
                tmp_getattr_default_9 = const_str_angle_metaclass;
                tmp_tuple_element_29 = BUILTIN_GETATTR(tmp_getattr_target_9, tmp_getattr_attr_9, tmp_getattr_default_9);
                if (tmp_tuple_element_29 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 806;

                    goto try_except_handler_25;
                }
                tmp_right_name_9 = PyTuple_New(2);
                PyTuple_SET_ITEM(tmp_right_name_9, 0, tmp_tuple_element_29);
                CHECK_OBJECT(tmp_class_creation_9__prepared);
                tmp_type_arg_15 = tmp_class_creation_9__prepared;
                tmp_source_name_36 = BUILTIN_TYPE1(tmp_type_arg_15);
                assert(!(tmp_source_name_36 == NULL));
                tmp_tuple_element_29 = LOOKUP_ATTRIBUTE(tmp_source_name_36, const_str_plain___name__);
                Py_DECREF(tmp_source_name_36);
                if (tmp_tuple_element_29 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    Py_DECREF(tmp_right_name_9);

                    exception_lineno = 806;

                    goto try_except_handler_25;
                }
                PyTuple_SET_ITEM(tmp_right_name_9, 1, tmp_tuple_element_29);
                tmp_raise_value_9 = BINARY_OPERATION_MOD_UNICODE_TUPLE(tmp_left_name_9, tmp_right_name_9);
                Py_DECREF(tmp_right_name_9);
                if (tmp_raise_value_9 == NULL) {
                    assert(ERROR_OCCURRED());

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                    exception_lineno = 806;

                    goto try_except_handler_25;
                }
                exception_type = tmp_raise_type_9;
                Py_INCREF(tmp_raise_type_9);
                exception_value = tmp_raise_value_9;
                exception_lineno = 806;
                RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

                goto try_except_handler_25;
            }
            branch_no_27:;
        }
        goto branch_end_26;
        branch_no_26:;
        {
            PyObject *tmp_assign_source_65;
            tmp_assign_source_65 = PyDict_New();
            assert(tmp_class_creation_9__prepared == NULL);
            tmp_class_creation_9__prepared = tmp_assign_source_65;
        }
        branch_end_26:;
    }
    {
        PyObject *tmp_assign_source_66;
        {
            PyObject *tmp_set_locals_9;
            CHECK_OBJECT(tmp_class_creation_9__prepared);
            tmp_set_locals_9 = tmp_class_creation_9__prepared;
            locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806 = tmp_set_locals_9;
            Py_INCREF(tmp_set_locals_9);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_b2df44234e2ee51d521095a7fa337920;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_27;
        }
        tmp_dictset_value = const_str_digest_a5bfe47ce4ba19f54f28f4b3cc10be37;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain___doc__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_27;
        }
        tmp_dictset_value = const_str_plain_ShapeLoopCompleteAlternative;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 806;

            goto try_except_handler_27;
        }
        MAKE_OR_REUSE_FRAME(cache_frame_c1a664c66de179cd92cb9a38d83e5344_10, codeobj_c1a664c66de179cd92cb9a38d83e5344, module_site$$45$packages$nuitka$nodes$shapes$StandardShapes, sizeof(void *));
        frame_c1a664c66de179cd92cb9a38d83e5344_10 = cache_frame_c1a664c66de179cd92cb9a38d83e5344_10;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_c1a664c66de179cd92cb9a38d83e5344_10);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_c1a664c66de179cd92cb9a38d83e5344_10) == 2); // Frame stack

        // Framed code:
        tmp_dictset_value = const_tuple_str_plain_type_shapes_tuple;
        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain___slots__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 817;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_91___init__();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain___init__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 819;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_92_emitAlternatives();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_emitAlternatives, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 824;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_93__collectShapeOperation();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain__collectShapeOperation, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 828;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_94_getOperationBinaryAddShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryAddShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 867;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_95_getOperationBinarySubShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinarySubShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 877;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_96_getOperationBinaryMultShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryMultShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 887;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_97_getOperationBinaryFloorDivShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryFloorDivShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 897;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_98_getOperationBinaryOldDivShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryOldDivShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 907;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_99_getOperationBinaryTrueDivShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryTrueDivShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 917;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_100_getOperationBinaryModShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryModShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 927;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_101_getOperationBinaryPowShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryPowShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 937;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_102_getOperationBinaryLShiftShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryLShiftShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 947;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_103_getOperationBinaryRShiftShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryRShiftShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 957;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_104_getOperationBinaryBitOrShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryBitOrShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 967;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_105_getOperationBinaryBitAndShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryBitAndShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 977;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_106_getOperationBinaryBitXorShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryBitXorShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 987;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_107_getOperationBinaryMatMultShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryMatMultShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 997;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_108_getOperationBinaryAddLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryAddLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1009;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_109_getOperationBinarySubLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinarySubLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1018;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_110_getOperationBinaryMultLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryMultLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1025;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_111_getOperationBinaryFloorDivLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryFloorDivLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1032;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_112_getOperationBinaryOldDivLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryOldDivLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1039;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_113_getOperationBinaryTrueDivLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryTrueDivLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1046;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_114_getOperationBinaryModLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryModLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1053;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_115_getOperationBinaryPowLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryPowLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1060;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_116_getOperationBinaryLShiftLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryLShiftLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1067;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_117_getOperationBinaryRShiftLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryRShiftLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1074;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_118_getOperationBinaryBitOrLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryBitOrLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1081;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_119_getOperationBinaryBitAndLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryBitAndLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1088;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_120_getOperationBinaryBitXorLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryBitXorLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1095;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_121_getOperationBinaryMatMultLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getOperationBinaryMatMultLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1102;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_122_getComparisonLtShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getComparisonLtShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1109;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_123_getComparisonLtLShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getComparisonLtLShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1119;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_124_getComparisonLteShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getComparisonLteShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1124;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_125_getComparisonGtShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getComparisonGtShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1127;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_126_getComparisonGteShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getComparisonGteShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1130;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_127_getComparisonEqShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getComparisonEqShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1133;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_128_getComparisonNeqShape();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_getComparisonNeqShape, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1136;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_129__delegatedCheck();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain__delegatedCheck, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1139;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_130_hasShapeSlotBool();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotBool, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1160;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_131_hasShapeSlotLen();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotLen, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1163;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_132_hasShapeSlotIter();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotIter, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1166;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_133_hasShapeSlotNext();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotNext, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1169;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_134_hasShapeSlotContains();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotContains, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1172;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_135_hasShapeSlotInt();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotInt, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1175;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_136_hasShapeSlotLong();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotLong, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1178;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_137_hasShapeSlotFloat();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotFloat, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1181;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_138_hasShapeSlotComplex();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotComplex, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1184;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_139_hasShapeSlotBytes();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeSlotBytes, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1187;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }
        tmp_dictset_value = MAKE_FUNCTION_site$$45$packages$nuitka$nodes$shapes$StandardShapes$$$function_140_hasShapeModule();



        tmp_res = PyObject_SetItem(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806, const_str_plain_hasShapeModule, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1190;
            type_description_2 = "o";
            goto frame_exception_exit_10;
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_c1a664c66de179cd92cb9a38d83e5344_10);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_9;

        frame_exception_exit_10:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_c1a664c66de179cd92cb9a38d83e5344_10);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_c1a664c66de179cd92cb9a38d83e5344_10, exception_lineno);
        }
        else if (exception_tb->tb_frame != &frame_c1a664c66de179cd92cb9a38d83e5344_10->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_c1a664c66de179cd92cb9a38d83e5344_10, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            (struct Nuitka_FrameObject *)frame_c1a664c66de179cd92cb9a38d83e5344_10,
            type_description_2,
            outline_8_var___class__
        );


        // Release cached frame.
        if (frame_c1a664c66de179cd92cb9a38d83e5344_10 == cache_frame_c1a664c66de179cd92cb9a38d83e5344_10) {
            Py_DECREF(frame_c1a664c66de179cd92cb9a38d83e5344_10);
        }
        cache_frame_c1a664c66de179cd92cb9a38d83e5344_10 = NULL;

        assertFrameObject(frame_c1a664c66de179cd92cb9a38d83e5344_10);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_9;

        frame_no_exception_9:;
        goto skip_nested_handling_9;
        nested_frame_exit_9:;

        goto try_except_handler_27;
        skip_nested_handling_9:;
        {
            PyObject *tmp_assign_source_67;
            PyObject *tmp_called_name_81;
            PyObject *tmp_args_name_18;
            PyObject *tmp_tuple_element_30;
            PyObject *tmp_kw_name_18;
            CHECK_OBJECT(tmp_class_creation_9__metaclass);
            tmp_called_name_81 = tmp_class_creation_9__metaclass;
            tmp_tuple_element_30 = const_str_plain_ShapeLoopCompleteAlternative;
            tmp_args_name_18 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_30);
            PyTuple_SET_ITEM(tmp_args_name_18, 0, tmp_tuple_element_30);
            CHECK_OBJECT(tmp_class_creation_9__bases);
            tmp_tuple_element_30 = tmp_class_creation_9__bases;
            Py_INCREF(tmp_tuple_element_30);
            PyTuple_SET_ITEM(tmp_args_name_18, 1, tmp_tuple_element_30);
            tmp_tuple_element_30 = locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806;
            Py_INCREF(tmp_tuple_element_30);
            PyTuple_SET_ITEM(tmp_args_name_18, 2, tmp_tuple_element_30);
            CHECK_OBJECT(tmp_class_creation_9__class_decl_dict);
            tmp_kw_name_18 = tmp_class_creation_9__class_decl_dict;
            frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame.f_lineno = 806;
            tmp_assign_source_67 = CALL_FUNCTION(tmp_called_name_81, tmp_args_name_18, tmp_kw_name_18);
            Py_DECREF(tmp_args_name_18);
            if (tmp_assign_source_67 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 806;

                goto try_except_handler_27;
            }
            assert(outline_8_var___class__ == NULL);
            outline_8_var___class__ = tmp_assign_source_67;
        }
        CHECK_OBJECT(outline_8_var___class__);
        tmp_assign_source_66 = outline_8_var___class__;
        Py_INCREF(tmp_assign_source_66);
        goto try_return_handler_27;
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_27:;
        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806 = NULL;
        goto try_return_handler_26;
        // Exception handler code:
        try_except_handler_27:;
        exception_keeper_type_25 = exception_type;
        exception_keeper_value_25 = exception_value;
        exception_keeper_tb_25 = exception_tb;
        exception_keeper_lineno_25 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806);
        locals_site$$45$packages$nuitka$nodes$shapes$StandardShapes_806 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_25;
        exception_value = exception_keeper_value_25;
        exception_tb = exception_keeper_tb_25;
        exception_lineno = exception_keeper_lineno_25;

        goto try_except_handler_26;
        // End of try:
        // tried codes exits in all cases
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        // Return handler code:
        try_return_handler_26:;
        CHECK_OBJECT((PyObject *)outline_8_var___class__);
        Py_DECREF(outline_8_var___class__);
        outline_8_var___class__ = NULL;

        goto outline_result_9;
        // Exception handler code:
        try_except_handler_26:;
        exception_keeper_type_26 = exception_type;
        exception_keeper_value_26 = exception_value;
        exception_keeper_tb_26 = exception_tb;
        exception_keeper_lineno_26 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_26;
        exception_value = exception_keeper_value_26;
        exception_tb = exception_keeper_tb_26;
        exception_lineno = exception_keeper_lineno_26;

        goto outline_exception_9;
        // End of try:
        // Return statement must have exited already.
        NUITKA_CANNOT_GET_HERE(site$$45$packages$nuitka$nodes$shapes$StandardShapes);
        return NULL;
        outline_exception_9:;
        exception_lineno = 806;
        goto try_except_handler_25;
        outline_result_9:;
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeLoopCompleteAlternative, tmp_assign_source_66);
    }
    goto try_end_9;
    // Exception handler code:
    try_except_handler_25:;
    exception_keeper_type_27 = exception_type;
    exception_keeper_value_27 = exception_value;
    exception_keeper_tb_27 = exception_tb;
    exception_keeper_lineno_27 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_9__bases);
    tmp_class_creation_9__bases = NULL;

    Py_XDECREF(tmp_class_creation_9__class_decl_dict);
    tmp_class_creation_9__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_9__prepared);
    tmp_class_creation_9__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_27;
    exception_value = exception_keeper_value_27;
    exception_tb = exception_keeper_tb_27;
    exception_lineno = exception_keeper_lineno_27;

    goto frame_exception_exit_1;
    // End of try:
    try_end_9:;
    CHECK_OBJECT((PyObject *)tmp_class_creation_9__bases);
    Py_DECREF(tmp_class_creation_9__bases);
    tmp_class_creation_9__bases = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__class_decl_dict);
    Py_DECREF(tmp_class_creation_9__class_decl_dict);
    tmp_class_creation_9__class_decl_dict = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__metaclass);
    Py_DECREF(tmp_class_creation_9__metaclass);
    tmp_class_creation_9__metaclass = NULL;

    CHECK_OBJECT((PyObject *)tmp_class_creation_9__prepared);
    Py_DECREF(tmp_class_creation_9__prepared);
    tmp_class_creation_9__prepared = NULL;

    {
        PyObject *tmp_assign_source_68;
        PyObject *tmp_tuple_element_31;
        PyObject *tmp_mvar_value_10;
        PyObject *tmp_mvar_value_11;
        tmp_mvar_value_10 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);

        if (unlikely(tmp_mvar_value_10 == NULL)) {
            tmp_mvar_value_10 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ShapeUnknown);
        }

        if (tmp_mvar_value_10 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 31712 ], 34, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1194;

            goto frame_exception_exit_1;
        }

        tmp_tuple_element_31 = tmp_mvar_value_10;
        tmp_assign_source_68 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_31);
        PyTuple_SET_ITEM(tmp_assign_source_68, 0, tmp_tuple_element_31);
        tmp_mvar_value_11 = GET_STRING_DICT_VALUE(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);

        if (unlikely(tmp_mvar_value_11 == NULL)) {
            tmp_mvar_value_11 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_ControlFlowDescriptionFullEscape);
        }

        if (tmp_mvar_value_11 == NULL) {
            Py_DECREF(tmp_assign_source_68);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 86086 ], 54, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1194;

            goto frame_exception_exit_1;
        }

        tmp_tuple_element_31 = tmp_mvar_value_11;
        Py_INCREF(tmp_tuple_element_31);
        PyTuple_SET_ITEM(tmp_assign_source_68, 1, tmp_tuple_element_31);
        UPDATE_STRING_DICT1(moduledict_site$$45$packages$nuitka$nodes$shapes$StandardShapes, (Nuitka_StringObject *)const_str_plain_operation_result_unknown, tmp_assign_source_68);
    }

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbcacf0dd7105f7e77a454cdc3975a6d);
#endif
    popFrameStack();

    assertFrameObject(frame_fbcacf0dd7105f7e77a454cdc3975a6d);

    goto frame_no_exception_10;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbcacf0dd7105f7e77a454cdc3975a6d);
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK(frame_fbcacf0dd7105f7e77a454cdc3975a6d, exception_lineno);
    }
    else if (exception_tb->tb_frame != &frame_fbcacf0dd7105f7e77a454cdc3975a6d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fbcacf0dd7105f7e77a454cdc3975a6d, exception_lineno);
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_10:;

    return module_site$$45$packages$nuitka$nodes$shapes$StandardShapes;
    module_exception_exit:
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
    return NULL;
}
